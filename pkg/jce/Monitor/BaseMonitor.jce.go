// Package Monitor comment
// This file was generated by jce2go 2.0.0
// Generated from BaseMonitor.jce
package Monitor

import (
	"fmt"

	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// SystemMonitorInfo struct implement
type SystemMonitorInfo struct {
	codec.JceStructBase
	MemTotal     int32   `json:"memTotal"`
	MemFree      int32   `json:"memFree"`
	MemAvailable int32   `json:"memAvailable"`
	SwapTotal    int32   `json:"swapTotal"`
	SwapFree     int32   `json:"swapFree"`
	FCPURate     float32 `json:"fCPURate"`
}

func (st *SystemMonitorInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.MemTotal = 0
	st.MemFree = 0
	st.MemAvailable = 0
	st.SwapTotal = 0
	st.SwapFree = 0
	st.FCPURate = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *SystemMonitorInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.MemTotal, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.MemFree, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.MemAvailable, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.SwapTotal, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.SwapFree, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FCPURate, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SystemMonitorInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SystemMonitorInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SystemMonitorInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.MemTotal, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.MemFree, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.MemAvailable, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.SwapTotal, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.SwapFree, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FCPURate, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SystemMonitorInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SystemMonitorInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("memTotal:", st.MemTotal)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("memFree:", st.MemFree)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("memAvailable:", st.MemAvailable)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("swapTotal:", st.SwapTotal)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("swapFree:", st.SwapFree)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fCPURate:", st.FCPURate)

	ret = ret + " }"
	return ret
}

// ProcessMonitorInfo struct implement
type ProcessMonitorInfo struct {
	codec.JceStructBase
	NPid             int64   `json:"nPid"`
	VmPeak           int32   `json:"vmPeak"`
	VmSize           int32   `json:"vmSize"`
	VmHWM            int32   `json:"vmHWM"`
	VmRSS            int32   `json:"vmRSS"`
	ThreadNum        int32   `json:"threadNum"`
	FProgressCPURate float32 `json:"fProgressCPURate"`
	SRunPath         string  `json:"sRunPath"`
}

func (st *ProcessMonitorInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.NPid = 0
	st.VmPeak = 0
	st.VmSize = 0
	st.VmHWM = 0
	st.VmRSS = 0
	st.ThreadNum = 0
	st.FProgressCPURate = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *ProcessMonitorInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.NPid, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.VmPeak, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.VmSize, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.VmHWM, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.VmRSS, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ThreadNum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FProgressCPURate, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SRunPath, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ProcessMonitorInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ProcessMonitorInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ProcessMonitorInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.NPid, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.VmPeak, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.VmSize, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.VmHWM, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.VmRSS, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ThreadNum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FProgressCPURate, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SRunPath, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ProcessMonitorInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *ProcessMonitorInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("nPid:", st.NPid)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vmPeak:", st.VmPeak)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vmSize:", st.VmSize)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vmHWM:", st.VmHWM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vmRSS:", st.VmRSS)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("threadNum:", st.ThreadNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fProgressCPURate:", st.FProgressCPURate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sRunPath:", st.SRunPath)

	ret = ret + " }"
	return ret
}

// CPULoadAvaInfo struct implement
type CPULoadAvaInfo struct {
	codec.JceStructBase
	F1MinLoadAvg  float32 `json:"f1MinLoadAvg"`
	F5MinLoadAvg  float32 `json:"f5MinLoadAvg"`
	F15MinLoadAvg float32 `json:"f15MinLoadAvg"`
	NCPUCoreNum   int32   `json:"nCPUCoreNum"`
}

func (st *CPULoadAvaInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.F1MinLoadAvg = 0.0
	st.F5MinLoadAvg = 0.0
	st.F15MinLoadAvg = 0.0
	st.NCPUCoreNum = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *CPULoadAvaInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float32(&st.F1MinLoadAvg, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.F5MinLoadAvg, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.F15MinLoadAvg, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.NCPUCoreNum, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CPULoadAvaInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CPULoadAvaInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CPULoadAvaInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float32(st.F1MinLoadAvg, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.F5MinLoadAvg, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.F15MinLoadAvg, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.NCPUCoreNum, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CPULoadAvaInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *CPULoadAvaInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("f1MinLoadAvg:", st.F1MinLoadAvg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f5MinLoadAvg:", st.F5MinLoadAvg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f15MinLoadAvg:", st.F15MinLoadAvg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nCPUCoreNum:", st.NCPUCoreNum)

	ret = ret + " }"
	return ret
}

// DiskInfo struct implement
type DiskInfo struct {
	codec.JceStructBase
	LFileType       int64   `json:"lFileType"`
	SPermission     string  `json:"sPermission"`
	Disk_total_size float32 `json:"disk_total_size"`
	Disk_free_size  float32 `json:"disk_free_size"`
}

func (st *DiskInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.LFileType = 0
	st.Disk_total_size = 0
	st.Disk_free_size = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *DiskInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LFileType, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SPermission, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.Disk_total_size, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.Disk_free_size, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DiskInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DiskInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DiskInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LFileType, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SPermission, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.Disk_total_size, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.Disk_free_size, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DiskInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *DiskInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lFileType:", st.LFileType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sPermission:", st.SPermission)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("disk_total_size:", st.Disk_total_size)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("disk_free_size:", st.Disk_free_size)

	ret = ret + " }"
	return ret
}

// HMCvtMarketInfo struct implement
type HMCvtMarketInfo struct {
	codec.JceStructBase
	NMarket int16 `json:"nMarket"`
	NFlag   int32 `json:"nFlag"`
}

func (st *HMCvtMarketInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMCvtMarketInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.NMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.NFlag, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMCvtMarketInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMCvtMarketInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMCvtMarketInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.NMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.NFlag, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMCvtMarketInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMCvtMarketInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("nMarket:", st.NMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nFlag:", st.NFlag)

	ret = ret + " }"
	return ret
}

// CvtMonitInfo struct implement
type CvtMonitInfo struct {
	codec.JceStructBase
	StrVer       string                       `json:"strVer"`
	StrStartTime string                       `json:"strStartTime"`
	BlnListen    bool                         `json:"blnListen"`
	StrUpIp      string                       `json:"strUpIp"`
	ShtUpPort    int16                        `json:"shtUpPort"`
	IUpTradeDate int32                        `json:"iUpTradeDate"`
	IUpTradeTime int32                        `json:"iUpTradeTime"`
	MapDiskInfo  map[string]DiskInfo          `json:"mapDiskInfo"`
	MapOther     map[string]string            `json:"mapOther"`
	SysInfo      SystemMonitorInfo            `json:"sysInfo"`
	ProcessInfo  ProcessMonitorInfo           `json:"processInfo"`
	CpuLoadAvg   CPULoadAvaInfo               `json:"cpuLoadAvg"`
	NMSTime      int64                        `json:"nMSTime"`
	NStartMSTime int64                        `json:"nStartMSTime"`
	MMCvtUpAddr  map[string][]HMCvtMarketInfo `json:"mMCvtUpAddr"`
	SName        string                       `json:"sName"`
}

func (st *CvtMonitInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BlnListen = false
	st.SysInfo.ResetDefault()
	st.ProcessInfo.ResetDefault()
	st.CpuLoadAvg.ResetDefault()
	st.NMSTime = 0
	st.NStartMSTime = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *CvtMonitInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.StrVer, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.StrStartTime, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BlnListen, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.StrUpIp, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtUpPort, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpTradeDate, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpTradeTime, 6, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 7, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapDiskInfo = make(map[string]DiskInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 DiskInfo

			err = _is.Read_string(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapDiskInfo[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 8, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapOther = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = _is.Read_string(&k1, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v1, 1, false)
			if err != nil {
				return err
			}

			st.MapOther[k1] = v1
		}
	}

	err = st.SysInfo.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.ProcessInfo.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = st.CpuLoadAvg.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.NMSTime, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.NStartMSTime, 13, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 14, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MMCvtUpAddr = make(map[string][]HMCvtMarketInfo)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 []HMCvtMarketInfo

			err = _is.Read_string(&k2, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v2 = make([]HMCvtMarketInfo, length)
					for i3, e3 := int32(0), length; i3 < e3; i3++ {

						err = v2[i3].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.MMCvtUpAddr[k2] = v2
		}
	}

	err = _is.Read_string(&st.SName, 15, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CvtMonitInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CvtMonitInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CvtMonitInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.StrVer, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.StrStartTime, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BlnListen, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.StrUpIp, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtUpPort, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpTradeDate, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpTradeTime, 6)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapDiskInfo)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.MapDiskInfo {

		err = _os.Write_string(k4, 0)
		if err != nil {
			return err
		}

		err = v4.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapOther)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.MapOther {

		err = _os.Write_string(k5, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v5, 1)
		if err != nil {
			return err
		}

	}

	err = st.SysInfo.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.ProcessInfo.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = st.CpuLoadAvg.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.NMSTime, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.NStartMSTime, 13)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MMCvtUpAddr)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.MMCvtUpAddr {

		err = _os.Write_string(k6, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v6)), 0)
		if err != nil {
			return err
		}

		for _, v := range v6 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	err = _os.Write_string(st.SName, 15)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CvtMonitInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *CvtMonitInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("strVer:", st.StrVer)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("strStartTime:", st.StrStartTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("blnListen:", st.BlnListen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("strUpIp:", st.StrUpIp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtUpPort:", st.ShtUpPort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpTradeDate:", st.IUpTradeDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpTradeTime:", st.IUpTradeTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapDiskInfo:", st.MapDiskInfo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapOther:", st.MapOther)
	ret = ret + ",  "
	ret = ret + "sysInfo:" + st.SysInfo.Display()
	ret = ret + ",  "
	ret = ret + "processInfo:" + st.ProcessInfo.Display()
	ret = ret + ",  "
	ret = ret + "cpuLoadAvg:" + st.CpuLoadAvg.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nMSTime:", st.NMSTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nStartMSTime:", st.NStartMSTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mMCvtUpAddr:", st.MMCvtUpAddr)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)

	ret = ret + " }"
	return ret
}

// HTradePeriod struct implement
type HTradePeriod struct {
	codec.JceStructBase
	M_nBegDate int32 `json:"m_nBegDate"`
	M_nBegTime int32 `json:"m_nBegTime"`
	M_nEndDate int32 `json:"m_nEndDate"`
	M_nEndTime int32 `json:"m_nEndTime"`
}

func (st *HTradePeriod) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.M_nBegDate = 0
	st.M_nBegTime = 0
	st.M_nEndDate = 0
	st.M_nEndTime = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HTradePeriod) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.M_nBegDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.M_nBegTime, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.M_nEndDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.M_nEndTime, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTradePeriod) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTradePeriod, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTradePeriod) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.M_nBegDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.M_nBegTime, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.M_nEndDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.M_nEndTime, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTradePeriod) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTradePeriod) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("m_nBegDate:", st.M_nBegDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m_nBegTime:", st.M_nBegTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m_nEndDate:", st.M_nEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m_nEndTime:", st.M_nEndTime)

	ret = ret + " }"
	return ret
}

// HMarketTimeInfo struct implement
type HMarketTimeInfo struct {
	codec.JceStructBase
	NTradeSequence int32          `json:"nTradeSequence"`
	NDate          int32          `json:"nDate"`
	NTime          int32          `json:"nTime"`
	CTradeFlag     int8           `json:"cTradeFlag"`
	VecPeriod      []HTradePeriod `json:"vecPeriod"`
}

func (st *HMarketTimeInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.NTradeSequence = 0
	st.NDate = 0
	st.NTime = 0
	st.CTradeFlag = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketTimeInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.NTradeSequence, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.NDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.NTime, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CTradeFlag, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecPeriod = make([]HTradePeriod, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VecPeriod[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketTimeInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketTimeInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketTimeInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.NTradeSequence, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.NDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.NTime, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CTradeFlag, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecPeriod)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecPeriod {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketTimeInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketTimeInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("nTradeSequence:", st.NTradeSequence)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nDate:", st.NDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nTime:", st.NTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cTradeFlag:", st.CTradeFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecPeriod:", st.VecPeriod)

	ret = ret + " }"
	return ret
}

// ServerMonitorInfo struct implement
type ServerMonitorInfo struct {
	codec.JceStructBase
	SVersion          string            `json:"sVersion"`
	NFileDataLoadTime int32             `json:"nFileDataLoadTime"`
	MapOther          map[string]string `json:"mapOther"`
	SName             string            `json:"sName"`
}

func (st *ServerMonitorInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.NFileDataLoadTime = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *ServerMonitorInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SVersion, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.NFileDataLoadTime, 1, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapOther = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = _is.Read_string(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MapOther[k0] = v0
		}
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ServerMonitorInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ServerMonitorInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ServerMonitorInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SVersion, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.NFileDataLoadTime, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapOther)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapOther {

		err = _os.Write_string(k1, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v1, 1)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ServerMonitorInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *ServerMonitorInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sVersion:", st.SVersion)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nFileDataLoadTime:", st.NFileDataLoadTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapOther:", st.MapOther)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)

	ret = ret + " }"
	return ret
}

// SysMonitorInfo struct implement
type SysMonitorInfo struct {
	codec.JceStructBase
	NMSTime      int64               `json:"nMSTime"`
	NStartMSTime int64               `json:"nStartMSTime"`
	SysInfo      SystemMonitorInfo   `json:"sysInfo"`
	ProcessInfo  ProcessMonitorInfo  `json:"processInfo"`
	CpuLoadAvg   CPULoadAvaInfo      `json:"cpuLoadAvg"`
	MapDiskInfo  map[string]DiskInfo `json:"mapDiskInfo"`
	ServerInfo   ServerMonitorInfo   `json:"serverInfo"`
}

func (st *SysMonitorInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.NMSTime = 0
	st.NStartMSTime = 0
	st.SysInfo.ResetDefault()
	st.ProcessInfo.ResetDefault()
	st.CpuLoadAvg.ResetDefault()
	st.ServerInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SysMonitorInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.NMSTime, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.NStartMSTime, 1, false)
	if err != nil {
		return err
	}

	err = st.SysInfo.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.ProcessInfo.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.CpuLoadAvg.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 5, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapDiskInfo = make(map[string]DiskInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 DiskInfo

			err = _is.Read_string(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapDiskInfo[k0] = v0
		}
	}

	err = st.ServerInfo.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SysMonitorInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SysMonitorInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SysMonitorInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.NMSTime, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.NStartMSTime, 1)
	if err != nil {
		return err
	}

	err = st.SysInfo.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.ProcessInfo.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.CpuLoadAvg.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapDiskInfo)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapDiskInfo {

		err = _os.Write_string(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	err = st.ServerInfo.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SysMonitorInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SysMonitorInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("nMSTime:", st.NMSTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nStartMSTime:", st.NStartMSTime)
	ret = ret + ",  "
	ret = ret + "sysInfo:" + st.SysInfo.Display()
	ret = ret + ",  "
	ret = ret + "processInfo:" + st.ProcessInfo.Display()
	ret = ret + ",  "
	ret = ret + "cpuLoadAvg:" + st.CpuLoadAvg.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapDiskInfo:", st.MapDiskInfo)
	ret = ret + ",  "
	ret = ret + "serverInfo:" + st.ServerInfo.Display()

	ret = ret + " }"
	return ret
}
