// Package HQSys comment
// This file was generated by jce2go 2.0.0
// Generated from BasicHq.jce
package HQSys

import (
	"fmt"

	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/codec"
	"hq/pkg/jce/Monitor"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type E_PUSH_FUNC_TYPE int32

const (
	E_PUSH_FUNC_TYPE_E_FUNC_HQ_PUSH            = 1
	E_PUSH_FUNC_TYPE_E_FUNC_CODES_PUSH         = 2
	E_PUSH_FUNC_TYPE_E_FUNC_MARKET_INIT        = 3
	E_PUSH_FUNC_TYPE_E_FUNC_CPT_MIN            = 4
	E_PUSH_FUNC_TYPE_E_FUNC_ALIST_PUSH         = 5
	E_PUSH_FUNC_TYPE_E_FUNC_MLIST_PUSH         = 6
	E_PUSH_FUNC_TYPE_E_FUNC_KLINE_PUSH         = 7
	E_PUSH_FUNC_TYPE_E_FUNC_ORDER_QUEUE_PUSH   = 8
	E_PUSH_FUNC_TYPE_E_FUNC_TRANSACTION_PUSH   = 9
	E_PUSH_FUNC_TYPE_E_FUNC_ORDER_REC_PUSH     = 10
	E_PUSH_FUNC_TYPE_E_FUNC_PRICE_ORDER_PUSH   = 11
	E_PUSH_FUNC_TYPE_E_FUNC_PRICE_AMOUNT_PUSH  = 12
	E_PUSH_FUNC_TYPE_E_FUNC_BROKER_QUEUE_PUSH  = 13
	E_PUSH_FUNC_TYPE_E_FUNC_REG_STATUS_PUSH    = 14
	E_PUSH_FUNC_TYPE_E_FUNC_MONEY_FLOW_PUSH    = 15
	E_PUSH_FUNC_TYPE_E_FUNC_ZH_RANK_PUSH       = 16
	E_PUSH_FUNC_TYPE_E_FUNC_FUNDFLOW_RANK_PUSH = 17
	E_PUSH_FUNC_TYPE_E_FUNC_BLOCK_RANK_PUSH    = 18
	E_PUSH_FUNC_TYPE_E_FUNC_AOPTLIST_PUSH      = 19
	E_PUSH_FUNC_TYPE_E_FUNC_MOPTLIST_PUSH      = 20
	E_PUSH_FUNC_TYPE_E_FUNC_OPT_STOCK_PUSH     = 21
	E_PUSH_FUNC_TYPE_E_FUNC_RADAR_LIST_PUSH    = 22
	E_PUSH_FUNC_TYPE_E_FUNC_SHORT_LINE_PUSH    = 23
	E_PUSH_FUNC_TYPE_E_FUNC_VOLPRICE_PUSH      = 24
	E_PUSH_FUNC_TYPE_E_FUNC_ALLORDERPERSP_PUSH = 25
	E_PUSH_FUNC_TYPE_E_FUNC_TICK_PUSH          = 26
	E_PUSH_FUNC_TYPE_E_FUNC_ALISTSORT_PUSH     = 27
	E_PUSH_FUNC_TYPE_E_FUNC_MONITOR_PUSH       = 28
	E_PUSH_FUNC_TYPE_E_FUNC_RTMIN_AUCTION_PUSH = 29
	E_PUSH_FUNC_TYPE_E_FUNC_RTMIN_PUSH         = 30
	E_PUSH_FUNC_TYPE_E_FUNC_SNFUND_PUSH        = 31
	E_PUSH_FUNC_TYPE_E_FUNC_SNNETDATA_PUSH     = 32
	E_PUSH_FUNC_TYPE_E_FUNC_ORDER_BOOK         = 33
	E_PUSH_FUNC_TYPE_E_FUNC_ZDFENBU_PUSH       = 34
)

type E_MD_COMPRESS_TYPE int32

const (
	E_MD_COMPRESS_TYPE_E_MD_NO_COMPRESS     = 0
	E_MD_COMPRESS_TYPE_E_MD_COMPRESS_LZ4    = 1
	E_MD_COMPRESS_TYPE_E_MD_COMPRESS_LZMA   = 2
	E_MD_COMPRESS_TYPE_E_MD_COMPRESS_SNAPPY = 3
)

type BASIC_HQ_RET int32

const (
	BASIC_HQ_RET_BASIC_HQ_OK                   = 0
	BASIC_HQ_RET_BASIC_HQ_NO_CHANGE            = 1
	BASIC_HQ_RET_BASIC_HQ_INVALID_LEN          = -1
	BASIC_HQ_RET_BASIC_HQ_LOGIN_FAILED         = -2
	BASIC_HQ_RET_BASIC_HQ_NO_PERMISSION        = -3
	BASIC_HQ_RET_BASIC_HQ_INVALID_MARKET       = -4
	BASIC_HQ_RET_BASIC_HQ_INVALID_PROTOCOL     = -5
	BASIC_HQ_RET_BASIC_HQ_INVALID_TIME         = -6
	BASIC_HQ_RET_BASIC_HQ_SERVER_NOT_READY     = -7
	BASIC_HQ_RET_BASIC_HQ_INCOMING_DATA_ERR    = -8
	BASIC_HQ_RET_BASIC_HQ_SERVER_DATA_ERR      = -9
	BASIC_HQ_RET_BASIC_HQ_SERVER_NO_DATA       = -10
	BASIC_HQ_RET_BASIC_HQ_SERVER_NO_PRE_HISDAY = -11
	BASIC_HQ_RET_BASIC_HQ_INVALID_PARAM        = -21
	BASIC_HQ_RET_BASIC_HQ_GET_LOCK_ERR         = -22
	BASIC_HQ_RET_BASIC_HQ_GET_DATA_ERR         = -23
	BASIC_HQ_RET_BASIC_HQ_UNKNOWN              = -99
)

type E_CURRENCY_TYPE int32

const (
	E_CURRENCY_TYPE_E_CN_YUAN     = 1
	E_CURRENCY_TYPE_E_HK_DOLLAR   = 2
	E_CURRENCY_TYPE_E_US_DOLLAR   = 3
	E_CURRENCY_TYPE_E_JP_DOLLAR   = 4
	E_CURRENCY_TYPE_E_EN_POUND    = 5
	E_CURRENCY_TYPE_E_EURO_DOLLAR = 6
	E_CURRENCY_TYPE_E_SWISS_FRANC = 7
	E_CURRENCY_TYPE_E_CA_DOLLAR   = 8
)

type E_TYPE_MMP int32

const (
	E_TYPE_MMP_E_MMP_NONE         = 0
	E_TYPE_MMP_E_MMP_ENABLE       = 1
	E_TYPE_MMP_E_MMP_SINGLE_PRICE = 2
	E_TYPE_MMP_E_WEIBI_LIANGBI    = 4
)

type E_HQ_PUSH_REG int32

const (
	E_HQ_PUSH_REG_E_HQ_PUSH_NONE    = 0
	E_HQ_PUSH_REG_E_HQ_PUSH_REQUIRE = 1
	E_HQ_PUSH_REG_E_HQ_PUSH_CANCEL  = 2
)

type E_KLINERSP_TYPE int32

const (
	E_KLINERSP_TYPE_E_KLINERSP_SIMPLE = 0
	E_KLINERSP_TYPE_E_KLINERSP_EXT1   = 1
)

type E_LOGIN_STATUS int32

const (
	E_LOGIN_STATUS_E_LOGIN_STAT_OK                = 0
	E_LOGIN_STATUS_E_LOGIN_STAT_FAILED            = 1
	E_LOGIN_STATUS_E_LOGIN_STAT_OVERDUE           = 2
	E_LOGIN_STATUS_E_LOGIN_STAT_DUP               = 3
	E_LOGIN_STATUS_E_LOGIN_STAT_NO_RIGHT          = 4
	E_LOGIN_STATUS_E_LOGIN_STAT_TOKEN_INVALID     = 5
	E_LOGIN_STATUS_E_LOGIN_STAT_TOKEN_ERROR       = 6
	E_LOGIN_STATUS_E_LOGIN_STAT_USERID_INVALID    = 7
	E_LOGIN_STATUS_E_LOGIN_STAT_USERID_NO_MATCH   = 8
	E_LOGIN_STATUS_E_LOGIN_STAT_PLAT_NO_MATCH     = 9
	E_LOGIN_STATUS_E_LOGIN_STAT_OEM_TOKEN_INVALID = 10
)

type E_CLT_INFO_STATUS int32

const (
	E_CLT_INFO_STATUS_E_CLT_INFO_OK  = 0
	E_CLT_INFO_STATUS_E_CLT_INFO_ERR = 1
)

type E_TRANS_DATA_TYPE int32

const (
	E_TRANS_DATA_TYPE_E_TRANS_DATA_NORMAL = 0
	E_TRANS_DATA_TYPE_E_TRANS_DATA_BIG    = 1
)

type E_ORDER_REC_TYPE int32

const (
	E_ORDER_REC_TYPE_E_ORDER_REC_NORMAL     = 0
	E_ORDER_REC_TYPE_E_ORDER_REC_BIG        = 1
	E_ORDER_REC_TYPE_E_ORDER_REC_CANCEL     = 2
	E_ORDER_REC_TYPE_E_ORDER_REC_CANCEL_BIG = 3
)

//const as define in taf jce
const (
	CONTEXT_CONNECTION     string = "serialNo"
	CONTEXT_PUSH_REQ       string = "pushRegID"
	CONTEXT_REG_FLAG       string = "regFlag"
	CONTEXT_RCV_TIME       string = "pushRecvTime"
	CONTEXT_DIFF_PACKET    string = "diffPacket"
	CONTEXT_RESP_STR       string = "responseStr"
	CONTEXT_REQ_CACHE_KEY  string = "cacheKey"
	CONTEXT_RES_PACKTYPE   string = "responsePackType"
	CONTEXT_CONN_TYPE      string = "connType"
	CONTEXT_RCV_HEART_TIME string = "recvHeartReqTime"
	CONTEXT_RSP_HEART_TIME string = "rspHeartTime"
)

// MockReqBasic struct implement
type MockReqBasic struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *MockReqBasic) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MockReqBasic) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MockReqBasic) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MockReqBasic, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MockReqBasic) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MockReqBasic) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *MockReqBasic) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HCloseNoticeData struct implement
type HCloseNoticeData struct {
	codec.JceStructBase
	VReqId    []int64 `json:"vReqId"`
	VUserConn []int64 `json:"vUserConn"`
}

func (st *HCloseNoticeData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCloseNoticeData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VReqId = make([]int64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int64(&st.VReqId[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VUserConn = make([]int64, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int64(&st.VUserConn[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCloseNoticeData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCloseNoticeData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCloseNoticeData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VReqId)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VReqId {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VUserConn)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VUserConn {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCloseNoticeData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCloseNoticeData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vReqId:", st.VReqId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vUserConn:", st.VUserConn)

	ret = ret + " }"
	return ret
}

// HStockMFlowReq struct implement
type HStockMFlowReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	SCode    string     `json:"sCode"`
}

func (st *HStockMFlowReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockMFlowReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockMFlowReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockMFlowReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockMFlowReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockMFlowReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockMFlowReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)

	ret = ret + " }"
	return ret
}

// HStockMFlowRsp struct implement
type HStockMFlowRsp struct {
	codec.JceStructBase
	SttStockMFlow HTolMoneyFlow `json:"sttStockMFlow"`
}

func (st *HStockMFlowRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.SttStockMFlow.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockMFlowRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.SttStockMFlow.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockMFlowRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockMFlowRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockMFlowRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.SttStockMFlow.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockMFlowRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockMFlowRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "sttStockMFlow:" + st.SttStockMFlow.Display()

	ret = ret + " }"
	return ret
}

// HStockMFlowBatchReq struct implement
type HStockMFlowBatchReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HStockMFlowBatchReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockMFlowBatchReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockMFlowBatchReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockMFlowBatchReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockMFlowBatchReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockMFlowBatchReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockMFlowBatchReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HStockMFlowBatchRsp struct implement
type HStockMFlowBatchRsp struct {
	codec.JceStructBase
	VStockMFlow []HTolMoneyFlow `json:"vStockMFlow"`
}

func (st *HStockMFlowBatchRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockMFlowBatchRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockMFlow = make([]HTolMoneyFlow, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockMFlow[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockMFlowBatchRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockMFlowBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockMFlowBatchRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockMFlow)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockMFlow {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockMFlowBatchRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockMFlowBatchRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockMFlow:", st.VStockMFlow)

	ret = ret + " }"
	return ret
}

// HRTMinDataReq struct implement
type HRTMinDataReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	SCode     string        `json:"sCode"`
	IStartPos int32         `json:"iStartPos"`
	BAuction  bool          `json:"bAuction"`
	ShtVer    int16         `json:"shtVer"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HRTMinDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IStartPos = 0
	st.BAuction = false
	st.ShtVer = 0
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HRTMinDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BAuction, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtVer, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRTMinDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRTMinDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRTMinDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BAuction, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtVer, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRTMinDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRTMinDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bAuction:", st.BAuction)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtVer:", st.ShtVer)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HRTMinDataRsp struct implement
type HRTMinDataRsp struct {
	codec.JceStructBase
	VRTMinData []HRTMinData `json:"vRTMinData"`
	DClose     float64      `json:"dClose"`
	IDate      int32        `json:"iDate"`
	SCode      string       `json:"sCode"`
	ShtSetcode int16        `json:"shtSetcode"`
	IDateExt   int32        `json:"iDateExt"`
}

func (st *HRTMinDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IDateExt = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HRTMinDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRTMinData = make([]HRTMinData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRTMinData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_float64(&st.DClose, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDateExt, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRTMinDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRTMinDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRTMinDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRTMinData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRTMinData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_float64(st.DClose, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDateExt, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRTMinDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRTMinDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vRTMinData:", st.VRTMinData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dClose:", st.DClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDateExt:", st.IDateExt)

	ret = ret + " }"
	return ret
}

// HRTMinDataSimpleReq struct implement
type HRTMinDataSimpleReq struct {
	codec.JceStructBase
	Req     HRTMinDataReq `json:"req"`
	VBitmap []int8        `json:"vBitmap"`
}

func (st *HRTMinDataSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Req.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRTMinDataSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Req.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRTMinDataSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRTMinDataSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRTMinDataSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Req.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRTMinDataSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRTMinDataSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "req:" + st.Req.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HRTMinDataSimpleRsp struct implement
type HRTMinDataSimpleRsp struct {
	codec.JceStructBase
	VRTMinData []HRTMinDataSimple `json:"vRTMinData"`
	DClose     float64            `json:"dClose"`
	IDate      int32              `json:"iDate"`
	SCode      string             `json:"sCode"`
	ShtSetcode int16              `json:"shtSetcode"`
	IDateExt   int32              `json:"iDateExt"`
}

func (st *HRTMinDataSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IDateExt = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HRTMinDataSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRTMinData = make([]HRTMinDataSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRTMinData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_float64(&st.DClose, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDateExt, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRTMinDataSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRTMinDataSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRTMinDataSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRTMinData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRTMinData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_float64(st.DClose, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDateExt, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRTMinDataSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRTMinDataSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vRTMinData:", st.VRTMinData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dClose:", st.DClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDateExt:", st.IDateExt)

	ret = ret + " }"
	return ret
}

// HHisMinuteReq struct implement
type HHisMinuteReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo `json:"stHeader"`
	SCode     string     `json:"sCode"`
	IDate     int32      `json:"iDate"`
	BAuction  bool       `json:"bAuction"`
	IStartPos int32      `json:"iStartPos"`
	BAtp      bool       `json:"bAtp"`
	ShtVer    int16      `json:"shtVer"`
}

func (st *HHisMinuteReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.BAuction = false
	st.IStartPos = 0
	st.BAtp = false
	st.ShtVer = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisMinuteReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BAuction, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BAtp, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtVer, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisMinuteReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisMinuteReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisMinuteReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BAuction, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BAtp, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtVer, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisMinuteReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisMinuteReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bAuction:", st.BAuction)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bAtp:", st.BAtp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtVer:", st.ShtVer)

	ret = ret + " }"
	return ret
}

// HHisMinuteRsp struct implement
type HHisMinuteRsp struct {
	codec.JceStructBase
	DClose      float64      `json:"dClose"`
	VMinuteData []HRTMinData `json:"vMinuteData"`
	IDate       int32        `json:"iDate"`
	IDateExt    int32        `json:"iDateExt"`
}

func (st *HHisMinuteRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IDateExt = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisMinuteRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DClose, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMinuteData = make([]HRTMinData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMinuteData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDateExt, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisMinuteRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisMinuteRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisMinuteRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DClose, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMinuteData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMinuteData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDateExt, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisMinuteRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisMinuteRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dClose:", st.DClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMinuteData:", st.VMinuteData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDateExt:", st.IDateExt)

	ret = ret + " }"
	return ret
}

// HHisMinuteSimpleReq struct implement
type HHisMinuteSimpleReq struct {
	codec.JceStructBase
	Req     HHisMinuteReq `json:"req"`
	VBitmap []int8        `json:"vBitmap"`
}

func (st *HHisMinuteSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Req.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisMinuteSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Req.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisMinuteSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisMinuteSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisMinuteSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Req.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisMinuteSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisMinuteSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "req:" + st.Req.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HHisMinuteSimpleRsp struct implement
type HHisMinuteSimpleRsp struct {
	codec.JceStructBase
	DClose      float64            `json:"dClose"`
	VMinuteData []HRTMinDataSimple `json:"vMinuteData"`
	IDate       int32              `json:"iDate"`
	IDateExt    int32              `json:"iDateExt"`
}

func (st *HHisMinuteSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IDateExt = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisMinuteSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DClose, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMinuteData = make([]HRTMinDataSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMinuteData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDateExt, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisMinuteSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisMinuteSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisMinuteSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DClose, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMinuteData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMinuteData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDateExt, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisMinuteSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisMinuteSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dClose:", st.DClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMinuteData:", st.VMinuteData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDateExt:", st.IDateExt)

	ret = ret + " }"
	return ret
}

// HHisMinBatchReq struct implement
type HHisMinBatchReq struct {
	codec.JceStructBase
	StHeader     HeaderInfo `json:"stHeader"`
	SCode        string     `json:"sCode"`
	IDate        int32      `json:"iDate"`
	INum         int32      `json:"iNum"`
	BAuction     bool       `json:"bAuction"`
	BContainLast bool       `json:"bContainLast"`
	ShtVer       int16      `json:"shtVer"`
}

func (st *HHisMinBatchReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.BAuction = false
	st.BContainLast = false
	st.ShtVer = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisMinBatchReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.INum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BAuction, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BContainLast, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtVer, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisMinBatchReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisMinBatchReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisMinBatchReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.INum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BAuction, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BContainLast, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtVer, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisMinBatchReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisMinBatchReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNum:", st.INum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bAuction:", st.BAuction)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bContainLast:", st.BContainLast)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtVer:", st.ShtVer)

	ret = ret + " }"
	return ret
}

// HHisMinBatchRsp struct implement
type HHisMinBatchRsp struct {
	codec.JceStructBase
	MClose   map[int32]float64      `json:"mClose"`
	MMinData map[int32][]HRTMinData `json:"mMinData"`
	MDateExt map[int32]int32        `json:"mDateExt"`
}

func (st *HHisMinBatchRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisMinBatchRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MClose = make(map[int32]float64)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 float64

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_float64(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MClose[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MMinData = make(map[int32][]HRTMinData)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 []HRTMinData

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v1 = make([]HRTMinData, length)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {

						err = v1[i2].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.MMinData[k1] = v1
		}
	}

	err, have = _is.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MDateExt = make(map[int32]int32)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 int32
			var v3 int32

			err = _is.Read_int32(&k3, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&v3, 1, false)
			if err != nil {
				return err
			}

			st.MDateExt[k3] = v3
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisMinBatchRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisMinBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisMinBatchRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MClose)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.MClose {

		err = _os.Write_int32(k4, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(v4, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MMinData)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.MMinData {

		err = _os.Write_int32(k5, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v5)), 0)
		if err != nil {
			return err
		}

		for _, v := range v5 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MDateExt)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.MDateExt {

		err = _os.Write_int32(k6, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(v6, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisMinBatchRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisMinBatchRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mClose:", st.MClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mMinData:", st.MMinData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mDateExt:", st.MDateExt)

	ret = ret + " }"
	return ret
}

// HHisMinBatchSimpleReq struct implement
type HHisMinBatchSimpleReq struct {
	codec.JceStructBase
	Req     HHisMinBatchReq `json:"req"`
	VBitmap []int8          `json:"vBitmap"`
}

func (st *HHisMinBatchSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Req.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisMinBatchSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Req.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisMinBatchSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisMinBatchSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisMinBatchSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Req.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisMinBatchSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisMinBatchSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "req:" + st.Req.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HHisMinBatchSimpleRsp struct implement
type HHisMinBatchSimpleRsp struct {
	codec.JceStructBase
	MClose   map[int32]float64            `json:"mClose"`
	MMinData map[int32][]HRTMinDataSimple `json:"mMinData"`
	MDateExt map[int32]int32              `json:"mDateExt"`
}

func (st *HHisMinBatchSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisMinBatchSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MClose = make(map[int32]float64)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 float64

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_float64(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MClose[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MMinData = make(map[int32][]HRTMinDataSimple)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 []HRTMinDataSimple

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v1 = make([]HRTMinDataSimple, length)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {

						err = v1[i2].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.MMinData[k1] = v1
		}
	}

	err, have = _is.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MDateExt = make(map[int32]int32)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 int32
			var v3 int32

			err = _is.Read_int32(&k3, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&v3, 1, false)
			if err != nil {
				return err
			}

			st.MDateExt[k3] = v3
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisMinBatchSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisMinBatchSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisMinBatchSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MClose)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.MClose {

		err = _os.Write_int32(k4, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(v4, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MMinData)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.MMinData {

		err = _os.Write_int32(k5, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v5)), 0)
		if err != nil {
			return err
		}

		for _, v := range v5 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MDateExt)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.MDateExt {

		err = _os.Write_int32(k6, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(v6, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisMinBatchSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisMinBatchSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mClose:", st.MClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mMinData:", st.MMinData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mDateExt:", st.MDateExt)

	ret = ret + " }"
	return ret
}

// HKLineDataReq struct implement
type HKLineDataReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo        `json:"stHeader"`
	SCode      string            `json:"sCode"`
	ELineType  HISTORY_DATA_TYPE `json:"eLineType"`
	ShtStartxh int16             `json:"shtStartxh"`
	ShtWantNum int16             `json:"shtWantNum"`
	BXRXDFlag  bool              `json:"bXRXDFlag"`
	BSameUnit  bool              `json:"bSameUnit"`
	EQxMode    E_QX_MODE         `json:"eQxMode"`
	LDate      int64             `json:"lDate"`
	ShtTypeRsp E_KLINERSP_TYPE   `json:"shtTypeRsp"`
}

func (st *HKLineDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
	st.BXRXDFlag = false
	st.BSameUnit = false
	st.EQxMode = E_QX_MODE_EQM_QX_NONE
	st.LDate = 0
	st.ShtTypeRsp = E_KLINERSP_TYPE_E_KLINERSP_SIMPLE
}

//ReadFrom reads  from _is and put into struct.
func (st *HKLineDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ELineType), 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BXRXDFlag, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BSameUnit, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EQxMode), 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LDate, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ShtTypeRsp), 9, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKLineDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKLineDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKLineDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ELineType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BXRXDFlag, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BSameUnit, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EQxMode), 7)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LDate, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ShtTypeRsp), 9)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKLineDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKLineDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eLineType:", st.ELineType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bXRXDFlag:", st.BXRXDFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bSameUnit:", st.BSameUnit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eQxMode:", st.EQxMode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lDate:", st.LDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtTypeRsp:", st.ShtTypeRsp)

	ret = ret + " }"
	return ret
}

// HKLineDataRsp struct implement
type HKLineDataRsp struct {
	codec.JceStructBase
	VAnalyData []HAnalyData `json:"vAnalyData"`
}

func (st *HKLineDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HKLineDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VAnalyData = make([]HAnalyData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VAnalyData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKLineDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKLineDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKLineDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VAnalyData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VAnalyData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKLineDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKLineDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vAnalyData:", st.VAnalyData)

	ret = ret + " }"
	return ret
}

// HKLineDataSimpleReq struct implement
type HKLineDataSimpleReq struct {
	codec.JceStructBase
	Req     HKLineDataReq `json:"req"`
	VBitmap []int8        `json:"vBitmap"`
}

func (st *HKLineDataSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Req.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HKLineDataSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Req.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKLineDataSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKLineDataSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKLineDataSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Req.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKLineDataSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKLineDataSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "req:" + st.Req.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HKLineDataSimpleRsp struct implement
type HKLineDataSimpleRsp struct {
	codec.JceStructBase
	VData []HCQAnalyDataSimple `json:"vData"`
}

func (st *HKLineDataSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HKLineDataSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HCQAnalyDataSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKLineDataSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKLineDataSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKLineDataSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKLineDataSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKLineDataSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// HRegKLineReq struct implement
type HRegKLineReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo        `json:"stHeader"`
	SCode     string            `json:"sCode"`
	ELineType HISTORY_DATA_TYPE `json:"eLineType"`
	LDate     int64             `json:"lDate"`
	IWantNum  int32             `json:"iWantNum"`
	EPushFlag E_HQ_PUSH_REG     `json:"ePushFlag"`
	BXRXDFlag bool              `json:"bXRXDFlag"`
}

func (st *HRegKLineReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IWantNum = 100
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.BXRXDFlag = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegKLineReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ELineType), 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BXRXDFlag, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegKLineReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegKLineReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegKLineReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ELineType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BXRXDFlag, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegKLineReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegKLineReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eLineType:", st.ELineType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lDate:", st.LDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bXRXDFlag:", st.BXRXDFlag)

	ret = ret + " }"
	return ret
}

// HRegKLineSimpleReq struct implement
type HRegKLineSimpleReq struct {
	codec.JceStructBase
	Req     HRegKLineReq `json:"req"`
	VBitmap []int8       `json:"vBitmap"`
}

func (st *HRegKLineSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Req.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegKLineSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Req.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegKLineSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegKLineSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegKLineSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Req.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegKLineSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegKLineSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "req:" + st.Req.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HRegKLineRsp struct implement
type HRegKLineRsp struct {
	codec.JceStructBase
	VAnalyData []HCQAnalyData `json:"vAnalyData"`
}

func (st *HRegKLineRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegKLineRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VAnalyData = make([]HCQAnalyData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VAnalyData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegKLineRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegKLineRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegKLineRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VAnalyData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VAnalyData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegKLineRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegKLineRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vAnalyData:", st.VAnalyData)

	ret = ret + " }"
	return ret
}

// HRegKLineSimpleRsp struct implement
type HRegKLineSimpleRsp struct {
	codec.JceStructBase
	VData []HCQAnalyDataSimple `json:"vData"`
}

func (st *HRegKLineSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegKLineSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HCQAnalyDataSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegKLineSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegKLineSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegKLineSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegKLineSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegKLineSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// HKLineDataByPeriodReq struct implement
type HKLineDataByPeriodReq struct {
	codec.JceStructBase
	StHeader         HeaderInfo         `json:"stHeader"`
	VStockDatePeriod []HStockDatePeriod `json:"vStockDatePeriod"`
	ELineType        HISTORY_DATA_TYPE  `json:"eLineType"`
	BXRXDFlag        bool               `json:"bXRXDFlag"`
}

func (st *HKLineDataByPeriodReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.BXRXDFlag = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HKLineDataByPeriodReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStockDatePeriod = make([]HStockDatePeriod, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStockDatePeriod[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_int32((*int32)(&st.ELineType), 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BXRXDFlag, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKLineDataByPeriodReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKLineDataByPeriodReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKLineDataByPeriodReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockDatePeriod)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockDatePeriod {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.ELineType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BXRXDFlag, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKLineDataByPeriodReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKLineDataByPeriodReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStockDatePeriod:", st.VStockDatePeriod)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eLineType:", st.ELineType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bXRXDFlag:", st.BXRXDFlag)

	ret = ret + " }"
	return ret
}

// HKLineDataByPeriodRsp struct implement
type HKLineDataByPeriodRsp struct {
	codec.JceStructBase
	VStockAnalyData []HStockAnalyData `json:"vStockAnalyData"`
}

func (st *HKLineDataByPeriodRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HKLineDataByPeriodRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockAnalyData = make([]HStockAnalyData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockAnalyData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKLineDataByPeriodRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKLineDataByPeriodRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKLineDataByPeriodRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockAnalyData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockAnalyData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKLineDataByPeriodRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKLineDataByPeriodRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockAnalyData:", st.VStockAnalyData)

	ret = ret + " }"
	return ret
}

// HKLineDataByPeriodSimpleReq struct implement
type HKLineDataByPeriodSimpleReq struct {
	codec.JceStructBase
	Req     HKLineDataByPeriodReq `json:"req"`
	VBitmap []int8                `json:"vBitmap"`
}

func (st *HKLineDataByPeriodSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Req.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HKLineDataByPeriodSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Req.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKLineDataByPeriodSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKLineDataByPeriodSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKLineDataByPeriodSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Req.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKLineDataByPeriodSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKLineDataByPeriodSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "req:" + st.Req.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HKLineDataByPeriodSimpleRsp struct implement
type HKLineDataByPeriodSimpleRsp struct {
	codec.JceStructBase
	VData []HStockAnalySimpleData `json:"vData"`
}

func (st *HKLineDataByPeriodSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HKLineDataByPeriodSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HStockAnalySimpleData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKLineDataByPeriodSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKLineDataByPeriodSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKLineDataByPeriodSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKLineDataByPeriodSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKLineDataByPeriodSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// HStockKLineReq struct implement
type HStockKLineReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo        `json:"stHeader"`
	SCode      string            `json:"sCode"`
	ELineType  HISTORY_DATA_TYPE `json:"eLineType"`
	LDate      int64             `json:"lDate"`
	IWantNum   int32             `json:"iWantNum"`
	VecCheck   []HCheckData      `json:"vecCheck"`
	StSecCheck HSectionCheckData `json:"stSecCheck"`
}

func (st *HStockKLineReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IWantNum = 100
	st.StSecCheck.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockKLineReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ELineType), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecCheck = make([]HCheckData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VecCheck[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.StSecCheck.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockKLineReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockKLineReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockKLineReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ELineType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecCheck)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecCheck {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.StSecCheck.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockKLineReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockKLineReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eLineType:", st.ELineType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lDate:", st.LDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecCheck:", st.VecCheck)
	ret = ret + ",  "
	ret = ret + "stSecCheck:" + st.StSecCheck.Display()

	ret = ret + " }"
	return ret
}

// HStockKLineRsp struct implement
type HStockKLineRsp struct {
	codec.JceStructBase
	VAnalyData []HCQAnalyData    `json:"vAnalyData"`
	VecCheck   []HCheckData      `json:"vecCheck"`
	StSecCheck HSectionCheckData `json:"stSecCheck"`
}

func (st *HStockKLineRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StSecCheck.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockKLineRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VAnalyData = make([]HCQAnalyData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VAnalyData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecCheck = make([]HCheckData, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VecCheck[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.StSecCheck.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockKLineRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockKLineRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockKLineRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VAnalyData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VAnalyData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecCheck)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecCheck {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.StSecCheck.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockKLineRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockKLineRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vAnalyData:", st.VAnalyData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecCheck:", st.VecCheck)
	ret = ret + ",  "
	ret = ret + "stSecCheck:" + st.StSecCheck.Display()

	ret = ret + " }"
	return ret
}

// HTickDataReq struct implement
type HTickDataReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo    `json:"stHeader"`
	SCode      string        `json:"sCode"`
	ShtStartxh int16         `json:"shtStartxh"`
	ShtWantNum int16         `json:"shtWantNum"`
	EPushFlag  E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HTickDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HTickDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTickDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTickDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTickDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTickDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTickDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HTickDataRsp struct implement
type HTickDataRsp struct {
	codec.JceStructBase
	CPrecise  int8        `json:"cPrecise"`
	VTickData []HTickData `json:"vTickData"`
	ICount    int32       `json:"iCount"`
}

func (st *HTickDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTickDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int8(&st.CPrecise, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTickData = make([]HTickData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VTickData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.ICount, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTickDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTickDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTickDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int8(st.CPrecise, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTickData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTickData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.ICount, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTickDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTickDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("cPrecise:", st.CPrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vTickData:", st.VTickData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iCount:", st.ICount)

	ret = ret + " }"
	return ret
}

// HHisTickReq struct implement
type HHisTickReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo `json:"stHeader"`
	SCode      string     `json:"sCode"`
	IDate      int32      `json:"iDate"`
	ShtStartxh int16      `json:"shtStartxh"`
	ShtWantNum int16      `json:"shtWantNum"`
}

func (st *HHisTickReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisTickReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisTickReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisTickReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisTickReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisTickReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisTickReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)

	ret = ret + " }"
	return ret
}

// HHisTickRsp struct implement
type HHisTickRsp struct {
	codec.JceStructBase
	CPrecise  int8        `json:"cPrecise"`
	VTickData []HTickData `json:"vTickData"`
}

func (st *HHisTickRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisTickRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int8(&st.CPrecise, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTickData = make([]HTickData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VTickData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisTickRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisTickRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisTickRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int8(st.CPrecise, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTickData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTickData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisTickRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisTickRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("cPrecise:", st.CPrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vTickData:", st.VTickData)

	ret = ret + " }"
	return ret
}

// HMFlowByDayReq struct implement
type HMFlowByDayReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo `json:"stHeader"`
	SCode      string     `json:"sCode"`
	ShtStartxh int16      `json:"shtStartxh"`
	ShtWantNum int16      `json:"shtWantNum"`
}

func (st *HMFlowByDayReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFlowByDayReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFlowByDayReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFlowByDayReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFlowByDayReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFlowByDayReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFlowByDayReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)

	ret = ret + " }"
	return ret
}

// HMFlowByDayRsp struct implement
type HMFlowByDayRsp struct {
	codec.JceStructBase
	VStockMFlow []HTolMoneyFlow `json:"vStockMFlow"`
}

func (st *HMFlowByDayRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFlowByDayRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockMFlow = make([]HTolMoneyFlow, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockMFlow[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFlowByDayRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFlowByDayRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFlowByDayRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockMFlow)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockMFlow {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFlowByDayRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFlowByDayRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockMFlow:", st.VStockMFlow)

	ret = ret + " }"
	return ret
}

// HMFByTradeReq struct implement
type HMFByTradeReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo    `json:"stHeader"`
	SCode      string        `json:"sCode"`
	ShtStartxh int16         `json:"shtStartxh"`
	ShtWantNum int16         `json:"shtWantNum"`
	EPushFlag  E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HMFByTradeReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 10
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFByTradeReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFByTradeReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFByTradeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFByTradeReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFByTradeReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFByTradeReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HMFByTradeRsp struct implement
type HMFByTradeRsp struct {
	codec.JceStructBase
	VStockMFlow []HTolMoneyFlow `json:"vStockMFlow"`
	VDate       []int64         `json:"vDate"`
}

func (st *HMFByTradeRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFByTradeRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockMFlow = make([]HTolMoneyFlow, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockMFlow[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VDate = make([]int64, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int64(&st.VDate[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFByTradeRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFByTradeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFByTradeRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockMFlow)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockMFlow {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VDate)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VDate {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFByTradeRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFByTradeRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockMFlow:", st.VStockMFlow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vDate:", st.VDate)

	ret = ret + " }"
	return ret
}

// HStockMFlowDataReq struct implement
type HStockMFlowDataReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo        `json:"stHeader"`
	SCode     string            `json:"sCode"`
	ELineType HISTORY_DATA_TYPE `json:"eLineType"`
	LDate     int64             `json:"lDate"`
	IWantNum  int32             `json:"iWantNum"`
	VecCheck  []HCheckData      `json:"vecCheck"`
	EMfType   E_MONEYFLOW_TYPE  `json:"eMfType"`
}

func (st *HStockMFlowDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IWantNum = 100
	st.EMfType = E_MONEYFLOW_TYPE_E_MONEYFLOW_DOUBLE
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockMFlowDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ELineType), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecCheck = make([]HCheckData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VecCheck[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.EMfType), 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockMFlowDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockMFlowDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockMFlowDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ELineType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecCheck)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecCheck {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EMfType), 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockMFlowDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockMFlowDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eLineType:", st.ELineType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lDate:", st.LDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecCheck:", st.VecCheck)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eMfType:", st.EMfType)

	ret = ret + " }"
	return ret
}

// HStockMFlowDataRsp struct implement
type HStockMFlowDataRsp struct {
	codec.JceStructBase
	VMFlowData []HDDZData   `json:"vMFlowData"`
	VecCheck   []HCheckData `json:"vecCheck"`
}

func (st *HStockMFlowDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockMFlowDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMFlowData = make([]HDDZData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMFlowData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecCheck = make([]HCheckData, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VecCheck[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockMFlowDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockMFlowDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockMFlowDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMFlowData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMFlowData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecCheck)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecCheck {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockMFlowDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockMFlowDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vMFlowData:", st.VMFlowData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecCheck:", st.VecCheck)

	ret = ret + " }"
	return ret
}

// HStockBatchMFlowDataReq struct implement
type HStockBatchMFlowDataReq struct {
	codec.JceStructBase
	StHeader     HeaderInfo                        `json:"stHeader"`
	SCode        string                            `json:"sCode"`
	ELineType    HISTORY_DATA_TYPE                 `json:"eLineType"`
	LDate        int64                             `json:"lDate"`
	IWantNum     int32                             `json:"iWantNum"`
	MapCheckData map[E_MONEYFLOW_TYPE][]HCheckData `json:"mapCheckData"`
}

func (st *HStockBatchMFlowDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IWantNum = 100
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBatchMFlowDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ELineType), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 4, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 5, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapCheckData = make(map[E_MONEYFLOW_TYPE][]HCheckData)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 E_MONEYFLOW_TYPE
			var v0 []HCheckData

			err = _is.Read_int32((*int32)(&k0), 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v0 = make([]HCheckData, length)
					for i1, e1 := int32(0), length; i1 < e1; i1++ {

						err = v0[i1].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.MapCheckData[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBatchMFlowDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBatchMFlowDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBatchMFlowDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ELineType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapCheckData)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.MapCheckData {

		err = _os.Write_int32(int32(k2), 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v2)), 0)
		if err != nil {
			return err
		}

		for _, v := range v2 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBatchMFlowDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBatchMFlowDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eLineType:", st.ELineType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lDate:", st.LDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapCheckData:", st.MapCheckData)

	ret = ret + " }"
	return ret
}

// HStockBatchMFlowDataRsp struct implement
type HStockBatchMFlowDataRsp struct {
	codec.JceStructBase
	MapData map[E_MONEYFLOW_TYPE]HStockMFlowDataRsp `json:"mapData"`
}

func (st *HStockBatchMFlowDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBatchMFlowDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapData = make(map[E_MONEYFLOW_TYPE]HStockMFlowDataRsp)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 E_MONEYFLOW_TYPE
			var v0 HStockMFlowDataRsp

			err = _is.Read_int32((*int32)(&k0), 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapData[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBatchMFlowDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBatchMFlowDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBatchMFlowDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapData)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapData {

		err = _os.Write_int32(int32(k1), 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBatchMFlowDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBatchMFlowDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapData:", st.MapData)

	ret = ret + " }"
	return ret
}

// HMFlowRankReq struct implement
type HMFlowRankReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo            `json:"stHeader"`
	EBussType  E_BUSS_TYPE           `json:"eBussType"`
	ShtStartxh int16                 `json:"shtStartxh"`
	ShtWantNum int16                 `json:"shtWantNum"`
	VStock     []HStockUnique        `json:"vStock"`
	EColumn    E_MF_RANK_SORT_COLUMN `json:"eColumn"`
	ESort      E_SORT_METHOD         `json:"eSort"`
}

func (st *HMFlowRankReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFlowRankReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EBussType), 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFlowRankReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFlowRankReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFlowRankReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EBussType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EColumn), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFlowRankReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFlowRankReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eBussType:", st.EBussType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)

	ret = ret + " }"
	return ret
}

// HMFlowRankRsp struct implement
type HMFlowRankRsp struct {
	codec.JceStructBase
	VMFlowRank []HMFlowRank `json:"vMFlowRank"`
	ITotalSize uint32       `json:"iTotalSize"`
}

func (st *HMFlowRankRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ITotalSize = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFlowRankRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMFlowRank = make([]HMFlowRank, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMFlowRank[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_uint32(&st.ITotalSize, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFlowRankRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFlowRankRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFlowRankRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMFlowRank)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMFlowRank {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_uint32(st.ITotalSize, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFlowRankRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFlowRankRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vMFlowRank:", st.VMFlowRank)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalSize:", st.ITotalSize)

	ret = ret + " }"
	return ret
}

// HDDERankReq struct implement
type HDDERankReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo            `json:"stHeader"`
	ShtDomain  int16                 `json:"shtDomain"`
	ShtStartxh int16                 `json:"shtStartxh"`
	ShtWantNum int16                 `json:"shtWantNum"`
	EColumn    E_DDERANK_SORT_COLUMN `json:"eColumn"`
	ESort      E_SORT_METHOD         `json:"eSort"`
}

func (st *HDDERankReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
}

//ReadFrom reads  from _is and put into struct.
func (st *HDDERankReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDomain, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HDDERankReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HDDERankReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HDDERankReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDomain, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HDDERankReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HDDERankReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDomain:", st.ShtDomain)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)

	ret = ret + " }"
	return ret
}

// HDDERankRsp struct implement
type HDDERankRsp struct {
	codec.JceStructBase
	VDDERank   []HDDERank `json:"vDDERank"`
	ITotalSize uint32     `json:"iTotalSize"`
}

func (st *HDDERankRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ITotalSize = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HDDERankRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VDDERank = make([]HDDERank, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VDDERank[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_uint32(&st.ITotalSize, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HDDERankRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HDDERankRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HDDERankRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VDDERank)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VDDERank {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_uint32(st.ITotalSize, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HDDERankRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HDDERankRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vDDERank:", st.VDDERank)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalSize:", st.ITotalSize)

	ret = ret + " }"
	return ret
}

// HStockDDEBatchReq struct implement
type HStockDDEBatchReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HStockDDEBatchReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDDEBatchReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDDEBatchReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDDEBatchReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDDEBatchReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDDEBatchReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDDEBatchReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HStockDDEBatchRsp struct implement
type HStockDDEBatchRsp struct {
	codec.JceStructBase
	VStockDDE []HDDERank `json:"vStockDDE"`
}

func (st *HStockDDEBatchRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDDEBatchRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockDDE = make([]HDDERank, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockDDE[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDDEBatchRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDDEBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDDEBatchRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockDDE)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockDDE {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDDEBatchRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDDEBatchRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockDDE:", st.VStockDDE)

	ret = ret + " }"
	return ret
}

// HDxjlReq struct implement
type HDxjlReq struct {
	codec.JceStructBase
	StHeader     HeaderInfo     `json:"stHeader"`
	VStock       []HStockUnique `json:"vStock"`
	INum         uint32         `json:"iNum"`
	BlnFromHead  bool           `json:"blnFromHead"`
	EPushFlag    E_HQ_PUSH_REG  `json:"ePushFlag"`
	IncreaseMode bool           `json:"IncreaseMode"`
	UiStartPosEx uint32         `json:"uiStartPosEx"`
	INumEx       int32          `json:"iNumEx"`
	VMarket      []int16        `json:"vMarket"`
	VType        []int16        `json:"vType"`
}

func (st *HDxjlReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.BlnFromHead = true
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.IncreaseMode = false
	//st.UiStartPosEx = -1
	st.INumEx = -200
}

//ReadFrom reads  from _is and put into struct.
func (st *HDxjlReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_uint32(&st.INum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BlnFromHead, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.IncreaseMode, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiStartPosEx, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.INumEx, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarket = make([]int16, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int16(&st.VMarket[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VType = make([]int16, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_int16(&st.VType[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HDxjlReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HDxjlReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HDxjlReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_uint32(st.INum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BlnFromHead, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.IncreaseMode, 5)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiStartPosEx, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.INumEx, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarket)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarket {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VType {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HDxjlReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HDxjlReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNum:", st.INum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("blnFromHead:", st.BlnFromHead)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("IncreaseMode:", st.IncreaseMode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiStartPosEx:", st.UiStartPosEx)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNumEx:", st.INumEx)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMarket:", st.VMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vType:", st.VType)

	ret = ret + " }"
	return ret
}

// HDxjlRsp struct implement
type HDxjlRsp struct {
	codec.JceStructBase
	VDxjl        []HDxjl `json:"vDxjl"`
	UiStartPosEx uint32  `json:"uiStartPosEx"`
}

func (st *HDxjlRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.UiStartPosEx = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HDxjlRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VDxjl = make([]HDxjl, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VDxjl[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_uint32(&st.UiStartPosEx, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HDxjlRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HDxjlRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HDxjlRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VDxjl)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VDxjl {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_uint32(st.UiStartPosEx, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HDxjlRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HDxjlRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vDxjl:", st.VDxjl)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiStartPosEx:", st.UiStartPosEx)

	ret = ret + " }"
	return ret
}

// HL2MonitReq struct implement
type HL2MonitReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo         `json:"stHeader"`
	VStock     []HStockUnique     `json:"vStock"`
	ShtStartxh int16              `json:"shtStartxh"`
	ShtWantNum int16              `json:"shtWantNum"`
	EColumn    E_STOCK_ORDER_TYPE `json:"eColumn"`
	ESort      E_SORT_METHOD      `json:"eSort"`
}

func (st *HL2MonitReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
}

//ReadFrom reads  from _is and put into struct.
func (st *HL2MonitReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int16(&st.ShtStartxh, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HL2MonitReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HL2MonitReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HL2MonitReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int16(st.ShtStartxh, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HL2MonitReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HL2MonitReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)

	ret = ret + " }"
	return ret
}

// HL2MonitRsp struct implement
type HL2MonitRsp struct {
	codec.JceStructBase
	VMonit []HL2Monit `json:"vMonit"`
}

func (st *HL2MonitRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HL2MonitRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMonit = make([]HL2Monit, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMonit[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HL2MonitRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HL2MonitRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HL2MonitRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMonit)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMonit {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HL2MonitRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HL2MonitRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vMonit:", st.VMonit)

	ret = ret + " }"
	return ret
}

// HLV2SZFYReq struct implement
type HLV2SZFYReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo         `json:"stHeader"`
	VStock     []HStockUnique     `json:"vStock"`
	ShtStartxh int16              `json:"shtStartxh"`
	ShtWantNum int16              `json:"shtWantNum"`
	EColumn    E_STOCK_ORDER_TYPE `json:"eColumn"`
	EOrder     E_SZFY_ORDER_TYPE  `json:"eOrder"`
	ESort      E_SORT_METHOD      `json:"eSort"`
	BlnDetail  bool               `json:"blnDetail"`
}

func (st *HLV2SZFYReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
	st.BlnDetail = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HLV2SZFYReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int16(&st.ShtStartxh, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EOrder), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BlnDetail, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HLV2SZFYReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HLV2SZFYReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HLV2SZFYReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int16(st.ShtStartxh, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EOrder), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BlnDetail, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HLV2SZFYReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HLV2SZFYReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eOrder:", st.EOrder)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("blnDetail:", st.BlnDetail)

	ret = ret + " }"
	return ret
}

// HLV2SZFYRsp struct implement
type HLV2SZFYRsp struct {
	codec.JceStructBase
	VMonit []HSZFY `json:"vMonit"`
}

func (st *HLV2SZFYRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HLV2SZFYRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMonit = make([]HSZFY, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMonit[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HLV2SZFYRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HLV2SZFYRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HLV2SZFYRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMonit)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMonit {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HLV2SZFYRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HLV2SZFYRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vMonit:", st.VMonit)

	ret = ret + " }"
	return ret
}

// HSZFYComReq struct implement
type HSZFYComReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo           `json:"stHeader"`
	EType      E_COM_ORDER_TYPE     `json:"eType"`
	ShtStartxh int16                `json:"shtStartxh"`
	ShtWantNum int16                `json:"shtWantNum"`
	EOrder     E_SZFYCOM_ORDER_TYPE `json:"eOrder"`
	ESort      E_SORT_METHOD        `json:"eSort"`
}

func (st *HSZFYComReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
}

//ReadFrom reads  from _is and put into struct.
func (st *HSZFYComReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EOrder), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSZFYComReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSZFYComReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSZFYComReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EOrder), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSZFYComReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSZFYComReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eOrder:", st.EOrder)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)

	ret = ret + " }"
	return ret
}

// HSZFYComRsp struct implement
type HSZFYComRsp struct {
	codec.JceStructBase
	VMonit     []HSZFYCom `json:"vMonit"`
	ITotalSize uint32     `json:"iTotalSize"`
}

func (st *HSZFYComRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ITotalSize = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HSZFYComRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMonit = make([]HSZFYCom, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMonit[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_uint32(&st.ITotalSize, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSZFYComRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSZFYComRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSZFYComRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMonit)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMonit {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_uint32(st.ITotalSize, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSZFYComRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSZFYComRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vMonit:", st.VMonit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalSize:", st.ITotalSize)

	ret = ret + " }"
	return ret
}

// HStockHqReq struct implement
type HStockHqReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo       `json:"stHeader"`
	VStock      []HStockUnique   `json:"vStock"`
	EPushFlag   E_HQ_PUSH_REG    `json:"ePushFlag"`
	EHqData     E_STOCK_HQ_DATA  `json:"eHqData"`
	EEnvData    E_STOCK_DATA_ENV `json:"eEnvData"`
	IDelayFlag  int32            `json:"iDelayFlag"`
	VBitmap     []int8           `json:"vBitmap"`
	ShtDiffType int16            `json:"shtDiffType"`
}

func (st *HStockHqReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.EHqData = E_STOCK_HQ_DATA_E_SHD_NONE
	st.EEnvData = E_STOCK_DATA_ENV_E_SHDE_NORMAL
	st.IDelayFlag = 0
	st.ShtDiffType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockHqReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EHqData), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EEnvData), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDelayFlag, 6, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VBitmap[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int16(&st.ShtDiffType, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockHqReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockHqReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockHqReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EHqData), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EEnvData), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDelayFlag, 6)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDiffType, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockHqReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockHqReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eHqData:", st.EHqData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eEnvData:", st.EEnvData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDelayFlag:", st.IDelayFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDiffType:", st.ShtDiffType)

	ret = ret + " }"
	return ret
}

// HStockHqSimpleReq struct implement
type HStockHqSimpleReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo     `json:"stHeader"`
	VStock    []HStockUnique `json:"vStock"`
	EPushFlag E_HQ_PUSH_REG  `json:"ePushFlag"`
	VBitmap   []int8         `json:"vBitmap"`
}

func (st *HStockHqSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockHqSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VBitmap[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockHqSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockHqSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockHqSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockHqSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockHqSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HStockHqRsp struct implement
type HStockHqRsp struct {
	codec.JceStructBase
	VStockHq []HStockHq `json:"vStockHq"`
}

func (st *HStockHqRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockHqRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockHq = make([]HStockHq, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockHq[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockHqRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockHqRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockHqRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockHq)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockHq {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockHqRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockHqRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockHq:", st.VStockHq)

	ret = ret + " }"
	return ret
}

// HStockHqSimpleRsp struct implement
type HStockHqSimpleRsp struct {
	codec.JceStructBase
	VStockHq []HStockHqSimple `json:"vStockHq"`
}

func (st *HStockHqSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockHqSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockHq = make([]HStockHqSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockHq[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockHqSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockHqSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockHqSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockHq)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockHq {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockHqSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockHqSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockHq:", st.VStockHq)

	ret = ret + " }"
	return ret
}

// OptStockHqExReq struct implement
type OptStockHqExReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo     `json:"stHeader"`
	VStock     []HStockUnique `json:"vStock"`
	EPushFlag  E_HQ_PUSH_REG  `json:"ePushFlag"`
	IDelayFlag int32          `json:"iDelayFlag"`
	BRtMin     bool           `json:"bRtMin"`
	IStartPos  int32          `json:"iStartPos"`
	BAuction   bool           `json:"bAuction"`
	ShtType    int16          `json:"shtType"`
}

func (st *OptStockHqExReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.IDelayFlag = 0
	st.BRtMin = false
	st.IStartPos = 0
	st.BAuction = false
	st.ShtType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *OptStockHqExReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDelayFlag, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BRtMin, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BAuction, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *OptStockHqExReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OptStockHqExReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *OptStockHqExReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDelayFlag, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BRtMin, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BAuction, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *OptStockHqExReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *OptStockHqExReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDelayFlag:", st.IDelayFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bRtMin:", st.BRtMin)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bAuction:", st.BAuction)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)

	ret = ret + " }"
	return ret
}

// OptStockHqExRsp struct implement
type OptStockHqExRsp struct {
	codec.JceStructBase
	VOptStockHqEx []OptStockHqEx `json:"vOptStockHqEx"`
}

func (st *OptStockHqExRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *OptStockHqExRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VOptStockHqEx = make([]OptStockHqEx, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VOptStockHqEx[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *OptStockHqExRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OptStockHqExRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *OptStockHqExRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VOptStockHqEx)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VOptStockHqEx {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *OptStockHqExRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *OptStockHqExRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vOptStockHqEx:", st.VOptStockHqEx)

	ret = ret + " }"
	return ret
}

// HOptStockHqReq struct implement
type HOptStockHqReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo     `json:"stHeader"`
	VStock    []HStockUnique `json:"vStock"`
	EPushFlag E_HQ_PUSH_REG  `json:"ePushFlag"`
}

func (st *HOptStockHqReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptStockHqReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptStockHqReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptStockHqReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptStockHqReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptStockHqReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptStockHqReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HOptStockHqRsp struct implement
type HOptStockHqRsp struct {
	codec.JceStructBase
	VStockHq []HStockHq `json:"vStockHq"`
}

func (st *HOptStockHqRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptStockHqRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockHq = make([]HStockHq, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockHq[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptStockHqRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptStockHqRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptStockHqRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockHq)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockHq {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptStockHqRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptStockHqRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockHq:", st.VStockHq)

	ret = ret + " }"
	return ret
}

// HStockBaseInfoReq struct implement
type HStockBaseInfoReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo     `json:"stHeader"`
	VStock      []HStockUnique `json:"vStock"`
	BNeedDelist bool           `json:"bNeedDelist"`
}

func (st *HStockBaseInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.BNeedDelist = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBaseInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_bool(&st.BNeedDelist, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBaseInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBaseInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBaseInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.BNeedDelist, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBaseInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBaseInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bNeedDelist:", st.BNeedDelist)

	ret = ret + " }"
	return ret
}

// HStockBaseInfoRsp struct implement
type HStockBaseInfoRsp struct {
	codec.JceStructBase
	VStockInfo []HStockBaseInfo `json:"vStockInfo"`
}

func (st *HStockBaseInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBaseInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockInfo = make([]HStockBaseInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBaseInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBaseInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBaseInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBaseInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBaseInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockInfo:", st.VStockInfo)

	ret = ret + " }"
	return ret
}

// HStockBaseInfoSimpleReq struct implement
type HStockBaseInfoSimpleReq struct {
	codec.JceStructBase
	Req     HStockBaseInfoReq `json:"req"`
	VBitmap []int8            `json:"vBitmap"`
}

func (st *HStockBaseInfoSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Req.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBaseInfoSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Req.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBaseInfoSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBaseInfoSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBaseInfoSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Req.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBaseInfoSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBaseInfoSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "req:" + st.Req.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HStockBaseInfoSimpleRsp struct implement
type HStockBaseInfoSimpleRsp struct {
	codec.JceStructBase
	VStockInfo []HStockBaseInfoSimple `json:"vStockInfo"`
}

func (st *HStockBaseInfoSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBaseInfoSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockInfo = make([]HStockBaseInfoSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBaseInfoSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBaseInfoSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBaseInfoSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBaseInfoSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBaseInfoSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockInfo:", st.VStockInfo)

	ret = ret + " }"
	return ret
}

// HStockStaticInfoRsp struct implement
type HStockStaticInfoRsp struct {
	codec.JceStructBase
	VStockInfo []StockStaticData `json:"vStockInfo"`
}

func (st *HStockStaticInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockStaticInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockInfo = make([]StockStaticData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockStaticInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockStaticInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockStaticInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockStaticInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockStaticInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockInfo:", st.VStockInfo)

	ret = ret + " }"
	return ret
}

// HMarketBaseInfoReq struct implement
type HMarketBaseInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo        `json:"stHeader"`
	VMarket  []HMarketCheckSum `json:"vMarket"`
}

func (st *HMarketBaseInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketBaseInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarket = make([]HMarketCheckSum, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMarket[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketBaseInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketBaseInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketBaseInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarket)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarket {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketBaseInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketBaseInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMarket:", st.VMarket)

	ret = ret + " }"
	return ret
}

// HMarketBaseInfoRsp struct implement
type HMarketBaseInfoRsp struct {
	codec.JceStructBase
	VMarketBuf []HMarketBaseBuf `json:"vMarketBuf"`
}

func (st *HMarketBaseInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketBaseInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarketBuf = make([]HMarketBaseBuf, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMarketBuf[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketBaseInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketBaseInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketBaseInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarketBuf)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarketBuf {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketBaseInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketBaseInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vMarketBuf:", st.VMarketBuf)

	ret = ret + " }"
	return ret
}

// HOptionBaseInfoReq struct implement
type HOptionBaseInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HOptionBaseInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionBaseInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionBaseInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionBaseInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionBaseInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionBaseInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionBaseInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HOptionBaseInfoRsp struct implement
type HOptionBaseInfoRsp struct {
	codec.JceStructBase
	VBaseInfo []HOptionBaseInfo `json:"vBaseInfo"`
}

func (st *HOptionBaseInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionBaseInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBaseInfo = make([]HOptionBaseInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VBaseInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionBaseInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionBaseInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionBaseInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBaseInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBaseInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionBaseInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionBaseInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vBaseInfo:", st.VBaseInfo)

	ret = ret + " }"
	return ret
}

// HStockDictReq struct implement
type HStockDictReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	VSetcode []int16    `json:"vSetcode"`
}

func (st *HStockDictReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDictReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VSetcode = make([]int16, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = _is.Read_int16(&st.VSetcode[i0], 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDictReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDictReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDictReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSetcode)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSetcode {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDictReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDictReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSetcode:", st.VSetcode)

	ret = ret + " }"
	return ret
}

// HStockDictRsp struct implement
type HStockDictRsp struct {
	codec.JceStructBase
	VStockInfo []HStockDictInfo `json:"vStockInfo"`
}

func (st *HStockDictRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDictRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockInfo = make([]HStockDictInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDictRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDictRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDictRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDictRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDictRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockInfo:", st.VStockInfo)

	ret = ret + " }"
	return ret
}

// HStockDictSimpleReq struct implement
type HStockDictSimpleReq struct {
	codec.JceStructBase
	Req     HStockDictReq `json:"req"`
	VBitmap []int8        `json:"vBitmap"`
}

func (st *HStockDictSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Req.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDictSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Req.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDictSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDictSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDictSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Req.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDictSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDictSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "req:" + st.Req.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HStockDictSimpleRsp struct implement
type HStockDictSimpleRsp struct {
	codec.JceStructBase
	VStockInfo []HStockDictInfoSimple `json:"vStockInfo"`
}

func (st *HStockDictSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDictSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockInfo = make([]HStockDictInfoSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDictSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDictSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDictSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDictSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDictSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockInfo:", st.VStockInfo)

	ret = ret + " }"
	return ret
}

// HStockBaseBatchReq struct implement
type HStockBaseBatchReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HStockBaseBatchReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBaseBatchReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBaseBatchReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBaseBatchReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBaseBatchReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBaseBatchReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBaseBatchReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HStockBaseBatchRsp struct implement
type HStockBaseBatchRsp struct {
	codec.JceStructBase
	VStockInfo []HStockBaseInfo `json:"vStockInfo"`
}

func (st *HStockBaseBatchRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBaseBatchRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockInfo = make([]HStockBaseInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBaseBatchRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBaseBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBaseBatchRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBaseBatchRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBaseBatchRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockInfo:", st.VStockInfo)

	ret = ret + " }"
	return ret
}

// HStockAHListReq struct implement
type HStockAHListReq struct {
	codec.JceStructBase
	StHeader     HeaderInfo       `json:"stHeader"`
	ShtStartxh   int16            `json:"shtStartxh"`
	ShtWantNum   int16            `json:"shtWantNum"`
	EColumn      E_AH_SORT_COLUMN `json:"eColumn"`
	ESort        E_SORT_METHOD    `json:"eSort"`
	EAMType      E_AM_STK_TYPE    `json:"eAMType"`
	CPremiumType int8             `json:"cPremiumType"`
}

func (st *HStockAHListReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
	st.EAMType = E_AM_STK_TYPE_E_AM_STK_AH
	st.CPremiumType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAHListReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EAMType), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CPremiumType, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAHListReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAHListReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAHListReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EAMType), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CPremiumType, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAHListReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAHListReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eAMType:", st.EAMType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cPremiumType:", st.CPremiumType)

	ret = ret + " }"
	return ret
}

// HStockAHListRsp struct implement
type HStockAHListRsp struct {
	codec.JceStructBase
	VAHStock []HAHStock `json:"vAHStock"`
}

func (st *HStockAHListRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAHListRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VAHStock = make([]HAHStock, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VAHStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAHListRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAHListRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAHListRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VAHStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VAHStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAHListRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAHListRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vAHStock:", st.VAHStock)

	ret = ret + " }"
	return ret
}

// HStockAHReq struct implement
type HStockAHReq struct {
	codec.JceStructBase
	StHeader     HeaderInfo    `json:"stHeader"`
	SCode        string        `json:"sCode"`
	EAMType      E_AM_STK_TYPE `json:"eAMType"`
	CPremiumType int8          `json:"cPremiumType"`
}

func (st *HStockAHReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EAMType = E_AM_STK_TYPE_E_AM_STK_AH
	st.CPremiumType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAHReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EAMType), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CPremiumType, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAHReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAHReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAHReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EAMType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CPremiumType, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAHReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAHReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eAMType:", st.EAMType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cPremiumType:", st.CPremiumType)

	ret = ret + " }"
	return ret
}

// HStockAHRsp struct implement
type HStockAHRsp struct {
	codec.JceStructBase
	FPremiumRate        float64 `json:"fPremiumRate"`
	StItem              HAHItem `json:"stItem"`
	ShtPrecise          uint16  `json:"shtPrecise"`
	FConversionPrice    float64 `json:"fConversionPrice"`
	FConversionChgValue float64 `json:"fConversionChgValue"`
	FConversionChgRatio float64 `json:"fConversionChgRatio"`
}

func (st *HStockAHRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StItem.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAHRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.FPremiumRate, 1, false)
	if err != nil {
		return err
	}

	err = st.StItem.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint16(&st.ShtPrecise, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FConversionPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FConversionChgValue, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FConversionChgRatio, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAHRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAHRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAHRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.FPremiumRate, 1)
	if err != nil {
		return err
	}

	err = st.StItem.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_uint16(st.ShtPrecise, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FConversionPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FConversionChgValue, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FConversionChgRatio, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAHRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAHRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fPremiumRate:", st.FPremiumRate)
	ret = ret + ",  "
	ret = ret + "stItem:" + st.StItem.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtPrecise:", st.ShtPrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fConversionPrice:", st.FConversionPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fConversionChgValue:", st.FConversionChgValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fConversionChgRatio:", st.FConversionChgRatio)

	ret = ret + " }"
	return ret
}

// HStockAHBatchRsp struct implement
type HStockAHBatchRsp struct {
	codec.JceStructBase
	VAHStock []HStockAHRsp `json:"vAHStock"`
}

func (st *HStockAHBatchRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAHBatchRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VAHStock = make([]HStockAHRsp, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VAHStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAHBatchRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAHBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAHBatchRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VAHStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VAHStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAHBatchRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAHBatchRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vAHStock:", st.VAHStock)

	ret = ret + " }"
	return ret
}

// HTradePeriodReq struct implement
type HTradePeriodReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HTradePeriodReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTradePeriodReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTradePeriodReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTradePeriodReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTradePeriodReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTradePeriodReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTradePeriodReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HTradePeriodRsp struct implement
type HTradePeriodRsp struct {
	codec.JceStructBase
	VMTradeInfo map[int16]HTradePeriod `json:"vMTradeInfo"`
}

func (st *HTradePeriodRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTradePeriodRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VMTradeInfo = make(map[int16]HTradePeriod)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 HTradePeriod

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.VMTradeInfo[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTradePeriodRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTradePeriodRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTradePeriodRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMTradeInfo)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.VMTradeInfo {

		err = _os.Write_int16(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTradePeriodRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTradePeriodRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vMTradeInfo:", st.VMTradeInfo)

	ret = ret + " }"
	return ret
}

// HCQCXReq struct implement
type HCQCXReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	IDate    int32      `json:"iDate"`
	IType    int32      `json:"iType"`
}

func (st *HCQCXReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCQCXReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IType, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCQCXReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCQCXReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCQCXReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IType, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCQCXReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCQCXReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iType:", st.IType)

	ret = ret + " }"
	return ret
}

// HCQCXRsp struct implement
type HCQCXRsp struct {
	codec.JceStructBase
	VInfo []HCQCX `json:"vInfo"`
}

func (st *HCQCXRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCQCXRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HCQCX, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCQCXRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCQCXRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCQCXRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCQCXRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCQCXRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}

// HHotPlateReq struct implement
type HHotPlateReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	SCode    string     `json:"sCode"`
}

func (st *HHotPlateReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHotPlateReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHotPlateReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHotPlateReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHotPlateReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHotPlateReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHotPlateReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)

	ret = ret + " }"
	return ret
}

// HHotPlateRsp struct implement
type HHotPlateRsp struct {
	codec.JceStructBase
	VHotPlateData []HHotPlateStock `json:"vHotPlateData"`
}

func (st *HHotPlateRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHotPlateRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VHotPlateData = make([]HHotPlateStock, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VHotPlateData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHotPlateRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHotPlateRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHotPlateRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VHotPlateData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VHotPlateData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHotPlateRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHotPlateRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vHotPlateData:", st.VHotPlateData)

	ret = ret + " }"
	return ret
}

// HRegCPTMinReq struct implement
type HRegCPTMinReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HRegCPTMinReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegCPTMinReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegCPTMinReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegCPTMinReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegCPTMinReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegCPTMinReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegCPTMinReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HRegCPTMinRsp struct implement
type HRegCPTMinRsp struct {
	codec.JceStructBase
	ShtSetcode int16   `json:"shtSetcode"`
	CptData    HCPTMin `json:"cptData"`
}

func (st *HRegCPTMinRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.CptData.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegCPTMinRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = st.CptData.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegCPTMinRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegCPTMinRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegCPTMinRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = st.CptData.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegCPTMinRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegCPTMinRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + "cptData:" + st.CptData.Display()

	ret = ret + " }"
	return ret
}

// HRegMarketInitReq struct implement
type HRegMarketInitReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	VSetCode  []int16       `json:"vSetCode"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HRegMarketInitReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegMarketInitReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSetCode = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VSetCode[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegMarketInitReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegMarketInitReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegMarketInitReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSetCode)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSetCode {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegMarketInitReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegMarketInitReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSetCode:", st.VSetCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HRegMarketInitRsp struct implement
type HRegMarketInitRsp struct {
	codec.JceStructBase
	VInfo []HMarketInit `json:"vInfo"`
}

func (st *HRegMarketInitRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegMarketInitRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HMarketInit, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegMarketInitRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegMarketInitRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegMarketInitRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegMarketInitRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegMarketInitRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}

// HRegCodesReq struct implement
type HRegCodesReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	SCheckSum string        `json:"sCheckSum"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
	BUTF8     bool          `json:"bUTF8"`
}

func (st *HRegCodesReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.BUTF8 = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegCodesReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCheckSum, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BUTF8, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegCodesReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegCodesReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegCodesReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCheckSum, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BUTF8, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegCodesReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegCodesReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bUTF8:", st.BUTF8)

	ret = ret + " }"
	return ret
}

// HRegCodesRsp struct implement
type HRegCodesRsp struct {
	codec.JceStructBase
	StInfo HMarketCodes `json:"stInfo"`
}

func (st *HRegCodesRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegCodesRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StInfo.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegCodesRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegCodesRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegCodesRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StInfo.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegCodesRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegCodesRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stInfo:" + st.StInfo.Display()

	ret = ret + " }"
	return ret
}

// HPeriodReq struct implement
type HPeriodReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	VMarket  []int16    `json:"vMarket"`
	ShtVer   int16      `json:"shtVer"`
}

func (st *HPeriodReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtVer = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HPeriodReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarket = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VMarket[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int16(&st.ShtVer, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPeriodReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPeriodReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPeriodReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarket)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarket {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int16(st.ShtVer, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPeriodReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPeriodReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMarket:", st.VMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtVer:", st.ShtVer)

	ret = ret + " }"
	return ret
}

// HPeriodRsp struct implement
type HPeriodRsp struct {
	codec.JceStructBase
	VTime    map[int16]HTradePeriodTime `json:"vTime"`
	LCurTime int64                      `json:"lCurTime"`
}

func (st *HPeriodRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPeriodRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VTime = make(map[int16]HTradePeriodTime)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 HTradePeriodTime

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.VTime[k0] = v0
		}
	}

	err = _is.Read_int64(&st.LCurTime, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPeriodRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPeriodRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPeriodRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTime)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.VTime {

		err = _os.Write_int16(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.LCurTime, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPeriodRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPeriodRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vTime:", st.VTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lCurTime:", st.LCurTime)

	ret = ret + " }"
	return ret
}

// HUserLoginReq struct implement
type HUserLoginReq struct {
	codec.JceStructBase
	StHeader        HeaderInfo        `json:"stHeader"`
	ShtEncryptType  int16             `json:"shtEncryptType"`
	SCltTime        string            `json:"sCltTime"`
	VUserId         []int8            `json:"vUserId"`
	VToken          []int8            `json:"vToken"`
	EAuthType       E_LOGIN_AUTH_TYPE `json:"eAuthType"`
	SOEMToken       string            `json:"sOEMToken"`
	BKickoutDiffClt bool              `json:"bKickoutDiffClt"`
}

func (st *HUserLoginReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EAuthType = E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_SZ_SH
	st.BKickoutDiffClt = true
}

//ReadFrom reads  from _is and put into struct.
func (st *HUserLoginReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtEncryptType, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCltTime, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VUserId = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VUserId[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VUserId, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VToken = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VToken[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VToken, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.EAuthType), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SOEMToken, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BKickoutDiffClt, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HUserLoginReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HUserLoginReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HUserLoginReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtEncryptType, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCltTime, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VUserId)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VUserId)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VToken)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VToken)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EAuthType), 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SOEMToken, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BKickoutDiffClt, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HUserLoginReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HUserLoginReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtEncryptType:", st.ShtEncryptType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCltTime:", st.SCltTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vUserId:", st.VUserId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vToken:", st.VToken)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eAuthType:", st.EAuthType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sOEMToken:", st.SOEMToken)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bKickoutDiffClt:", st.BKickoutDiffClt)

	ret = ret + " }"
	return ret
}

// HUserLoginRsp struct implement
type HUserLoginRsp struct {
	codec.JceStructBase
	EStatus E_LOGIN_STATUS `json:"eStatus"`
	SMsg    string         `json:"sMsg"`
}

func (st *HUserLoginRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HUserLoginRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.EStatus), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SMsg, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HUserLoginRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HUserLoginRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HUserLoginRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.EStatus), 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SMsg, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HUserLoginRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HUserLoginRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sMsg:", st.SMsg)

	ret = ret + " }"
	return ret
}

// HUserSimpleLoginReq struct implement
type HUserSimpleLoginReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo `json:"stHeader"`
	SCltTime  string     `json:"sCltTime"`
	StrUserId string     `json:"strUserId"`
}

func (st *HUserSimpleLoginReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HUserSimpleLoginReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCltTime, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.StrUserId, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HUserSimpleLoginReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HUserSimpleLoginReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HUserSimpleLoginReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCltTime, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.StrUserId, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HUserSimpleLoginReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HUserSimpleLoginReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCltTime:", st.SCltTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("strUserId:", st.StrUserId)

	ret = ret + " }"
	return ret
}

// HUserSimpleLoginRsp struct implement
type HUserSimpleLoginRsp struct {
	codec.JceStructBase
	EStatus E_LOGIN_STATUS `json:"eStatus"`
	SMsg    string         `json:"sMsg"`
}

func (st *HUserSimpleLoginRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HUserSimpleLoginRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.EStatus), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SMsg, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HUserSimpleLoginRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HUserSimpleLoginRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HUserSimpleLoginRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.EStatus), 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SMsg, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HUserSimpleLoginRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HUserSimpleLoginRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sMsg:", st.SMsg)

	ret = ret + " }"
	return ret
}

// HProxyLoginReq struct implement
type HProxyLoginReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo    `json:"stHeader"`
	StLogin    HUserLoginReq `json:"stLogin"`
	BClearFlag bool          `json:"bClearFlag"`
	LCltConId  int64         `json:"lCltConId"`
}

func (st *HProxyLoginReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.StLogin.ResetDefault()
	st.BClearFlag = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HProxyLoginReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.StLogin.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BClearFlag, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LCltConId, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HProxyLoginReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HProxyLoginReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HProxyLoginReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.StLogin.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BClearFlag, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LCltConId, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HProxyLoginReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HProxyLoginReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + "stLogin:" + st.StLogin.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bClearFlag:", st.BClearFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lCltConId:", st.LCltConId)

	ret = ret + " }"
	return ret
}

// HProxyLoginRsp struct implement
type HProxyLoginRsp struct {
	codec.JceStructBase
	StInfo  HLoginInfo     `json:"stInfo"`
	EStatus E_LOGIN_STATUS `json:"eStatus"`
	SMsg    string         `json:"sMsg"`
}

func (st *HProxyLoginRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HProxyLoginRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StInfo.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStatus), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SMsg, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HProxyLoginRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HProxyLoginRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HProxyLoginRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StInfo.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStatus), 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SMsg, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HProxyLoginRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HProxyLoginRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stInfo:" + st.StInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sMsg:", st.SMsg)

	ret = ret + " }"
	return ret
}

// HUserPermissionReq struct implement
type HUserPermissionReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	SToken   string     `json:"sToken"`
}

func (st *HUserPermissionReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HUserPermissionReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SToken, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HUserPermissionReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HUserPermissionReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HUserPermissionReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SToken, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HUserPermissionReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HUserPermissionReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sToken:", st.SToken)

	ret = ret + " }"
	return ret
}

// HUserPermissionRsp struct implement
type HUserPermissionRsp struct {
	codec.JceStructBase
	EStatus E_LOGIN_STATUS `json:"eStatus"`
}

func (st *HUserPermissionRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HUserPermissionRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.EStatus), 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HUserPermissionRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HUserPermissionRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HUserPermissionRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.EStatus), 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HUserPermissionRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HUserPermissionRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)

	ret = ret + " }"
	return ret
}

// HOrderQueueReq struct implement
type HOrderQueueReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	SCode     string        `json:"sCode"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HOrderQueueReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderQueueReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderQueueReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderQueueReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderQueueReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderQueueReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderQueueReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HOrderQueueRsp struct implement
type HOrderQueueRsp struct {
	codec.JceStructBase
	VOrderData []HOrderQueue `json:"vOrderData"`
}

func (st *HOrderQueueRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderQueueRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VOrderData = make([]HOrderQueue, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VOrderData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderQueueRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderQueueRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderQueueRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VOrderData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VOrderData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderQueueRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderQueueRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vOrderData:", st.VOrderData)

	ret = ret + " }"
	return ret
}

// HTransDataReq struct implement
type HTransDataReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo        `json:"stHeader"`
	SCode       string            `json:"sCode"`
	EPushFlag   E_HQ_PUSH_REG     `json:"ePushFlag"`
	IStatPos    int32             `json:"iStatPos"`
	IWantNum    int32             `json:"iWantNum"`
	ETransType  E_TRANS_DATA_TYPE `json:"eTransType"`
	IReversePos int32             `json:"iReversePos"`
}

func (st *HTransDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.ETransType = E_TRANS_DATA_TYPE_E_TRANS_DATA_NORMAL
	st.IReversePos = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HTransDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStatPos, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ETransType), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IReversePos, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTransDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTransDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTransDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStatPos, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ETransType), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IReversePos, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTransDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTransDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStatPos:", st.IStatPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eTransType:", st.ETransType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iReversePos:", st.IReversePos)

	ret = ret + " }"
	return ret
}

// HTransDataRsp struct implement
type HTransDataRsp struct {
	codec.JceStructBase
	VTrans []HTransaction `json:"vTrans"`
	IIndex int32          `json:"iIndex"`
}

func (st *HTransDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTransDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTrans = make([]HTransaction, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VTrans[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IIndex, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTransDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTransDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTransDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTrans)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTrans {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IIndex, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTransDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTransDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vTrans:", st.VTrans)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iIndex:", st.IIndex)

	ret = ret + " }"
	return ret
}

// HOrderRecReq struct implement
type HOrderRecReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo       `json:"stHeader"`
	SCode       string           `json:"sCode"`
	EPushFlag   E_HQ_PUSH_REG    `json:"ePushFlag"`
	IStatPos    int32            `json:"iStatPos"`
	IWantNum    int32            `json:"iWantNum"`
	ERecType    E_ORDER_REC_TYPE `json:"eRecType"`
	IReversePos int32            `json:"iReversePos"`
}

func (st *HOrderRecReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.ERecType = E_ORDER_REC_TYPE_E_ORDER_REC_NORMAL
	st.IReversePos = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderRecReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStatPos, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ERecType), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IReversePos, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderRecReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderRecReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderRecReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStatPos, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ERecType), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IReversePos, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderRecReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderRecReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStatPos:", st.IStatPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eRecType:", st.ERecType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iReversePos:", st.IReversePos)

	ret = ret + " }"
	return ret
}

// HOrderRecRsp struct implement
type HOrderRecRsp struct {
	codec.JceStructBase
	VRec   []HOrderRec `json:"vRec"`
	IIndex int32       `json:"iIndex"`
}

func (st *HOrderRecRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderRecRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRec = make([]HOrderRec, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRec[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IIndex, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderRecRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderRecRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderRecRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRec)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRec {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IIndex, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderRecRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderRecRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vRec:", st.VRec)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iIndex:", st.IIndex)

	ret = ret + " }"
	return ret
}

// HPriceOrderReq struct implement
type HPriceOrderReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	SCode     string        `json:"sCode"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HPriceOrderReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HPriceOrderReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPriceOrderReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPriceOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPriceOrderReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPriceOrderReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPriceOrderReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HPriceOrderRsp struct implement
type HPriceOrderRsp struct {
	codec.JceStructBase
	StSum      HOrderSumStat      `json:"stSum"`
	VBuyOrder  []HOrderQueuePrice `json:"vBuyOrder"`
	VSellOrder []HOrderQueuePrice `json:"vSellOrder"`
}

func (st *HPriceOrderRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StSum.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPriceOrderRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StSum.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuyOrder = make([]HOrderQueuePrice, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VBuyOrder[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSellOrder = make([]HOrderQueuePrice, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VSellOrder[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPriceOrderRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPriceOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPriceOrderRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StSum.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuyOrder)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBuyOrder {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSellOrder)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSellOrder {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPriceOrderRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPriceOrderRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stSum:" + st.StSum.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuyOrder:", st.VBuyOrder)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSellOrder:", st.VSellOrder)

	ret = ret + " }"
	return ret
}

// HPriceAmountReq struct implement
type HPriceAmountReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo           `json:"stHeader"`
	SCode     string               `json:"sCode"`
	FPrice    float32              `json:"fPrice"`
	EType     E_ORDER_OPERATE_TYPE `json:"eType"`
	EPushFlag E_HQ_PUSH_REG        `json:"ePushFlag"`
}

func (st *HPriceAmountReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HPriceAmountReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FPrice, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPriceAmountReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPriceAmountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPriceAmountReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FPrice, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPriceAmountReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPriceAmountReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPrice:", st.FPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HPriceAmountRsp struct implement
type HPriceAmountRsp struct {
	codec.JceStructBase
	EType  E_ORDER_OPERATE_TYPE `json:"eType"`
	FPrice float32              `json:"fPrice"`
	VOrder []HPriceAmount       `json:"vOrder"`
}

func (st *HPriceAmountRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPriceAmountRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.EType), 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FPrice, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VOrder = make([]HPriceAmount, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VOrder[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPriceAmountRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPriceAmountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPriceAmountRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.EType), 0)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FPrice, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VOrder)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VOrder {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPriceAmountRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPriceAmountRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPrice:", st.FPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vOrder:", st.VOrder)

	ret = ret + " }"
	return ret
}

// HBrokerQueueReq struct implement
type HBrokerQueueReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	Stock     HStockUnique  `json:"stock"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HBrokerQueueReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.Stock.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HBrokerQueueReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Stock.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBrokerQueueReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBrokerQueueReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBrokerQueueReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Stock.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBrokerQueueReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBrokerQueueReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + "stock:" + st.Stock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HBrokerQueueRsp struct implement
type HBrokerQueueRsp struct {
	codec.JceStructBase
	BrokerQueue HBrokerQueue `json:"brokerQueue"`
}

func (st *HBrokerQueueRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BrokerQueue.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HBrokerQueueRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.BrokerQueue.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBrokerQueueRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBrokerQueueRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBrokerQueueRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.BrokerQueue.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBrokerQueueRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBrokerQueueRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "brokerQueue:" + st.BrokerQueue.Display()

	ret = ret + " }"
	return ret
}

// HType2StockReq struct implement
type HType2StockReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo           `json:"stHeader"`
	VCategory   []E_STOCK_CATEGORY   `json:"vCategory"`
	EColumn     E_HQ_SORT_COLUMN     `json:"eColumn"`
	ESort       E_SORT_METHOD        `json:"eSort"`
	EHqData     E_STOCK_HQ_DATA      `json:"eHqData"`
	IWantNum    int32                `json:"iWantNum"`
	EPushFlag   E_HQ_PUSH_REG        `json:"ePushFlag"`
	EEnvData    E_STOCK_DATA_ENV     `json:"eEnvData"`
	BDelayHq    bool                 `json:"bDelayHq"`
	IStartPos   int32                `json:"iStartPos"`
	VBitmap     []int8               `json:"vBitmap"`
	VMarketType []HMarketTypeData    `json:"vMarketType"`
	ETypeMmp    E_TYPE_MMP           `json:"eTypeMmp"`
	VFilterType []E_RANK_FILTER_TYPE `json:"vFilterType"`
}

func (st *HType2StockReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EHqData = E_STOCK_HQ_DATA_E_SHD_NONE
	st.IWantNum = -1
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.EEnvData = E_STOCK_DATA_ENV_E_SHDE_NORMAL
	st.BDelayHq = false
	st.IStartPos = 0
	st.ETypeMmp = E_TYPE_MMP_E_MMP_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HType2StockReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VCategory = make([]E_STOCK_CATEGORY, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32((*int32)(&st.VCategory[i0]), 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EHqData), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EEnvData), 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDelayHq, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 9, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VBitmap[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(11, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarketType = make([]HMarketTypeData, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.VMarketType[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.ETypeMmp), 12, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(13, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VFilterType = make([]E_RANK_FILTER_TYPE, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = _is.Read_int32((*int32)(&st.VFilterType[i3]), 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HType2StockReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HType2StockReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HType2StockReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VCategory)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VCategory {

		err = _os.Write_int32(int32(v), 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EColumn), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EHqData), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EEnvData), 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDelayHq, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 9)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarketType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarketType {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.ETypeMmp), 12)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VFilterType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VFilterType {

		err = _os.Write_int32(int32(v), 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HType2StockReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HType2StockReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vCategory:", st.VCategory)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eHqData:", st.EHqData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eEnvData:", st.EEnvData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDelayHq:", st.BDelayHq)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMarketType:", st.VMarketType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eTypeMmp:", st.ETypeMmp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vFilterType:", st.VFilterType)

	ret = ret + " }"
	return ret
}

// HTypeListSimpleReq struct implement
type HTypeListSimpleReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo         `json:"stHeader"`
	VCategory   []E_STOCK_CATEGORY `json:"vCategory"`
	EColumn     E_HQ_SORT_COLUMN   `json:"eColumn"`
	ESort       E_SORT_METHOD      `json:"eSort"`
	EPushFlag   E_HQ_PUSH_REG      `json:"ePushFlag"`
	IStartPos   int32              `json:"iStartPos"`
	IWantNum    int32              `json:"iWantNum"`
	VBitmap     []int8             `json:"vBitmap"`
	VMarketType []HMarketTypeData  `json:"vMarketType"`
}

func (st *HTypeListSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.IStartPos = 0
	st.IWantNum = -1
}

//ReadFrom reads  from _is and put into struct.
func (st *HTypeListSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VCategory = make([]E_STOCK_CATEGORY, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32((*int32)(&st.VCategory[i0]), 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 6, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VBitmap[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarketType = make([]HMarketTypeData, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.VMarketType[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTypeListSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTypeListSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTypeListSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VCategory)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VCategory {

		err = _os.Write_int32(int32(v), 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EColumn), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 6)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarketType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarketType {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTypeListSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTypeListSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vCategory:", st.VCategory)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMarketType:", st.VMarketType)

	ret = ret + " }"
	return ret
}

// HSubTypeSubmit struct implement
type HSubTypeSubmit struct {
	codec.JceStructBase
	ShtMarket int16 `json:"shtMarket"`
	IType     int32 `json:"iType"`
	ISubType  int32 `json:"iSubType"`
}

func (st *HSubTypeSubmit) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IType = 0
	st.ISubType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HSubTypeSubmit) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IType, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ISubType, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSubTypeSubmit) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSubTypeSubmit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSubTypeSubmit) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IType, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ISubType, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSubTypeSubmit) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSubTypeSubmit) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iType:", st.IType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSubType:", st.ISubType)

	ret = ret + " }"
	return ret
}

// HType2StockSimpleReq struct implement
type HType2StockSimpleReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo           `json:"stHeader"`
	EBussType   E_BUSS_TYPE          `json:"eBussType"`
	EColumn     E_HQ_SORT_COLUMN     `json:"eColumn"`
	ESort       E_SORT_METHOD        `json:"eSort"`
	EHqData     E_STOCK_HQ_DATA      `json:"eHqData"`
	IWantNum    int32                `json:"iWantNum"`
	EPushFlag   E_HQ_PUSH_REG        `json:"ePushFlag"`
	EEnvData    E_STOCK_DATA_ENV     `json:"eEnvData"`
	BDelayHq    bool                 `json:"bDelayHq"`
	IStartPos   int32                `json:"iStartPos"`
	VBitmap     []int8               `json:"vBitmap"`
	VType       []HTypeSubType       `json:"vType"`
	ETypeMmp    E_TYPE_MMP           `json:"eTypeMmp"`
	VFilterType []E_RANK_FILTER_TYPE `json:"vFilterType"`
}

func (st *HType2StockSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EHqData = E_STOCK_HQ_DATA_E_SHD_NONE
	st.IWantNum = -1
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.EEnvData = E_STOCK_DATA_ENV_E_SHDE_NORMAL
	st.BDelayHq = false
	st.IStartPos = 0
	st.ETypeMmp = E_TYPE_MMP_E_MMP_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HType2StockSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EBussType), 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EHqData), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EEnvData), 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDelayHq, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 9, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(11, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VType = make([]HTypeSubType, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VType[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.ETypeMmp), 12, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(13, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VFilterType = make([]E_RANK_FILTER_TYPE, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_int32((*int32)(&st.VFilterType[i2]), 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HType2StockSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HType2StockSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HType2StockSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EBussType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EHqData), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EEnvData), 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDelayHq, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 9)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VType {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.ETypeMmp), 12)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VFilterType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VFilterType {

		err = _os.Write_int32(int32(v), 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HType2StockSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HType2StockSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eBussType:", st.EBussType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eHqData:", st.EHqData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eEnvData:", st.EEnvData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDelayHq:", st.BDelayHq)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vType:", st.VType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eTypeMmp:", st.ETypeMmp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vFilterType:", st.VFilterType)

	ret = ret + " }"
	return ret
}

// HBusListSimpleReq struct implement
type HBusListSimpleReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo       `json:"stHeader"`
	EBussType E_BUSS_TYPE      `json:"eBussType"`
	EColumn   E_HQ_SORT_COLUMN `json:"eColumn"`
	ESort     E_SORT_METHOD    `json:"eSort"`
	EPushFlag E_HQ_PUSH_REG    `json:"ePushFlag"`
	IStartPos int32            `json:"iStartPos"`
	IWantNum  int32            `json:"iWantNum"`
	VType     []HTypeSubType   `json:"vType"`
	VBitmap   []int8           `json:"vBitmap"`
}

func (st *HBusListSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.IStartPos = 0
	st.IWantNum = -1
}

//ReadFrom reads  from _is and put into struct.
func (st *HBusListSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EBussType), 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 6, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VType = make([]HTypeSubType, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VType[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VBitmap[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBusListSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBusListSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBusListSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EBussType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 6)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VType {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBusListSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBusListSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eBussType:", st.EBussType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vType:", st.VType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HType2StockRsp struct implement
type HType2StockRsp struct {
	codec.JceStructBase
	VStock    []HStockHq `json:"vStock"`
	ITotalNum int32      `json:"iTotalNum"`
}

func (st *HType2StockRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HType2StockRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockHq, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.ITotalNum, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HType2StockRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HType2StockRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HType2StockRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.ITotalNum, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HType2StockRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HType2StockRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalNum:", st.ITotalNum)

	ret = ret + " }"
	return ret
}

// HType2StockSimpleRsp struct implement
type HType2StockSimpleRsp struct {
	codec.JceStructBase
	VStock    []HStockHqSimple `json:"vStock"`
	ITotalNum int32            `json:"iTotalNum"`
}

func (st *HType2StockSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HType2StockSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockHqSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.ITotalNum, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HType2StockSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HType2StockSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HType2StockSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.ITotalNum, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HType2StockSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HType2StockSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalNum:", st.ITotalNum)

	ret = ret + " }"
	return ret
}

// HBlock2StockReq struct implement
type HBlock2StockReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo           `json:"stHeader"`
	VBlockCode  []string             `json:"vBlockCode"`
	EColumn     E_HQ_SORT_COLUMN     `json:"eColumn"`
	ESort       E_SORT_METHOD        `json:"eSort"`
	EHqData     E_STOCK_HQ_DATA      `json:"eHqData"`
	EPushFlag   E_HQ_PUSH_REG        `json:"ePushFlag"`
	EEnvData    E_STOCK_DATA_ENV     `json:"eEnvData"`
	IWantNum    int32                `json:"iWantNum"`
	BDelayHq    bool                 `json:"bDelayHq"`
	IStartPos   int32                `json:"iStartPos"`
	VBitmap     []int8               `json:"vBitmap"`
	ETypeMmp    E_TYPE_MMP           `json:"eTypeMmp"`
	VFilterType []E_RANK_FILTER_TYPE `json:"vFilterType"`
}

func (st *HBlock2StockReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EHqData = E_STOCK_HQ_DATA_E_SHD_NONE
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.EEnvData = E_STOCK_DATA_ENV_E_SHDE_NORMAL
	st.IWantNum = -1
	st.BDelayHq = false
	st.IStartPos = 0
	st.ETypeMmp = E_TYPE_MMP_E_MMP_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HBlock2StockReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VBlockCode = make([]string, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = _is.Read_string(&st.VBlockCode[i0], 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_int32((*int32)(&st.EColumn), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EHqData), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EEnvData), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDelayHq, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 9, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VBitmap[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.ETypeMmp), 11, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(12, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VFilterType = make([]E_RANK_FILTER_TYPE, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_int32((*int32)(&st.VFilterType[i2]), 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBlock2StockReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBlock2StockReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBlock2StockReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBlockCode)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBlockCode {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EColumn), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EHqData), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EEnvData), 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDelayHq, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 9)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ETypeMmp), 11)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VFilterType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VFilterType {

		err = _os.Write_int32(int32(v), 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBlock2StockReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBlock2StockReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBlockCode:", st.VBlockCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eHqData:", st.EHqData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eEnvData:", st.EEnvData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDelayHq:", st.BDelayHq)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eTypeMmp:", st.ETypeMmp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vFilterType:", st.VFilterType)

	ret = ret + " }"
	return ret
}

// HBlock2StockSimpleReq struct implement
type HBlock2StockSimpleReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo       `json:"stHeader"`
	VBlockCode []string         `json:"vBlockCode"`
	EColumn    E_HQ_SORT_COLUMN `json:"eColumn"`
	ESort      E_SORT_METHOD    `json:"eSort"`
	EPushFlag  E_HQ_PUSH_REG    `json:"ePushFlag"`
	IStartPos  int32            `json:"iStartPos"`
	IWantNum   int32            `json:"iWantNum"`
	VBitmap    []int8           `json:"vBitmap"`
}

func (st *HBlock2StockSimpleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.IStartPos = 0
	st.IWantNum = -1
}

//ReadFrom reads  from _is and put into struct.
func (st *HBlock2StockSimpleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VBlockCode = make([]string, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = _is.Read_string(&st.VBlockCode[i0], 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_int32((*int32)(&st.EColumn), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 6, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VBitmap[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBlock2StockSimpleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBlock2StockSimpleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBlock2StockSimpleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBlockCode)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBlockCode {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EColumn), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 6)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBlock2StockSimpleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBlock2StockSimpleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBlockCode:", st.VBlockCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HBlock2StockRsp struct implement
type HBlock2StockRsp struct {
	codec.JceStructBase
	MStockList map[string]HType2StockRsp `json:"mStockList"`
}

func (st *HBlock2StockRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HBlock2StockRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MStockList = make(map[string]HType2StockRsp)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 HType2StockRsp

			err = _is.Read_string(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MStockList[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBlock2StockRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBlock2StockRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBlock2StockRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MStockList)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MStockList {

		err = _os.Write_string(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBlock2StockRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBlock2StockRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mStockList:", st.MStockList)

	ret = ret + " }"
	return ret
}

// HTsBlockLevelReq struct implement
type HTsBlockLevelReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo `json:"stHeader"`
	VBlockCode []string   `json:"vBlockCode"`
}

func (st *HTsBlockLevelReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTsBlockLevelReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBlockCode = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_string(&st.VBlockCode[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTsBlockLevelReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTsBlockLevelReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTsBlockLevelReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBlockCode)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBlockCode {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTsBlockLevelReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTsBlockLevelReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBlockCode:", st.VBlockCode)

	ret = ret + " }"
	return ret
}

// HTsBlockLevelRsp struct implement
type HTsBlockLevelRsp struct {
	codec.JceStructBase
	MTsLevel map[string]map[string][]string `json:"mTsLevel"`
}

func (st *HTsBlockLevelRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTsBlockLevelRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MTsLevel = make(map[string]map[string][]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 map[string][]string

			err = _is.Read_string(&k0, 0, false)
			if err != nil {
				return err
			}

			err, have = _is.SkipTo(codec.MAP, 1, false)
			if err != nil {
				return err
			}

			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return err
				}

				v0 = make(map[string][]string)
				for i1, e1 := int32(0), length; i1 < e1; i1++ {
					var k1 string
					var v1 []string

					err = _is.Read_string(&k1, 0, false)
					if err != nil {
						return err
					}

					err, have, ty = _is.SkipToNoCheck(1, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return err
							}

							v1 = make([]string, length)
							for i2, e2 := int32(0), length; i2 < e2; i2++ {

								err = _is.Read_string(&v1[i2], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SIMPLE_LIST {
							err = fmt.Errorf("not support simple_list type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}

					v0[k1] = v1
				}
			}

			st.MTsLevel[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTsBlockLevelRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTsBlockLevelRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTsBlockLevelRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MTsLevel)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.MTsLevel {

		err = _os.Write_string(k3, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v3)), 0)
		if err != nil {
			return err
		}

		for k4, v4 := range v3 {

			err = _os.Write_string(k4, 0)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 1)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(v4)), 0)
			if err != nil {
				return err
			}

			for _, v := range v4 {

				err = _os.Write_string(v, 0)
				if err != nil {
					return err
				}

			}
		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTsBlockLevelRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTsBlockLevelRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mTsLevel:", st.MTsLevel)

	ret = ret + " }"
	return ret
}

// HBlock2StockSimpleRsp struct implement
type HBlock2StockSimpleRsp struct {
	codec.JceStructBase
	MStockList map[string]HType2StockSimpleRsp `json:"mStockList"`
}

func (st *HBlock2StockSimpleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HBlock2StockSimpleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MStockList = make(map[string]HType2StockSimpleRsp)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 HType2StockSimpleRsp

			err = _is.Read_string(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MStockList[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBlock2StockSimpleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBlock2StockSimpleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBlock2StockSimpleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MStockList)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MStockList {

		err = _os.Write_string(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBlock2StockSimpleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBlock2StockSimpleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mStockList:", st.MStockList)

	ret = ret + " }"
	return ret
}

// HStock2BlockReq struct implement
type HStock2BlockReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo       `json:"stHeader"`
	SStockCode string           `json:"sStockCode"`
	EColumn    E_HQ_SORT_COLUMN `json:"eColumn"`
	ESort      E_SORT_METHOD    `json:"eSort"`
	EHqData    E_STOCK_HQ_DATA  `json:"eHqData"`
	EPushFlag  E_HQ_PUSH_REG    `json:"ePushFlag"`
	EEnvData   E_STOCK_DATA_ENV `json:"eEnvData"`
	IWantNum   int32            `json:"iWantNum"`
	VBitmap    []int8           `json:"vBitmap"`
	BDelayHq   bool             `json:"bDelayHq"`
	ETypeMmp   E_TYPE_MMP       `json:"eTypeMmp"`
}

func (st *HStock2BlockReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EHqData = E_STOCK_HQ_DATA_E_SHD_NONE
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.EEnvData = E_STOCK_DATA_ENV_E_SHDE_NORMAL
	st.IWantNum = -1
	st.BDelayHq = false
	st.ETypeMmp = E_TYPE_MMP_E_MMP_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HStock2BlockReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SStockCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EHqData), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EEnvData), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.BDelayHq, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ETypeMmp), 10, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStock2BlockReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStock2BlockReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStock2BlockReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SStockCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EHqData), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EEnvData), 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDelayHq, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ETypeMmp), 10)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStock2BlockReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStock2BlockReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sStockCode:", st.SStockCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eHqData:", st.EHqData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eEnvData:", st.EEnvData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDelayHq:", st.BDelayHq)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eTypeMmp:", st.ETypeMmp)

	ret = ret + " }"
	return ret
}

// HStock2BlockRsp struct implement
type HStock2BlockRsp struct {
	codec.JceStructBase
	VBlock []HStockHq `json:"vBlock"`
}

func (st *HStock2BlockRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStock2BlockRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBlock = make([]HStockHq, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VBlock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStock2BlockRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStock2BlockRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStock2BlockRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBlock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBlock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStock2BlockRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStock2BlockRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vBlock:", st.VBlock)

	ret = ret + " }"
	return ret
}

// HCustomType2StockReq struct implement
type HCustomType2StockReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo       `json:"stHeader"`
	IType     E_CUSTOM_TYPE    `json:"iType"`
	EHqData   E_STOCK_HQ_DATA  `json:"eHqData"`
	EEnvData  E_STOCK_DATA_ENV `json:"eEnvData"`
	IWantNum  int32            `json:"iWantNum"`
	IStartPos int32            `json:"iStartPos"`
	VBitmap   []int8           `json:"vBitmap"`
}

func (st *HCustomType2StockReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EHqData = E_STOCK_HQ_DATA_E_SHD_NONE
	st.EEnvData = E_STOCK_DATA_ENV_E_SHDE_NORMAL
	st.IWantNum = -1
	st.IStartPos = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HCustomType2StockReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.IType), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EHqData), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EEnvData), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCustomType2StockReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCustomType2StockReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCustomType2StockReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.IType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EHqData), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EEnvData), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 6)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCustomType2StockReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCustomType2StockReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iType:", st.IType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eHqData:", st.EHqData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eEnvData:", st.EEnvData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HSortListReq struct implement
type HSortListReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo       `json:"stHeader"`
	EBussType E_BUSS_TYPE      `json:"eBussType"`
	EColumn   E_HQ_SORT_COLUMN `json:"eColumn"`
	ESort     E_SORT_METHOD    `json:"eSort"`
	EPushFlag E_HQ_PUSH_REG    `json:"ePushFlag"`
	IWantNum  int32            `json:"iWantNum"`
}

func (st *HSortListReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.IWantNum = -1
}

//ReadFrom reads  from _is and put into struct.
func (st *HSortListReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EBussType), 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSortListReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSortListReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSortListReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EBussType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSortListReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSortListReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eBussType:", st.EBussType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)

	ret = ret + " }"
	return ret
}

// HSortListRsp struct implement
type HSortListRsp struct {
	codec.JceStructBase
	VStock []HStockUnique `json:"vStock"`
}

func (st *HSortListRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSortListRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSortListRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSortListRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSortListRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSortListRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSortListRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HOptionUnderlyingDictReq struct implement
type HOptionUnderlyingDictReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo `json:"stHeader"`
	VecMarket []uint16   `json:"vecMarket"`
}

func (st *HOptionUnderlyingDictReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionUnderlyingDictReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecMarket = make([]uint16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint16(&st.VecMarket[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionUnderlyingDictReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionUnderlyingDictReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionUnderlyingDictReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecMarket)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecMarket {

		err = _os.Write_uint16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionUnderlyingDictReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionUnderlyingDictReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecMarket:", st.VecMarket)

	ret = ret + " }"
	return ret
}

// HOptionUnderlyingDictRsp struct implement
type HOptionUnderlyingDictRsp struct {
	codec.JceStructBase
	MapDict map[uint16][]HOptionUnderlyingDictInfo `json:"mapDict"`
}

func (st *HOptionUnderlyingDictRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionUnderlyingDictRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapDict = make(map[uint16][]HOptionUnderlyingDictInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 uint16
			var v0 []HOptionUnderlyingDictInfo

			err = _is.Read_uint16(&k0, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v0 = make([]HOptionUnderlyingDictInfo, length)
					for i1, e1 := int32(0), length; i1 < e1; i1++ {

						err = v0[i1].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.MapDict[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionUnderlyingDictRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionUnderlyingDictRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionUnderlyingDictRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapDict)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.MapDict {

		err = _os.Write_uint16(k2, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v2)), 0)
		if err != nil {
			return err
		}

		for _, v := range v2 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionUnderlyingDictRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionUnderlyingDictRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapDict:", st.MapDict)

	ret = ret + " }"
	return ret
}

// HOptionStockReq struct implement
type HOptionStockReq struct {
	codec.JceStructBase
	StHeader           HeaderInfo       `json:"stHeader"`
	UsUnderlyingMarket uint16           `json:"usUnderlyingMarket"`
	SUnderlyingCode    string           `json:"sUnderlyingCode"`
	SContractType      string           `json:"sContractType"`
	EColumn            E_HQ_SORT_COLUMN `json:"eColumn"`
	ESort              E_SORT_METHOD    `json:"eSort"`
	EHqData            E_STOCK_HQ_DATA  `json:"eHqData"`
	IWantNum           int32            `json:"iWantNum"`
	EPushFlag          E_HQ_PUSH_REG    `json:"ePushFlag"`
	EEnvData           E_STOCK_DATA_ENV `json:"eEnvData"`
	VBitmap            []int8           `json:"vBitmap"`
}

func (st *HOptionStockReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.EHqData = E_STOCK_HQ_DATA_E_SHD_NONE
	st.IWantNum = -1
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.EEnvData = E_STOCK_DATA_ENV_E_SHDE_NORMAL
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionStockReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint16(&st.UsUnderlyingMarket, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SUnderlyingCode, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SContractType, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EHqData), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EEnvData), 9, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBitmap[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionStockReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionStockReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionStockReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_uint16(st.UsUnderlyingMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SUnderlyingCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SContractType, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EHqData), 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EEnvData), 9)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionStockReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionStockReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("usUnderlyingMarket:", st.UsUnderlyingMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sUnderlyingCode:", st.SUnderlyingCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sContractType:", st.SContractType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eHqData:", st.EHqData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eEnvData:", st.EEnvData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HOptionStockRsp struct implement
type HOptionStockRsp struct {
	codec.JceStructBase
	VStock []HStockHq `json:"vStock"`
}

func (st *HOptionStockRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionStockRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockHq, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionStockRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionStockRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionStockRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionStockRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionStockRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HEtfInfoReq struct implement
type HEtfInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HEtfInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HEtfInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HEtfInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HEtfInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HEtfInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HEtfInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HEtfInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HEtfInfoRsp struct implement
type HEtfInfoRsp struct {
	codec.JceStructBase
	VEtfInfo []HEtfDescInfo `json:"vEtfInfo"`
}

func (st *HEtfInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HEtfInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VEtfInfo = make([]HEtfDescInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VEtfInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HEtfInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HEtfInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HEtfInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VEtfInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VEtfInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HEtfInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HEtfInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vEtfInfo:", st.VEtfInfo)

	ret = ret + " }"
	return ret
}

// HStock2IndustryReq struct implement
type HStock2IndustryReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HStock2IndustryReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStock2IndustryReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStock2IndustryReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStock2IndustryReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStock2IndustryReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStock2IndustryReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStock2IndustryReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HStock2IndustryRsp struct implement
type HStock2IndustryRsp struct {
	codec.JceStructBase
	VStockIndustry []HStockIndustry `json:"vStockIndustry"`
}

func (st *HStock2IndustryRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStock2IndustryRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockIndustry = make([]HStockIndustry, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockIndustry[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStock2IndustryRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStock2IndustryRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStock2IndustryRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockIndustry)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockIndustry {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStock2IndustryRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStock2IndustryRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockIndustry:", st.VStockIndustry)

	ret = ret + " }"
	return ret
}

// HCancelPushReq struct implement
type HCancelPushReq struct {
	codec.JceStructBase
	LReqID int64 `json:"lReqID"`
}

func (st *HCancelPushReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCancelPushReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LReqID, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCancelPushReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCancelPushReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCancelPushReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LReqID, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCancelPushReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCancelPushReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lReqID:", st.LReqID)

	ret = ret + " }"
	return ret
}

// HCQCXInfoReq struct implement
type HCQCXInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HCQCXInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCQCXInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCQCXInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCQCXInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCQCXInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCQCXInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCQCXInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HCQCXInfoRsp struct implement
type HCQCXInfoRsp struct {
	codec.JceStructBase
	VInfo []HCQCX `json:"vInfo"`
}

func (st *HCQCXInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCQCXInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HCQCX, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCQCXInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCQCXInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCQCXInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCQCXInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCQCXInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}

// HFinDataReq struct implement
type HFinDataReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HFinDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFinDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFinDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFinDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFinDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFinDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFinDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HFinDataRsp struct implement
type HFinDataRsp struct {
	codec.JceStructBase
	VInfo []HFinData `json:"vInfo"`
}

func (st *HFinDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFinDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HFinData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFinDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFinDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFinDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFinDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFinDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}

// HFinBatchReq struct implement
type HFinBatchReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo `json:"stHeader"`
	SCheckSum string     `json:"sCheckSum"`
}

func (st *HFinBatchReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFinBatchReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCheckSum, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFinBatchReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFinBatchReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFinBatchReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCheckSum, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFinBatchReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFinBatchReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)

	ret = ret + " }"
	return ret
}

// HFinBatchRsp struct implement
type HFinBatchRsp struct {
	codec.JceStructBase
	VInfo     []HFinData `json:"vInfo"`
	SCheckSum string     `json:"sCheckSum"`
}

func (st *HFinBatchRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFinBatchRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HFinData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.SCheckSum, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFinBatchRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFinBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFinBatchRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.SCheckSum, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFinBatchRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFinBatchRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)

	ret = ret + " }"
	return ret
}

// HQXInfoReq struct implement
type HQXInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HQXInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HQXInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HQXInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HQXInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HQXInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HQXInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HQXInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HQXInfoRsp struct implement
type HQXInfoRsp struct {
	codec.JceStructBase
	VInfo []SQXData `json:"vInfo"`
}

func (st *HQXInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HQXInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]SQXData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HQXInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HQXInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HQXInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HQXInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HQXInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}

// HCWDataReq struct implement
type HCWDataReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HCWDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCWDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCWDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCWDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCWDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCWDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCWDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HCWDataRsp struct implement
type HCWDataRsp struct {
	codec.JceStructBase
	VInfo []SCWData `json:"vInfo"`
}

func (st *HCWDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCWDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]SCWData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCWDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCWDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCWDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCWDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCWDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}

// HCWVerReq struct implement
type HCWVerReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HCWVerReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCWVerReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCWVerReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCWVerReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCWVerReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCWVerReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCWVerReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HCWVerRsp struct implement
type HCWVerRsp struct {
	codec.JceStructBase
	VInfo []HCWVerData `json:"vInfo"`
}

func (st *HCWVerRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCWVerRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HCWVerData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCWVerRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCWVerRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCWVerRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCWVerRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCWVerRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}

// HLTGChgReq struct implement
type HLTGChgReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HLTGChgReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HLTGChgReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HLTGChgReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HLTGChgReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HLTGChgReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HLTGChgReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HLTGChgReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HLTGChgRsp struct implement
type HLTGChgRsp struct {
	codec.JceStructBase
	VInfo []HLTGChg `json:"vInfo"`
}

func (st *HLTGChgRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HLTGChgRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HLTGChg, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HLTGChgRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HLTGChgRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HLTGChgRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HLTGChgRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HLTGChgRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}

// HFileReq struct implement
type HFileReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo `json:"stHeader"`
	SFileName string     `json:"sFileName"`
	IPos      int32      `json:"iPos"`
	SCheckSum string     `json:"sCheckSum"`
	ILen      int32      `json:"iLen"`
	BCompress bool       `json:"bCompress"`
}

func (st *HFileReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFileReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SFileName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IPos, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCheckSum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ILen, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCompress, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFileReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFileReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFileReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SFileName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IPos, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCheckSum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ILen, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCompress, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFileReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFileReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sFileName:", st.SFileName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iPos:", st.IPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iLen:", st.ILen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCompress:", st.BCompress)

	ret = ret + " }"
	return ret
}

// HFileRsp struct implement
type HFileRsp struct {
	codec.JceStructBase
	BChg          bool   `json:"bChg"`
	VBuf          []int8 `json:"vBuf"`
	BRemain       bool   `json:"bRemain"`
	SCheckSum     string `json:"sCheckSum"`
	ICompressSize int32  `json:"iCompressSize"`
	IRawSize      int32  `json:"iRawSize"`
}

func (st *HFileRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BChg = false
	st.BRemain = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HFileRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_bool(&st.BChg, 1, true)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuf = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBuf[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBuf, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.BRemain, 3, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCheckSum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ICompressSize, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IRawSize, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFileRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFileRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFileRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_bool(st.BChg, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuf)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBuf)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BRemain, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCheckSum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ICompressSize, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IRawSize, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFileRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFileRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("bChg:", st.BChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuf:", st.VBuf)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bRemain:", st.BRemain)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iCompressSize:", st.ICompressSize)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iRawSize:", st.IRawSize)

	ret = ret + " }"
	return ret
}

// HFileBatchReq struct implement
type HFileBatchReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo  `json:"stHeader"`
	VFileInfo []HFileInfo `json:"vFileInfo"`
}

func (st *HFileBatchReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFileBatchReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VFileInfo = make([]HFileInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VFileInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFileBatchReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFileBatchReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFileBatchReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VFileInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VFileInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFileBatchReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFileBatchReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vFileInfo:", st.VFileInfo)

	ret = ret + " }"
	return ret
}

// HFileBatchRsp struct implement
type HFileBatchRsp struct {
	codec.JceStructBase
	VFileData []HFileData `json:"vFileData"`
}

func (st *HFileBatchRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFileBatchRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VFileData = make([]HFileData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VFileData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFileBatchRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFileBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFileBatchRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VFileData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VFileData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFileBatchRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFileBatchRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vFileData:", st.VFileData)

	ret = ret + " }"
	return ret
}

// HProxyRegReq struct implement
type HProxyRegReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HProxyRegReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HProxyRegReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HProxyRegReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HProxyRegReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HProxyRegReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HProxyRegReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HProxyRegReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HProxyRegRsp struct implement
type HProxyRegRsp struct {
	codec.JceStructBase
	LSerialNo int64 `json:"lSerialNo"`
}

func (st *HProxyRegRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HProxyRegRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LSerialNo, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HProxyRegRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HProxyRegRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HProxyRegRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LSerialNo, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HProxyRegRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HProxyRegRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lSerialNo:", st.LSerialNo)

	ret = ret + " }"
	return ret
}

// HProxyStatReq struct implement
type HProxyStatReq struct {
	codec.JceStructBase
	StHeader     HeaderInfo `json:"stHeader"`
	SProxyAddr   string     `json:"sProxyAddr"`
	IActiveCount int32      `json:"iActiveCount"`
}

func (st *HProxyStatReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HProxyStatReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SProxyAddr, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IActiveCount, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HProxyStatReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HProxyStatReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HProxyStatReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SProxyAddr, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IActiveCount, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HProxyStatReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HProxyStatReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sProxyAddr:", st.SProxyAddr)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iActiveCount:", st.IActiveCount)

	ret = ret + " }"
	return ret
}

// HProxyStatRsp struct implement
type HProxyStatRsp struct {
	codec.JceStructBase
	IRet int32 `json:"iRet"`
}

func (st *HProxyStatRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HProxyStatRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IRet, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HProxyStatRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HProxyStatRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HProxyStatRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IRet, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HProxyStatRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HProxyStatRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iRet:", st.IRet)

	ret = ret + " }"
	return ret
}

// HType2StockPushReq struct implement
type HType2StockPushReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HType2StockPushReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HType2StockPushReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HType2StockPushReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HType2StockPushReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HType2StockPushReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HType2StockPushReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HType2StockPushReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HType2StockPushRsp struct implement
type HType2StockPushRsp struct {
	codec.JceStructBase
	VStockHq []HStockHq `json:"vStockHq"`
}

func (st *HType2StockPushRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HType2StockPushRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockHq = make([]HStockHq, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockHq[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HType2StockPushRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HType2StockPushRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HType2StockPushRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockHq)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockHq {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HType2StockPushRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HType2StockPushRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockHq:", st.VStockHq)

	ret = ret + " }"
	return ret
}

// HIntervalReq struct implement
type HIntervalReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HIntervalReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HIntervalReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HIntervalReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HIntervalReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HIntervalReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HIntervalReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HIntervalReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HIntervalRsp struct implement
type HIntervalRsp struct {
	codec.JceStructBase
	BTrading  bool   `json:"bTrading"`
	LInterval int64  `json:"lInterval"`
	ISequence uint32 `json:"iSequence"`
}

func (st *HIntervalRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BTrading = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HIntervalRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_bool(&st.BTrading, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LInterval, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.ISequence, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HIntervalRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HIntervalRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HIntervalRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_bool(st.BTrading, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LInterval, 2)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.ISequence, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HIntervalRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HIntervalRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("bTrading:", st.BTrading)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lInterval:", st.LInterval)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSequence:", st.ISequence)

	ret = ret + " }"
	return ret
}

// HZHRankReq struct implement
type HZHRankReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo     `json:"stHeader"`
	EStockType E_BUSS_TYPE    `json:"eStockType"`
	INum       int32          `json:"iNum"`
	ERankType  H_ZH_RANK_TYPE `json:"eRankType"`
	EPushFlag  E_HQ_PUSH_REG  `json:"ePushFlag"`
}

func (st *HZHRankReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HZHRankReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStockType), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.INum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ERankType), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HZHRankReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HZHRankReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HZHRankReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStockType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.INum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ERankType), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HZHRankReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HZHRankReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStockType:", st.EStockType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNum:", st.INum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eRankType:", st.ERankType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HZHRankRsp struct implement
type HZHRankRsp struct {
	codec.JceStructBase
	VRank []HZHRankData `json:"vRank"`
}

func (st *HZHRankRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HZHRankRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRank = make([]HZHRankData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRank[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HZHRankRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HZHRankRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HZHRankRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRank)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRank {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HZHRankRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HZHRankRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vRank:", st.VRank)

	ret = ret + " }"
	return ret
}

// HMFRankSimReq struct implement
type HMFRankSimReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo            `json:"stHeader"`
	EStockType E_BUSS_TYPE           `json:"eStockType"`
	INum       int32                 `json:"iNum"`
	ERankType  E_MF_RANK_SORT_COLUMN `json:"eRankType"`
	EPushFlag  E_HQ_PUSH_REG         `json:"ePushFlag"`
}

func (st *HMFRankSimReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ERankType = E_MF_RANK_SORT_COLUMN_EMRC_DAY_ZLLR
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFRankSimReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStockType), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.INum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ERankType), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFRankSimReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFRankSimReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFRankSimReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStockType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.INum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ERankType), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFRankSimReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFRankSimReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStockType:", st.EStockType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNum:", st.INum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eRankType:", st.ERankType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HMFRankSimpRsp struct implement
type HMFRankSimpRsp struct {
	codec.JceStructBase
	VTop  []HStockRankData `json:"vTop"`
	VLast []HStockRankData `json:"vLast"`
}

func (st *HMFRankSimpRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFRankSimpRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTop = make([]HStockRankData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VTop[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VLast = make([]HStockRankData, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VLast[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFRankSimpRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFRankSimpRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFRankSimpRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTop)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTop {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VLast)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VLast {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFRankSimpRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFRankSimpRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vTop:", st.VTop)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vLast:", st.VLast)

	ret = ret + " }"
	return ret
}

// HBKLedReq struct implement
type HBKLedReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo    `json:"stHeader"`
	EStockType E_BUSS_TYPE   `json:"eStockType"`
	IBlockNum  int32         `json:"iBlockNum"`
	IStockNum  int32         `json:"iStockNum"`
	EPushFlag  E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HBKLedReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HBKLedReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStockType), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IBlockNum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStockNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBKLedReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBKLedReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBKLedReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStockType), 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IBlockNum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStockNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBKLedReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBKLedReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStockType:", st.EStockType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iBlockNum:", st.IBlockNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStockNum:", st.IStockNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HBKLedRsp struct implement
type HBKLedRsp struct {
	codec.JceStructBase
	VRank []HBKLedData `json:"vRank"`
}

func (st *HBKLedRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HBKLedRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRank = make([]HBKLedData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRank[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBKLedRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBKLedRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBKLedRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRank)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRank {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBKLedRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBKLedRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vRank:", st.VRank)

	ret = ret + " }"
	return ret
}

// HStockDDZReq struct implement
type HStockDDZReq struct {
	codec.JceStructBase
	StHeader     HeaderInfo        `json:"stHeader"`
	SCode        string            `json:"sCode"`
	EType        HISTORY_DATA_TYPE `json:"eType"`
	ShtStartxh   int16             `json:"shtStartxh"`
	ShtWantNum   int16             `json:"shtWantNum"`
	LDate        int64             `json:"lDate"`
	EMfType      E_MONEYFLOW_TYPE  `json:"eMfType"`
	ShtWantDay   int16             `json:"shtWantDay"`
	BIncludeDate bool              `json:"bIncludeDate"`
}

func (st *HStockDDZReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 100
	st.LDate = -1
	st.EMfType = E_MONEYFLOW_TYPE_E_MONEYFLOW_DOUBLE
	st.ShtWantDay = 0
	st.BIncludeDate = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDDZReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LDate, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EMfType), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantDay, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BIncludeDate, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDDZReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDDZReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDDZReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LDate, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EMfType), 6)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantDay, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BIncludeDate, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDDZReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDDZReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lDate:", st.LDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eMfType:", st.EMfType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantDay:", st.ShtWantDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bIncludeDate:", st.BIncludeDate)

	ret = ret + " }"
	return ret
}

// HStockDDZRsp struct implement
type HStockDDZRsp struct {
	codec.JceStructBase
	VDDZData []HDDZData `json:"vDDZData"`
}

func (st *HStockDDZRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDDZRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VDDZData = make([]HDDZData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VDDZData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDDZRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDDZRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDDZRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VDDZData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VDDZData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDDZRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDDZRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vDDZData:", st.VDDZData)

	ret = ret + " }"
	return ret
}

// HRegStatusReq struct implement
type HRegStatusReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HRegStatusReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegStatusReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegStatusReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegStatusReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegStatusReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegStatusReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegStatusReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HRegStatusRsp struct implement
type HRegStatusRsp struct {
	codec.JceStructBase
	VTypeStatus   []HTypeStatusData   `json:"vTypeStatus"`
	LMarketTime   int64               `json:"lMarketTime"`
	NMarketStatus int16               `json:"nMarketStatus"`
	VMktStatus    []HMarketStatusData `json:"vMktStatus"`
}

func (st *HRegStatusRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRegStatusRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTypeStatus = make([]HTypeStatusData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VTypeStatus[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.LMarketTime, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.NMarketStatus, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMktStatus = make([]HMarketStatusData, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VMktStatus[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRegStatusRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRegStatusRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRegStatusRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTypeStatus)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTypeStatus {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.LMarketTime, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.NMarketStatus, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMktStatus)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMktStatus {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRegStatusRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRegStatusRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vTypeStatus:", st.VTypeStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lMarketTime:", st.LMarketTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nMarketStatus:", st.NMarketStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMktStatus:", st.VMktStatus)

	ret = ret + " }"
	return ret
}

// HCltInfoReq struct implement
type HCltInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	ISdkVer  int32      `json:"iSdkVer"`
}

func (st *HCltInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ISdkVer = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HCltInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ISdkVer, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCltInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCltInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCltInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ISdkVer, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCltInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCltInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSdkVer:", st.ISdkVer)

	ret = ret + " }"
	return ret
}

// HCltInfoRsp struct implement
type HCltInfoRsp struct {
	codec.JceStructBase
	EStatus E_CLT_INFO_STATUS `json:"eStatus"`
}

func (st *HCltInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCltInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.EStatus), 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCltInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCltInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCltInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.EStatus), 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCltInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCltInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)

	ret = ret + " }"
	return ret
}

// HNewStockPerformReq struct implement
type HNewStockPerformReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	IStartxh uint32     `json:"iStartxh"`
	IWantNum uint32     `json:"iWantNum"`
}

func (st *HNewStockPerformReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IStartxh = 0
	st.IWantNum = 10
}

//ReadFrom reads  from _is and put into struct.
func (st *HNewStockPerformReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.IStartxh, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.IWantNum, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HNewStockPerformReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HNewStockPerformReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HNewStockPerformReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.IStartxh, 1)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.IWantNum, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HNewStockPerformReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HNewStockPerformReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartxh:", st.IStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)

	ret = ret + " }"
	return ret
}

// HNewStockPerformRsp struct implement
type HNewStockPerformRsp struct {
	codec.JceStructBase
	VStock []HNewStockPerform `json:"vStock"`
}

func (st *HNewStockPerformRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HNewStockPerformRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HNewStockPerform, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HNewStockPerformRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HNewStockPerformRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HNewStockPerformRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HNewStockPerformRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HNewStockPerformRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HNewStockPerformByStockReq struct implement
type HNewStockPerformByStockReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HNewStockPerformByStockReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HNewStockPerformByStockReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HNewStockPerformByStockReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HNewStockPerformByStockReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HNewStockPerformByStockReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HNewStockPerformByStockReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HNewStockPerformByStockReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HRangeStatsReq struct implement
type HRangeStatsReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo        `json:"stHeader"`
	VStock     []HStockUnique    `json:"vStock"`
	ELineType  HISTORY_DATA_TYPE `json:"eLineType"`
	ShtStartxh int16             `json:"shtStartxh"`
	ShtWantNum int16             `json:"shtWantNum"`
	IStartDate int32             `json:"iStartDate"`
	IEndDate   int32             `json:"iEndDate"`
	EQxMode    E_QX_MODE         `json:"eQxMode"`
	VBitmap    []int8            `json:"vBitmap"`
}

func (st *HRangeStatsReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ShtStartxh = 0
	st.ShtWantNum = 0
	st.IStartDate = 0
	st.IEndDate = 0
	st.EQxMode = E_QX_MODE_EQM_QX_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HRangeStatsReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VStock = make([]HStockUnique, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.VStock[i0].ReadBlock(_is, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("not support simple_list type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = _is.Read_int32((*int32)(&st.ELineType), 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStartxh, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartDate, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEndDate, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EQxMode), 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBitmap = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int8(&st.VBitmap[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBitmap, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRangeStatsReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRangeStatsReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRangeStatsReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.ELineType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStartxh, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartDate, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEndDate, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EQxMode), 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBitmap)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBitmap)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRangeStatsReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRangeStatsReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eLineType:", st.ELineType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStartxh:", st.ShtStartxh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartDate:", st.IStartDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDate:", st.IEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eQxMode:", st.EQxMode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBitmap:", st.VBitmap)

	ret = ret + " }"
	return ret
}

// HStockRangeStats struct implement
type HStockRangeStats struct {
	codec.JceStructBase
	ShtPrecise uint16  `json:"shtPrecise"`
	ShtSetcode int16   `json:"shtSetcode"`
	SCode      string  `json:"sCode"`
	FHigh      float64 `json:"fHigh"`
	FClose     float64 `json:"fClose"`
	FPrice     float64 `json:"fPrice"`
}

func (st *HStockRangeStats) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockRangeStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint16(&st.ShtPrecise, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHigh, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FClose, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FPrice, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockRangeStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockRangeStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockRangeStats) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint16(st.ShtPrecise, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHigh, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FClose, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FPrice, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockRangeStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockRangeStats) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtPrecise:", st.ShtPrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHigh:", st.FHigh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fClose:", st.FClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPrice:", st.FPrice)

	ret = ret + " }"
	return ret
}

// HRangeStatsRsp struct implement
type HRangeStatsRsp struct {
	codec.JceStructBase
	VData []HStockRangeStats `json:"vData"`
}

func (st *HRangeStatsRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRangeStatsRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HStockRangeStats, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRangeStatsRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRangeStatsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRangeStatsRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRangeStatsRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRangeStatsRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// HRadarQtReq struct implement
type HRadarQtReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	IWantNum  int32         `json:"iWantNum"`
	IStartPos int32         `json:"iStartPos"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HRadarQtReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IWantNum = -1
	st.IStartPos = 0
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HRadarQtReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRadarQtReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRadarQtReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRadarQtReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRadarQtReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRadarQtReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HRadarQtRsp struct implement
type HRadarQtRsp struct {
	codec.JceStructBase
	VecQt []HRadarQt `json:"vecQt"`
}

func (st *HRadarQtRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRadarQtRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecQt = make([]HRadarQt, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VecQt[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRadarQtRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRadarQtRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRadarQtRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecQt)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecQt {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRadarQtRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRadarQtRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vecQt:", st.VecQt)

	ret = ret + " }"
	return ret
}

// HRadarChgReq struct implement
type HRadarChgReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	IWantNum  int32         `json:"iWantNum"`
	IStartPos int32         `json:"iStartPos"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HRadarChgReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IWantNum = -1
	st.IStartPos = 0
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HRadarChgReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRadarChgReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRadarChgReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRadarChgReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRadarChgReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRadarChgReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HRadarChgRsp struct implement
type HRadarChgRsp struct {
	codec.JceStructBase
	VecChg []HRadarChg `json:"vecChg"`
}

func (st *HRadarChgRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRadarChgRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecChg = make([]HRadarChg, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VecChg[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRadarChgRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRadarChgRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRadarChgRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecChg)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecChg {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRadarChgRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRadarChgRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vecChg:", st.VecChg)

	ret = ret + " }"
	return ret
}

// HOrderClassifyReq struct implement
type HOrderClassifyReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo     `json:"stHeader"`
	IOrderType  int32          `json:"iOrderType"`
	EPushFlag   E_HQ_PUSH_REG  `json:"ePushFlag"`
	VOrderTypes []int32        `json:"vOrderTypes"`
	DataType    int32          `json:"dataType"`
	VStocks     []HStockUnique `json:"vStocks"`
}

func (st *HOrderClassifyReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.DataType = 1
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderClassifyReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IOrderType, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VOrderTypes = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.VOrderTypes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.DataType, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStocks = make([]HStockUnique, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VStocks[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderClassifyReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderClassifyReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderClassifyReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IOrderType, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VOrderTypes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VOrderTypes {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.DataType, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStocks)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStocks {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderClassifyReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderClassifyReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iOrderType:", st.IOrderType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vOrderTypes:", st.VOrderTypes)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dataType:", st.DataType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStocks:", st.VStocks)

	ret = ret + " }"
	return ret
}

// OrderClassifyBasic struct implement
type OrderClassifyBasic struct {
	codec.JceStructBase
	Stock      HStockUnique `json:"stock"`
	IOrderType int32        `json:"iOrderType"`
	Count      int32        `json:"count"`
}

func (st *OrderClassifyBasic) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Stock.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *OrderClassifyBasic) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Stock.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IOrderType, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Count, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *OrderClassifyBasic) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderClassifyBasic, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *OrderClassifyBasic) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Stock.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IOrderType, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Count, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *OrderClassifyBasic) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *OrderClassifyBasic) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stock:" + st.Stock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iOrderType:", st.IOrderType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("count:", st.Count)

	ret = ret + " }"
	return ret
}

// HOrderClassifyRsp struct implement
type HOrderClassifyRsp struct {
	codec.JceStructBase
	VOrder []HOrderClassify     `json:"vOrder"`
	VBasic []OrderClassifyBasic `json:"vBasic"`
}

func (st *HOrderClassifyRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderClassifyRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VOrder = make([]HOrderClassify, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VOrder[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBasic = make([]OrderClassifyBasic, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VBasic[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderClassifyRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderClassifyRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderClassifyRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VOrder)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VOrder {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBasic)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBasic {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderClassifyRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderClassifyRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vOrder:", st.VOrder)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBasic:", st.VBasic)

	ret = ret + " }"
	return ret
}

// HSyntReq struct implement
type HSyntReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo         `json:"stHeader"`
	VCategory []E_STOCK_CATEGORY `json:"vCategory"`
	EPushFlag E_HQ_PUSH_REG      `json:"ePushFlag"`
}

func (st *HSyntReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HSyntReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VCategory = make([]E_STOCK_CATEGORY, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32((*int32)(&st.VCategory[i0]), 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSyntReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSyntReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSyntReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VCategory)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VCategory {

		err = _os.Write_int32(int32(v), 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSyntReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSyntReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vCategory:", st.VCategory)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HSyntRsp struct implement
type HSyntRsp struct {
	codec.JceStructBase
	VSynt []HSyntInfo `json:"vSynt"`
}

func (st *HSyntRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSyntRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSynt = make([]HSyntInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VSynt[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSyntRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSyntRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSyntRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSynt)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSynt {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSyntRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSyntRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vSynt:", st.VSynt)

	ret = ret + " }"
	return ret
}

// HPankouRadioReq struct implement
type HPankouRadioReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	SCode    string     `json:"sCode"`
}

func (st *HPankouRadioReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPankouRadioReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPankouRadioReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPankouRadioReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPankouRadioReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPankouRadioReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPankouRadioReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)

	ret = ret + " }"
	return ret
}

// HPankouRadioRsp struct implement
type HPankouRadioRsp struct {
	codec.JceStructBase
	StBuyInfo  HPankouRadio `json:"stBuyInfo"`
	StSellInfo HPankouRadio `json:"stSellInfo"`
}

func (st *HPankouRadioRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StBuyInfo.ResetDefault()
	st.StSellInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPankouRadioRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StBuyInfo.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.StSellInfo.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPankouRadioRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPankouRadioRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPankouRadioRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StBuyInfo.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.StSellInfo.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPankouRadioRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPankouRadioRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stBuyInfo:" + st.StBuyInfo.Display()
	ret = ret + ",  "
	ret = ret + "stSellInfo:" + st.StSellInfo.Display()

	ret = ret + " }"
	return ret
}

// HOrderBookReq struct implement
type HOrderBookReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	SCode     string        `json:"sCode"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HOrderBookReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderBookReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderBookReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderBookReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderBookReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderBookReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderBookReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HOrderBookRsp struct implement
type HOrderBookRsp struct {
	codec.JceStructBase
	VBid      []HOrderBookItem `json:"vBid"`
	VAsk      []HOrderBookItem `json:"vAsk"`
	LTime     int64            `json:"lTime"`
	ShtMarket int16            `json:"shtMarket"`
	SCode     string           `json:"sCode"`
}

func (st *HOrderBookRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderBookRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBid = make([]HOrderBookItem, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VBid[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VAsk = make([]HOrderBookItem, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VAsk[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.LTime, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtMarket, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderBookRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderBookRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderBookRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBid)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBid {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VAsk)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VAsk {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.LTime, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtMarket, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderBookRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderBookRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vBid:", st.VBid)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vAsk:", st.VAsk)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTime:", st.LTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)

	ret = ret + " }"
	return ret
}

// HHkWarrantReq struct implement
type HHkWarrantReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo        `json:"stHeader"`
	SCode     string            `json:"sCode"`
	EType     E_HK_WARRANT_TYPE `json:"eType"`
	EColumn   E_HQ_SORT_COLUMN  `json:"eColumn"`
	ESort     E_SORT_METHOD     `json:"eSort"`
	IStartPos int32             `json:"iStartPos"`
	IWantNum  int32             `json:"iWantNum"`
}

func (st *HHkWarrantReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.IStartPos = 0
	st.IWantNum = -1
}

//ReadFrom reads  from _is and put into struct.
func (st *HHkWarrantReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHkWarrantReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHkWarrantReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHkWarrantReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EColumn), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHkWarrantReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHkWarrantReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)

	ret = ret + " }"
	return ret
}

// HHkWarrantRsp struct implement
type HHkWarrantRsp struct {
	codec.JceStructBase
	VStock    []HWarrantData `json:"vStock"`
	ITotalNum int32          `json:"iTotalNum"`
}

func (st *HHkWarrantRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHkWarrantRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HWarrantData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.ITotalNum, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHkWarrantRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHkWarrantRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHkWarrantRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.ITotalNum, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHkWarrantRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHkWarrantRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalNum:", st.ITotalNum)

	ret = ret + " }"
	return ret
}

// HWarrantHkReq struct implement
type HWarrantHkReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	SCode    string     `json:"sCode"`
}

func (st *HWarrantHkReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HWarrantHkReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HWarrantHkReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HWarrantHkReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HWarrantHkReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HWarrantHkReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HWarrantHkReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)

	ret = ret + " }"
	return ret
}

// HWarrantHkRsp struct implement
type HWarrantHkRsp struct {
	codec.JceStructBase
	StStock HWarrantHkData `json:"stStock"`
}

func (st *HWarrantHkRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StStock.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HWarrantHkRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StStock.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HWarrantHkRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HWarrantHkRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HWarrantHkRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StStock.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HWarrantHkRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HWarrantHkRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stStock:" + st.StStock.Display()

	ret = ret + " }"
	return ret
}

// HServerInfoReq struct implement
type HServerInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HServerInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HServerInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HServerInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HServerInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HServerInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HServerInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HServerInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HServerInfoRsp struct implement
type HServerInfoRsp struct {
	codec.JceStructBase
	IConnNum    int32 `json:"iConnNum"`
	IMaxConnNum int32 `json:"iMaxConnNum"`
}

func (st *HServerInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HServerInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IConnNum, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IMaxConnNum, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HServerInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HServerInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HServerInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IConnNum, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IMaxConnNum, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HServerInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HServerInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iConnNum:", st.IConnNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iMaxConnNum:", st.IMaxConnNum)

	ret = ret + " }"
	return ret
}

// HVolPriceReq struct implement
type HVolPriceReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	SCode     string        `json:"sCode"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HVolPriceReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HVolPriceReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HVolPriceReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HVolPriceReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HVolPriceReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HVolPriceReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HVolPriceReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HPriceVolStats struct implement
type HPriceVolStats struct {
	codec.JceStructBase
	DAvgPrice float64 `json:"dAvgPrice"`
	LTradeNum int64   `json:"lTradeNum"`
	LVolume   int64   `json:"lVolume"`
	LBuyVol   int64   `json:"lBuyVol"`
	LSellVol  int64   `json:"lSellVol"`
}

func (st *HPriceVolStats) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPriceVolStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DAvgPrice, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTradeNum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyVol, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellVol, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPriceVolStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPriceVolStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPriceVolStats) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DAvgPrice, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTradeNum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyVol, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellVol, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPriceVolStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPriceVolStats) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dAvgPrice:", st.DAvgPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTradeNum:", st.LTradeNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyVol:", st.LBuyVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellVol:", st.LSellVol)

	ret = ret + " }"
	return ret
}

// HStatisticTransData struct implement
type HStatisticTransData struct {
	codec.JceStructBase
	TransMax   HPriceVolInfo  `json:"transMax"`
	TransStats HPriceVolStats `json:"transStats"`
}

func (st *HStatisticTransData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.TransMax.ResetDefault()
	st.TransStats.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStatisticTransData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.TransMax.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.TransStats.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStatisticTransData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStatisticTransData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStatisticTransData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.TransMax.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.TransStats.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStatisticTransData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStatisticTransData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "transMax:" + st.TransMax.Display()
	ret = ret + ",  "
	ret = ret + "transStats:" + st.TransStats.Display()

	ret = ret + " }"
	return ret
}

// HVolPriceRsp struct implement
type HVolPriceRsp struct {
	codec.JceStructBase
	MVolPrice      map[float64]uint32        `json:"mVolPrice"`
	StatisticTrans HStatisticTransData       `json:"statisticTrans"`
	MVolNum        map[int32]HTransVolNum    `json:"mVolNum"`
	MPriceInfo     map[float64]HPriceVolInfo `json:"mPriceInfo"`
}

func (st *HVolPriceRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StatisticTrans.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HVolPriceRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MVolPrice = make(map[float64]uint32)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 float64
			var v0 uint32

			err = _is.Read_float64(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_uint32(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MVolPrice[k0] = v0
		}
	}

	err = st.StatisticTrans.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MVolNum = make(map[int32]HTransVolNum)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 HTransVolNum

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err = v1.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MVolNum[k1] = v1
		}
	}

	err, have = _is.SkipTo(codec.MAP, 4, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MPriceInfo = make(map[float64]HPriceVolInfo)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 float64
			var v2 HPriceVolInfo

			err = _is.Read_float64(&k2, 0, false)
			if err != nil {
				return err
			}

			err = v2.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MPriceInfo[k2] = v2
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HVolPriceRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HVolPriceRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HVolPriceRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MVolPrice)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.MVolPrice {

		err = _os.Write_float64(k3, 0)
		if err != nil {
			return err
		}

		err = _os.Write_uint32(v3, 1)
		if err != nil {
			return err
		}

	}

	err = st.StatisticTrans.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MVolNum)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.MVolNum {

		err = _os.Write_int32(k4, 0)
		if err != nil {
			return err
		}

		err = v4.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MPriceInfo)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.MPriceInfo {

		err = _os.Write_float64(k5, 0)
		if err != nil {
			return err
		}

		err = v5.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HVolPriceRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HVolPriceRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mVolPrice:", st.MVolPrice)
	ret = ret + ",  "
	ret = ret + "statisticTrans:" + st.StatisticTrans.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mVolNum:", st.MVolNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mPriceInfo:", st.MPriceInfo)

	ret = ret + " }"
	return ret
}

// HAllOrderPerspReq struct implement
type HAllOrderPerspReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	SCode    string     `json:"sCode"`
}

func (st *HAllOrderPerspReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HAllOrderPerspReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HAllOrderPerspReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HAllOrderPerspReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HAllOrderPerspReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HAllOrderPerspReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HAllOrderPerspReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)

	ret = ret + " }"
	return ret
}

// HAllOrderPerspRsp struct implement
type HAllOrderPerspRsp struct {
	codec.JceStructBase
	MapPrice2Vol map[float32]uint32 `json:"mapPrice2Vol"`
}

func (st *HAllOrderPerspRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HAllOrderPerspRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapPrice2Vol = make(map[float32]uint32)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 float32
			var v0 uint32

			err = _is.Read_float32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_uint32(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MapPrice2Vol[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HAllOrderPerspRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HAllOrderPerspRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HAllOrderPerspRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapPrice2Vol)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapPrice2Vol {

		err = _os.Write_float32(k1, 0)
		if err != nil {
			return err
		}

		err = _os.Write_uint32(v1, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HAllOrderPerspRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HAllOrderPerspRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapPrice2Vol:", st.MapPrice2Vol)

	ret = ret + " }"
	return ret
}

// HProxyHeartReq struct implement
type HProxyHeartReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HProxyHeartReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HProxyHeartReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HProxyHeartReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HProxyHeartReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HProxyHeartReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HProxyHeartReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HProxyHeartReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// MarketMonitorInfo struct implement
type MarketMonitorInfo struct {
	codec.JceStructBase
	LTradeTime int64  `json:"lTradeTime"`
	SCvt       string `json:"sCvt"`
}

func (st *MarketMonitorInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *MarketMonitorInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LTradeTime, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCvt, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MarketMonitorInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MarketMonitorInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MarketMonitorInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LTradeTime, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCvt, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MarketMonitorInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *MarketMonitorInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lTradeTime:", st.LTradeTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCvt:", st.SCvt)

	ret = ret + " }"
	return ret
}

// GetMonitorInfoReq struct implement
type GetMonitorInfoReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo `json:"stHeader"`
	SPassword string     `json:"sPassword"`
}

func (st *GetMonitorInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *GetMonitorInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SPassword, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetMonitorInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetMonitorInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetMonitorInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SPassword, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetMonitorInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *GetMonitorInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sPassword:", st.SPassword)

	ret = ret + " }"
	return ret
}

// GetMonitorInfoRsp struct implement
type GetMonitorInfoRsp struct {
	codec.JceStructBase
	MapMarketInfo map[int16]MarketMonitorInfo `json:"mapMarketInfo"`
	MapOnlines    map[int32]int64             `json:"mapOnlines"`
	CpuUse        float32                     `json:"cpuUse"`
	DiskUse       float32                     `json:"diskUse"`
}

func (st *GetMonitorInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *GetMonitorInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapMarketInfo = make(map[int16]MarketMonitorInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 MarketMonitorInfo

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapMarketInfo[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapOnlines = make(map[int32]int64)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 int64

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int64(&v1, 1, false)
			if err != nil {
				return err
			}

			st.MapOnlines[k1] = v1
		}
	}

	err = _is.Read_float32(&st.CpuUse, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.DiskUse, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetMonitorInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetMonitorInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetMonitorInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapMarketInfo)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.MapMarketInfo {

		err = _os.Write_int16(k2, 0)
		if err != nil {
			return err
		}

		err = v2.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapOnlines)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.MapOnlines {

		err = _os.Write_int32(k3, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int64(v3, 1)
		if err != nil {
			return err
		}

	}

	err = _os.Write_float32(st.CpuUse, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.DiskUse, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetMonitorInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *GetMonitorInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapMarketInfo:", st.MapMarketInfo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapOnlines:", st.MapOnlines)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cpuUse:", st.CpuUse)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("diskUse:", st.DiskUse)

	ret = ret + " }"
	return ret
}

// MarketTradeCaleUnit struct implement
type MarketTradeCaleUnit struct {
	codec.JceStructBase
	ShtMarket int16 `json:"shtMarket"`
	IStart    int32 `json:"iStart"`
	IEnd      int32 `json:"iEnd"`
}

func (st *MarketTradeCaleUnit) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *MarketTradeCaleUnit) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStart, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEnd, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MarketTradeCaleUnit) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MarketTradeCaleUnit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MarketTradeCaleUnit) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStart, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEnd, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MarketTradeCaleUnit) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *MarketTradeCaleUnit) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStart:", st.IStart)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEnd:", st.IEnd)

	ret = ret + " }"
	return ret
}

// GetMarketTradeCaleReq struct implement
type GetMarketTradeCaleReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo            `json:"stHeader"`
	VMarketUnit []MarketTradeCaleUnit `json:"vMarketUnit"`
}

func (st *GetMarketTradeCaleReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *GetMarketTradeCaleReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarketUnit = make([]MarketTradeCaleUnit, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VMarketUnit[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetMarketTradeCaleReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetMarketTradeCaleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetMarketTradeCaleReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarketUnit)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarketUnit {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetMarketTradeCaleReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *GetMarketTradeCaleReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMarketUnit:", st.VMarketUnit)

	ret = ret + " }"
	return ret
}

// GetMarketTradeCaleRsp struct implement
type GetMarketTradeCaleRsp struct {
	codec.JceStructBase
	MapTradeCale map[int16][]TradeCale `json:"mapTradeCale"`
}

func (st *GetMarketTradeCaleRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *GetMarketTradeCaleRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapTradeCale = make(map[int16][]TradeCale)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 []TradeCale

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v0 = make([]TradeCale, length)
					for i1, e1 := int32(0), length; i1 < e1; i1++ {

						err = v0[i1].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.MapTradeCale[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetMarketTradeCaleRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetMarketTradeCaleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetMarketTradeCaleRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapTradeCale)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.MapTradeCale {

		err = _os.Write_int16(k2, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v2)), 0)
		if err != nil {
			return err
		}

		for _, v := range v2 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetMarketTradeCaleRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *GetMarketTradeCaleRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapTradeCale:", st.MapTradeCale)

	ret = ret + " }"
	return ret
}

// HSysMonitorReq struct implement
type HSysMonitorReq struct {
	codec.JceStructBase
	StHeader       HeaderInfo    `json:"stHeader"`
	SPermissionKey string        `json:"sPermissionKey"`
	EPushFlag      E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HSysMonitorReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HSysMonitorReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SPermissionKey, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSysMonitorReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSysMonitorReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSysMonitorReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SPermissionKey, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSysMonitorReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSysMonitorReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sPermissionKey:", st.SPermissionKey)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HSysMonitorRsp struct implement
type HSysMonitorRsp struct {
	codec.JceStructBase
	MapMarketInfo  map[int16]MarketMonitorInfo `json:"mapMarketInfo"`
	MapOnlines     map[int32]int64             `json:"mapOnlines"`
	MonitorInfo    Monitor.SysMonitorInfo      `json:"monitorInfo"`
	UiTotalOnlines uint32                      `json:"uiTotalOnlines"`
	UiMaxOnlines   uint32                      `json:"uiMaxOnlines"`
	BValid         bool                        `json:"bValid"`
}

func (st *HSysMonitorRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.MonitorInfo.ResetDefault()
	st.BValid = true
}

//ReadFrom reads  from _is and put into struct.
func (st *HSysMonitorRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapMarketInfo = make(map[int16]MarketMonitorInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 MarketMonitorInfo

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapMarketInfo[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapOnlines = make(map[int32]int64)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 int64

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int64(&v1, 1, false)
			if err != nil {
				return err
			}

			st.MapOnlines[k1] = v1
		}
	}

	err = st.MonitorInfo.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiTotalOnlines, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiMaxOnlines, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BValid, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSysMonitorRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSysMonitorRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSysMonitorRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapMarketInfo)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.MapMarketInfo {

		err = _os.Write_int16(k2, 0)
		if err != nil {
			return err
		}

		err = v2.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapOnlines)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.MapOnlines {

		err = _os.Write_int32(k3, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int64(v3, 1)
		if err != nil {
			return err
		}

	}

	err = st.MonitorInfo.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiTotalOnlines, 3)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiMaxOnlines, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BValid, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSysMonitorRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSysMonitorRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapMarketInfo:", st.MapMarketInfo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapOnlines:", st.MapOnlines)
	ret = ret + ",  "
	ret = ret + "monitorInfo:" + st.MonitorInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiTotalOnlines:", st.UiTotalOnlines)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiMaxOnlines:", st.UiMaxOnlines)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bValid:", st.BValid)

	ret = ret + " }"
	return ret
}

// HGetGuidReq struct implement
type HGetGuidReq struct {
	codec.JceStructBase
	StHeader       HeaderInfo `json:"stHeader"`
	SPermissionKey string     `json:"sPermissionKey"`
}

func (st *HGetGuidReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGetGuidReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SPermissionKey, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGetGuidReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGetGuidReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGetGuidReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SPermissionKey, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGetGuidReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGetGuidReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sPermissionKey:", st.SPermissionKey)

	ret = ret + " }"
	return ret
}

// HGetGuidRsp struct implement
type HGetGuidRsp struct {
	codec.JceStructBase
	VecGuidSet []string `json:"vecGuidSet"`
}

func (st *HGetGuidRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGetGuidRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecGuidSet = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_string(&st.VecGuidSet[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGetGuidRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGetGuidRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGetGuidRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecGuidSet)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecGuidSet {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGetGuidRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGetGuidRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vecGuidSet:", st.VecGuidSet)

	ret = ret + " }"
	return ret
}

// HGetSNInfoReq struct implement
type HGetSNInfoReq struct {
	codec.JceStructBase
	StHeader       HeaderInfo `json:"stHeader"`
	SPermissionKey string     `json:"sPermissionKey"`
}

func (st *HGetSNInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGetSNInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SPermissionKey, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGetSNInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGetSNInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGetSNInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SPermissionKey, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGetSNInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGetSNInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sPermissionKey:", st.SPermissionKey)

	ret = ret + " }"
	return ret
}

// HGetSNInfoRsp struct implement
type HGetSNInfoRsp struct {
	codec.JceStructBase
	MapSNInfo map[string]int64 `json:"mapSNInfo"`
}

func (st *HGetSNInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGetSNInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapSNInfo = make(map[string]int64)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 int64

			err = _is.Read_string(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int64(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MapSNInfo[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGetSNInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGetSNInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGetSNInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapSNInfo)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapSNInfo {

		err = _os.Write_string(k1, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int64(v1, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGetSNInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGetSNInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapSNInfo:", st.MapSNInfo)

	ret = ret + " }"
	return ret
}

// HGGTQXReq struct implement
type HGGTQXReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	VecDate  []int32    `json:"vecDate"`
}

func (st *HGGTQXReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTQXReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecDate = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.VecDate[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTQXReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTQXReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTQXReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecDate)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecDate {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTQXReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTQXReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecDate:", st.VecDate)

	ret = ret + " }"
	return ret
}

// HGGTQXRsp struct implement
type HGGTQXRsp struct {
	codec.JceStructBase
	MapStock map[int32][]HGGTStockQXInfo `json:"mapStock"`
}

func (st *HGGTQXRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTQXRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapStock = make(map[int32][]HGGTStockQXInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 []HGGTStockQXInfo

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v0 = make([]HGGTStockQXInfo, length)
					for i1, e1 := int32(0), length; i1 < e1; i1++ {

						err = v0[i1].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.MapStock[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTQXRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTQXRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTQXRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapStock)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.MapStock {

		err = _os.Write_int32(k2, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v2)), 0)
		if err != nil {
			return err
		}

		for _, v := range v2 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTQXRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTQXRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapStock:", st.MapStock)

	ret = ret + " }"
	return ret
}

// HGGTRateReq struct implement
type HGGTRateReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	VecDate  []int32    `json:"vecDate"`
}

func (st *HGGTRateReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTRateReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecDate = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.VecDate[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTRateReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTRateReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTRateReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecDate)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecDate {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTRateReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTRateReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecDate:", st.VecDate)

	ret = ret + " }"
	return ret
}

// HGGTRateRsp struct implement
type HGGTRateRsp struct {
	codec.JceStructBase
	MapRate map[int32]HGGTRate `json:"mapRate"`
}

func (st *HGGTRateRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTRateRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapRate = make(map[int32]HGGTRate)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 HGGTRate

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapRate[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTRateRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTRateRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTRateRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapRate)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapRate {

		err = _os.Write_int32(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTRateRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTRateRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapRate:", st.MapRate)

	ret = ret + " }"
	return ret
}

// HYYDataReq struct implement
type HYYDataReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo     `json:"stHeader"`
	ShtMarket int16          `json:"shtMarket"`
	VStock    []HStockUnique `json:"vStock"`
}

func (st *HYYDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HYYDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HYYDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HYYDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HYYDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HYYDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HYYDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HYYDataRsp struct implement
type HYYDataRsp struct {
	codec.JceStructBase
	ITotal int32     `json:"iTotal"`
	VData  []HYYInfo `json:"vData"`
}

func (st *HYYDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ITotal = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HYYDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ITotal, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HYYInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HYYDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HYYDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HYYDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ITotal, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HYYDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HYYDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iTotal:", st.ITotal)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// HFXDataReq struct implement
type HFXDataReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo     `json:"stHeader"`
	ShtMarket int16          `json:"shtMarket"`
	VStock    []HStockUnique `json:"vStock"`
}

func (st *HFXDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFXDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFXDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFXDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFXDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFXDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFXDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HFXDataRsp struct implement
type HFXDataRsp struct {
	codec.JceStructBase
	ITotal int32     `json:"iTotal"`
	VData  []HFXInfo `json:"vData"`
}

func (st *HFXDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ITotal = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HFXDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ITotal, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HFXInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFXDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFXDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFXDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ITotal, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFXDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFXDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iTotal:", st.ITotal)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// GetSouthMoneyFlowReq struct implement
type GetSouthMoneyFlowReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *GetSouthMoneyFlowReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *GetSouthMoneyFlowReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetSouthMoneyFlowReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetSouthMoneyFlowReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetSouthMoneyFlowReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetSouthMoneyFlowReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *GetSouthMoneyFlowReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HSouthMoneyFlow struct implement
type HSouthMoneyFlow struct {
	codec.JceStructBase
	IDate     uint32  `json:"iDate"`
	ITime     uint32  `json:"iTime"`
	DTotalAmt float64 `json:"dTotalAmt"`
	DBalance  float64 `json:"dBalance"`
}

func (st *HSouthMoneyFlow) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IDate = 0
	st.ITime = 0
	st.DTotalAmt = 0
	st.DBalance = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HSouthMoneyFlow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint32(&st.IDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.ITime, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTotalAmt, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBalance, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSouthMoneyFlow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSouthMoneyFlow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSouthMoneyFlow) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint32(st.IDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.ITime, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTotalAmt, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBalance, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSouthMoneyFlow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSouthMoneyFlow) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTotalAmt:", st.DTotalAmt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBalance:", st.DBalance)

	ret = ret + " }"
	return ret
}

// GetSouthMoneyFlowRsp struct implement
type GetSouthMoneyFlowRsp struct {
	codec.JceStructBase
	MapSouthMoneyFlow map[int16]HSouthMoneyFlow `json:"mapSouthMoneyFlow"`
}

func (st *GetSouthMoneyFlowRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *GetSouthMoneyFlowRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapSouthMoneyFlow = make(map[int16]HSouthMoneyFlow)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 HSouthMoneyFlow

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapSouthMoneyFlow[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GetSouthMoneyFlowRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetSouthMoneyFlowRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GetSouthMoneyFlowRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapSouthMoneyFlow)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapSouthMoneyFlow {

		err = _os.Write_int16(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GetSouthMoneyFlowRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *GetSouthMoneyFlowRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapSouthMoneyFlow:", st.MapSouthMoneyFlow)

	ret = ret + " }"
	return ret
}

// HFutureNameListReq struct implement
type HFutureNameListReq struct {
	codec.JceStructBase
	VMarket []int16 `json:"vMarket"`
}

func (st *HFutureNameListReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFutureNameListReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarket = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VMarket[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFutureNameListReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFutureNameListReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFutureNameListReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarket)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarket {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFutureNameListReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFutureNameListReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vMarket:", st.VMarket)

	ret = ret + " }"
	return ret
}

// HFutureNameListRsp struct implement
type HFutureNameListRsp struct {
	codec.JceStructBase
	MListName map[int16]map[int16]string `json:"mListName"`
}

func (st *HFutureNameListRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFutureNameListRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MListName = make(map[int16]map[int16]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 map[int16]string

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err, have = _is.SkipTo(codec.MAP, 1, false)
			if err != nil {
				return err
			}

			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return err
				}

				v0 = make(map[int16]string)
				for i1, e1 := int32(0), length; i1 < e1; i1++ {
					var k1 int16
					var v1 string

					err = _is.Read_int16(&k1, 0, false)
					if err != nil {
						return err
					}

					err = _is.Read_string(&v1, 1, false)
					if err != nil {
						return err
					}

					v0[k1] = v1
				}
			}

			st.MListName[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFutureNameListRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFutureNameListRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFutureNameListRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MListName)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.MListName {

		err = _os.Write_int16(k2, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v2)), 0)
		if err != nil {
			return err
		}

		for k3, v3 := range v2 {

			err = _os.Write_int16(k3, 0)
			if err != nil {
				return err
			}

			err = _os.Write_string(v3, 1)
			if err != nil {
				return err
			}

		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFutureNameListRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFutureNameListRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mListName:", st.MListName)

	ret = ret + " }"
	return ret
}

// HStockAuctionRsp struct implement
type HStockAuctionRsp struct {
	codec.JceStructBase
	VStockHq []HStockAuction `json:"vStockHq"`
}

func (st *HStockAuctionRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAuctionRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockHq = make([]HStockAuction, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockHq[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAuctionRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAuctionRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAuctionRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockHq)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockHq {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAuctionRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAuctionRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStockHq:", st.VStockHq)

	ret = ret + " }"
	return ret
}

// HRtminAuctionReq struct implement
type HRtminAuctionReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	SCode     string        `json:"sCode"`
	IStartPos int32         `json:"iStartPos"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HRtminAuctionReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IStartPos = 0
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HRtminAuctionReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRtminAuctionReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRtminAuctionReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRtminAuctionReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRtminAuctionReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRtminAuctionReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HRtminAuctionRsp struct implement
type HRtminAuctionRsp struct {
	codec.JceStructBase
	VRTMinAuc  []HRTMinDataAuc `json:"vRTMinAuc"`
	IDate      int32           `json:"iDate"`
	SCode      string          `json:"sCode"`
	ShtSetcode int16           `json:"shtSetcode"`
}

func (st *HRtminAuctionRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRtminAuctionRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRTMinAuc = make([]HRTMinDataAuc, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRTMinAuc[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRtminAuctionRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRtminAuctionRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRtminAuctionRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRTMinAuc)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRTMinAuc {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRtminAuctionRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRtminAuctionRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vRTMinAuc:", st.VRTMinAuc)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)

	ret = ret + " }"
	return ret
}

// HSNFundDataReq struct implement
type HSNFundDataReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
}

func (st *HSNFundDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HSNFundDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSNFundDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSNFundDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSNFundDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSNFundDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSNFundDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)

	ret = ret + " }"
	return ret
}

// HSNFundDataRsp struct implement
type HSNFundDataRsp struct {
	codec.JceStructBase
	VSNFundData []HSNFundsData `json:"vSNFundData"`
	IDate       int32          `json:"iDate"`
}

func (st *HSNFundDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSNFundDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSNFundData = make([]HSNFundsData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VSNFundData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IDate, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSNFundDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSNFundDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSNFundDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSNFundData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSNFundData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IDate, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSNFundDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSNFundDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vSNFundData:", st.VSNFundData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)

	ret = ret + " }"
	return ret
}

// HSNNetDataReq struct implement
type HSNNetDataReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
	BNetBuy   bool          `json:"bNetBuy"`
	IStartPos int32         `json:"iStartPos"`
}

func (st *HSNNetDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
	st.IStartPos = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HSNNetDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BNetBuy, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSNNetDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSNNetDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSNNetDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BNetBuy, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSNNetDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSNNetDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bNetBuy:", st.BNetBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)

	ret = ret + " }"
	return ret
}

// HSNNetDataRsp struct implement
type HSNNetDataRsp struct {
	codec.JceStructBase
	VNetData []HSNNetData `json:"vNetData"`
}

func (st *HSNNetDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSNNetDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VNetData = make([]HSNNetData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VNetData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSNNetDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSNNetDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSNNetDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VNetData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VNetData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSNNetDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSNNetDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vNetData:", st.VNetData)

	ret = ret + " }"
	return ret
}

// HHisSNNetDataReq struct implement
type HHisSNNetDataReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo        `json:"stHeader"`
	BNetBuy    bool              `json:"bNetBuy"`
	ShtWantNum int16             `json:"shtWantNum"`
	ELineType  HISTORY_DATA_TYPE `json:"eLineType"`
}

func (st *HHisSNNetDataReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.ELineType = HISTORY_DATA_TYPE_HDT_DAY_KLINE
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisSNNetDataReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BNetBuy, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtWantNum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ELineType), 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisSNNetDataReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisSNNetDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisSNNetDataReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BNetBuy, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtWantNum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ELineType), 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisSNNetDataReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisSNNetDataReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bNetBuy:", st.BNetBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWantNum:", st.ShtWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eLineType:", st.ELineType)

	ret = ret + " }"
	return ret
}

// HHisSNNetDataRsp struct implement
type HHisSNNetDataRsp struct {
	codec.JceStructBase
	VHisNetData []HSNNetData `json:"vHisNetData"`
}

func (st *HHisSNNetDataRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHisSNNetDataRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VHisNetData = make([]HSNNetData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VHisNetData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHisSNNetDataRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHisSNNetDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHisSNNetDataRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VHisNetData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VHisNetData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHisSNNetDataRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHisSNNetDataRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vHisNetData:", st.VHisNetData)

	ret = ret + " }"
	return ret
}

// HJPJLReq struct implement
type HJPJLReq struct {
	codec.JceStructBase
	StHeader   HeaderInfo        `json:"stHeader"`
	SInput     string            `json:"sInput"`
	IMaxNum    int32             `json:"iMaxNum"`
	VecMktType []HMarketTypeFilt `json:"vecMktType"`
	VecType    []HTypeFilt       `json:"vecType"`
}

func (st *HJPJLReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IMaxNum = 5
}

//ReadFrom reads  from _is and put into struct.
func (st *HJPJLReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SInput, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IMaxNum, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecMktType = make([]HMarketTypeFilt, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VecMktType[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecType = make([]HTypeFilt, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VecType[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HJPJLReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HJPJLReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HJPJLReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SInput, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IMaxNum, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecMktType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecMktType {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecType {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HJPJLReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HJPJLReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sInput:", st.SInput)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iMaxNum:", st.IMaxNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecMktType:", st.VecMktType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecType:", st.VecType)

	ret = ret + " }"
	return ret
}

// HJPJLRsp struct implement
type HJPJLRsp struct {
	codec.JceStructBase
	VStock []HJPJLStock `json:"vStock"`
}

func (st *HJPJLRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HJPJLRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HJPJLStock, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HJPJLRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HJPJLRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HJPJLRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HJPJLRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HJPJLRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HStockRankReq struct implement
type HStockRankReq struct {
	codec.JceStructBase
	StHeader    HeaderInfo           `json:"stHeader"`
	IRankType   int32                `json:"iRankType"`
	EBussType   E_BUSS_TYPE          `json:"eBussType"`
	VType       []HTypeSubType       `json:"vType"`
	VBlockCode  []string             `json:"vBlockCode"`
	VCategory   []E_STOCK_CATEGORY   `json:"vCategory"`
	VStock      []HStockUnique       `json:"vStock"`
	EColumn     E_HQ_SORT_COLUMN     `json:"eColumn"`
	ESort       E_SORT_METHOD        `json:"eSort"`
	IStartPos   int32                `json:"iStartPos"`
	IWantNum    int32                `json:"iWantNum"`
	VFilterType []E_RANK_FILTER_TYPE `json:"vFilterType"`
}

func (st *HStockRankReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.IRankType = 0
	st.ESort = E_SORT_METHOD_E_SORT_DEFAULT
	st.IStartPos = 0
	st.IWantNum = -1
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockRankReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IRankType, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EBussType), 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VType = make([]HTypeSubType, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VType[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBlockCode = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_string(&st.VBlockCode[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VCategory = make([]E_STOCK_CATEGORY, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_int32((*int32)(&st.VCategory[i2]), 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.VStock[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32((*int32)(&st.EColumn), 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ESort), 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartPos, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWantNum, 10, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(11, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VFilterType = make([]E_RANK_FILTER_TYPE, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = _is.Read_int32((*int32)(&st.VFilterType[i4]), 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockRankReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockRankReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockRankReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IRankType, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EBussType), 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VType {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBlockCode)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBlockCode {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VCategory)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VCategory {

		err = _os.Write_int32(int32(v), 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(int32(st.EColumn), 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ESort), 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartPos, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWantNum, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VFilterType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VFilterType {

		err = _os.Write_int32(int32(v), 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockRankReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockRankReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iRankType:", st.IRankType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eBussType:", st.EBussType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vType:", st.VType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBlockCode:", st.VBlockCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vCategory:", st.VCategory)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eColumn:", st.EColumn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eSort:", st.ESort)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartPos:", st.IStartPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWantNum:", st.IWantNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vFilterType:", st.VFilterType)

	ret = ret + " }"
	return ret
}

// HStockRankRsp struct implement
type HStockRankRsp struct {
	codec.JceStructBase
	VData      []HStockUnique `json:"vData"`
	ITotalSize int32          `json:"iTotalSize"`
}

func (st *HStockRankRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ITotalSize = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockRankRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HStockUnique, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.ITotalSize, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockRankRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockRankRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockRankRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.ITotalSize, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockRankRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockRankRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vData:", st.VData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalSize:", st.ITotalSize)

	ret = ret + " }"
	return ret
}

// HXrdFactorReq struct implement
type HXrdFactorReq struct {
	codec.JceStructBase
	StHeader HeaderInfo     `json:"stHeader"`
	VMarket  []int16        `json:"vMarket"`
	VStock   []HStockUnique `json:"vStock"`
}

func (st *HXrdFactorReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HXrdFactorReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarket = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VMarket[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockUnique, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VStock[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HXrdFactorReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HXrdFactorReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HXrdFactorReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarket)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarket {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HXrdFactorReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HXrdFactorReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMarket:", st.VMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HXrdFactorRsp struct implement
type HXrdFactorRsp struct {
	codec.JceStructBase
	VData []HStockXrdFactor `json:"vData"`
}

func (st *HXrdFactorRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HXrdFactorRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HStockXrdFactor, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HXrdFactorRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HXrdFactorRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HXrdFactorRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HXrdFactorRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HXrdFactorRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// HMarketCloseInfoReq struct implement
type HMarketCloseInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
	VMarket  []int16    `json:"vMarket"`
}

func (st *HMarketCloseInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketCloseInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VMarket = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VMarket[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketCloseInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketCloseInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketCloseInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VMarket)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VMarket {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketCloseInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketCloseInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vMarket:", st.VMarket)

	ret = ret + " }"
	return ret
}

// HMarketCloseInfoRsp struct implement
type HMarketCloseInfoRsp struct {
	codec.JceStructBase
	IDate            uint32           `json:"iDate"`
	MMarketCloseTips map[int16]string `json:"mMarketCloseTips"`
}

func (st *HMarketCloseInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketCloseInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint32(&st.IDate, 0, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MMarketCloseTips = make(map[int16]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 string

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MMarketCloseTips[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketCloseInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketCloseInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketCloseInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint32(st.IDate, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MMarketCloseTips)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MMarketCloseTips {

		err = _os.Write_int16(k1, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v1, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketCloseInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketCloseInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mMarketCloseTips:", st.MMarketCloseTips)

	ret = ret + " }"
	return ret
}

// HZDFenbuReq struct implement
type HZDFenbuReq struct {
	codec.JceStructBase
	StHeader  HeaderInfo    `json:"stHeader"`
	EPushFlag E_HQ_PUSH_REG `json:"ePushFlag"`
	VecType   []int16       `json:"vecType"`
	ShtWitdh  int16         `json:"shtWitdh"`
}

func (st *HZDFenbuReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
	st.EPushFlag = E_HQ_PUSH_REG_E_HQ_PUSH_NONE
}

//ReadFrom reads  from _is and put into struct.
func (st *HZDFenbuReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EPushFlag), 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecType = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VecType[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int16(&st.ShtWitdh, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HZDFenbuReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HZDFenbuReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HZDFenbuReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EPushFlag), 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecType {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int16(st.ShtWitdh, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HZDFenbuReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HZDFenbuReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ePushFlag:", st.EPushFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecType:", st.VecType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtWitdh:", st.ShtWitdh)

	ret = ret + " }"
	return ret
}

// HZDFenbuRsp struct implement
type HZDFenbuRsp struct {
	codec.JceStructBase
	MapData map[int32]HZDFenBuInfo `json:"mapData"`
}

func (st *HZDFenbuRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HZDFenbuRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapData = make(map[int32]HZDFenBuInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 HZDFenBuInfo

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapData[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HZDFenbuRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HZDFenbuRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HZDFenbuRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapData)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapData {

		err = _os.Write_int32(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HZDFenbuRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HZDFenbuRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapData:", st.MapData)

	ret = ret + " }"
	return ret
}

// HTradeStatusNameReq struct implement
type HTradeStatusNameReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HTradeStatusNameReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTradeStatusNameReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTradeStatusNameReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTradeStatusNameReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTradeStatusNameReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTradeStatusNameReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTradeStatusNameReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HTradeStatusNameRsp struct implement
type HTradeStatusNameRsp struct {
	codec.JceStructBase
	MapAData map[int32]string `json:"mapAData"`
	MapMData map[int32]string `json:"mapMData"`
}

func (st *HTradeStatusNameRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTradeStatusNameRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapAData = make(map[int32]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 string

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MapAData[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapMData = make(map[int32]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 string

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v1, 1, false)
			if err != nil {
				return err
			}

			st.MapMData[k1] = v1
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTradeStatusNameRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTradeStatusNameRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTradeStatusNameRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapAData)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.MapAData {

		err = _os.Write_int32(k2, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v2, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapMData)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.MapMData {

		err = _os.Write_int32(k3, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v3, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTradeStatusNameRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTradeStatusNameRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapAData:", st.MapAData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapMData:", st.MapMData)

	ret = ret + " }"
	return ret
}

// HCurrencyInfoReq struct implement
type HCurrencyInfoReq struct {
	codec.JceStructBase
	StHeader HeaderInfo `json:"stHeader"`
}

func (st *HCurrencyInfoReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StHeader.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCurrencyInfoReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StHeader.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCurrencyInfoReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCurrencyInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCurrencyInfoReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StHeader.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCurrencyInfoReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCurrencyInfoReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stHeader:" + st.StHeader.Display()

	ret = ret + " }"
	return ret
}

// HCurrencyInfoRsp struct implement
type HCurrencyInfoRsp struct {
	codec.JceStructBase
	VInfo []HCurrencyInfo `json:"vInfo"`
}

func (st *HCurrencyInfoRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCurrencyInfoRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HCurrencyInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCurrencyInfoRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCurrencyInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCurrencyInfoRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCurrencyInfoRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCurrencyInfoRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)

	ret = ret + " }"
	return ret
}
