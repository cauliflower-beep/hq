// Package HQSys comment
// This file was generated by jce2go 2.0.0
// Generated from BasicData.jce
package HQSys

import (
	"fmt"

	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/codec"
	"hq/pkg/jce/RadarData"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type E_SIMPLE_MF_TYPE int32

const (
	E_SIMPLE_MF_TYPE_E_MF_TODAY = 0
	E_SIMPLE_MF_TYPE_E_MF_3DAY  = 1
	E_SIMPLE_MF_TYPE_E_MF_5DAY  = 2
	E_SIMPLE_MF_TYPE_E_MF_10DAY = 3
	E_SIMPLE_MF_TYPE_E_MF_3MIN  = 4
	E_SIMPLE_MF_TYPE_E_MF_5MIN  = 5
	E_SIMPLE_MF_TYPE_E_MF_10MIN = 6
	E_SIMPLE_MF_TYPE_E_MF_30MIN = 7
	E_SIMPLE_MF_TYPE_E_MF_60MIN = 8
)

type E_FINANCING_TARGET int32

const (
	E_FINANCING_TARGET_E_FT_NULL      = 0
	E_FINANCING_TARGET_E_FT_FINANCING = 1
)

type E_STOCK_FLAG_TYPE int32

const (
	E_STOCK_FLAG_TYPE_E_FLAG_TYPE_UNKNOWN = 0
	E_STOCK_FLAG_TYPE_E_FLAG_TYPE_ZTG     = 1
)

type E_STOCK_TRADE_STATUS int32

const (
	E_STOCK_TRADE_STATUS_E_STATUS_UNKOWN                 = 0
	E_STOCK_TRADE_STATUS_E_STATUS_CLOSED                 = 1
	E_STOCK_TRADE_STATUS_E_STATUS_NOT_OPEN               = 2
	E_STOCK_TRADE_STATUS_E_STATUS_AUTION                 = 3
	E_STOCK_TRADE_STATUS_E_STATUS_UPCOMING               = 4
	E_STOCK_TRADE_STATUS_E_STATUS_TRADE                  = 5
	E_STOCK_TRADE_STATUS_E_STATUS_AM_TRADE               = 6
	E_STOCK_TRADE_STATUS_E_STATUS_NOONTIME               = 7
	E_STOCK_TRADE_STATUS_E_STATUS_PM_TRADE               = 8
	E_STOCK_TRADE_STATUS_E_STATUS_STOPPED                = 9
	E_STOCK_TRADE_STATUS_E_STATUS_TEMP_STOPPED           = 10
	E_STOCK_TRADE_STATUS_E_STATUS_AFTER_TRADE            = 11
	E_STOCK_TRADE_STATUS_E_STATUS_VOLATILITY_STOPPED     = 12
	E_STOCK_TRADE_STATUS_E_STATUS_RECOVERABLE_FUSING     = 13
	E_STOCK_TRADE_STATUS_E_STATUS_NON_RECOVERABLE_FUSING = 14
	E_STOCK_TRADE_STATUS_E_STATUS_PM_AUCTION             = 20
	E_STOCK_TRADE_STATUS_E_STATUS_ATP_TRADE              = 23
	E_STOCK_TRADE_STATUS_E_STATUS_JJSS                   = 24
	E_STOCK_TRADE_STATUS_E_STATUS_TS                     = 25
	E_STOCK_TRADE_STATUS_E_STATUS_SUSPEND                = 26
	E_STOCK_TRADE_STATUS_E_STATUS_HK_PRE_TRADE_ORDER     = 31
	E_STOCK_TRADE_STATUS_E_STATUS_HK_NO_CANCAL           = 32
	E_STOCK_TRADE_STATUS_E_STATUS_HK_RANDOM_MATCHING     = 33
	E_STOCK_TRADE_STATUS_E_STATUS_HK_AM_AUCTION          = 34
	E_STOCK_TRADE_STATUS_E_STATUS_HK_BLOCKING            = 35
	E_STOCK_TRADE_STATUS_E_STATUS_HK_INTERVERTION        = 36
	E_STOCK_TRADE_STATUS_E_STATUS_HK_REST                = 37
	E_STOCK_TRADE_STATUS_E_STATUS_HK_CANCAL              = 38
	E_STOCK_TRADE_STATUS_E_STATUS_HK_CAS_FIXING          = 39
	E_STOCK_TRADE_STATUS_E_STATUS_HK_CAS_OI              = 40
	E_STOCK_TRADE_STATUS_E_STATUS_HK_CAS_NO_CANCAL       = 41
	E_STOCK_TRADE_STATUS_E_STATUS_HK_CAS_RANDOM_CLOSE    = 42
	E_STOCK_TRADE_STATUS_E_STATUS_HK_PM_AUCTION          = 43
)

type E_MARKET_TRADE_STATUS int32

const (
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_UNKOWN     = 0
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_CLOSED     = 1
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_NOT_OPEN   = 2
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_AUCTION    = 3
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_UPCOMING   = 4
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_TRADE      = 5
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_AM_TRADE   = 6
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_NOONTIME   = 7
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_PM_TRADE   = 8
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_PM_AUCTION = 20
	E_MARKET_TRADE_STATUS_E_MARKET_STATUS_ATP_TRADE  = 23
)

type E_STOCK_HQ_DATA int32

const (
	E_STOCK_HQ_DATA_E_SHD_NONE     = 0
	E_STOCK_HQ_DATA_E_SHD_SIMPLE   = 1
	E_STOCK_HQ_DATA_E_SHD_ORDER    = 2
	E_STOCK_HQ_DATA_E_SHD_BLOCK    = 4
	E_STOCK_HQ_DATA_E_SHD_DERIVE   = 8
	E_STOCK_HQ_DATA_E_SHD_1DAY_ZJ  = 32
	E_STOCK_HQ_DATA_E_SHD_3DAY_ZJ  = 64
	E_STOCK_HQ_DATA_E_SHD_5DAY_ZJ  = 128
	E_STOCK_HQ_DATA_E_SHD_10DAY_ZJ = 256
	E_STOCK_HQ_DATA_E_SHD_DDE      = 512
	E_STOCK_HQ_DATA_E_SHD_CW       = 1024
	E_STOCK_HQ_DATA_E_SHD_3MIN_ZJ  = 2048
	E_STOCK_HQ_DATA_E_SHD_5MIN_ZJ  = 4096
	E_STOCK_HQ_DATA_E_SHD_10MIN_ZJ = 8192
	E_STOCK_HQ_DATA_E_SHD_30MIN_ZJ = 16384
	E_STOCK_HQ_DATA_E_SHD_60MIN_ZJ = 32768
	E_STOCK_HQ_DATA_E_SHD_DAY_MF   = 65536
	E_STOCK_HQ_DATA_E_SHD_OPTION   = 131072
	E_STOCK_HQ_DATA_E_SHD_AUCTION  = 262144
)

type E_STOCK_DATA_ENV int32

const (
	E_STOCK_DATA_ENV_E_SHDE_NORMAL        = 0
	E_STOCK_DATA_ENV_E_SHDE_PRICE         = 1
	E_STOCK_DATA_ENV_E_SHDE_LIST_QT       = 2
	E_STOCK_DATA_ENV_E_SHDE_LIST_1DAYZJ   = 3
	E_STOCK_DATA_ENV_E_SHDE_LIST_3DAYZJ   = 4
	E_STOCK_DATA_ENV_E_SHDE_LIST_5DAYZJ   = 5
	E_STOCK_DATA_ENV_E_SHDE_LIST_10DAYZJ  = 6
	E_STOCK_DATA_ENV_E_SHDE_SIMPLE_STATUS = 7
	E_STOCK_DATA_ENV_E_SHDE_LIST_3MINZJ   = 8
	E_STOCK_DATA_ENV_E_SHDE_LIST_5MINZJ   = 9
	E_STOCK_DATA_ENV_E_SHDE_LIST_10MINZJ  = 10
	E_STOCK_DATA_ENV_E_SHDE_LIST_30MINZJ  = 11
	E_STOCK_DATA_ENV_E_SHDE_LIST_60MINZJ  = 12
	E_STOCK_DATA_ENV_E_SHDE_LIST_QT_MF    = 13
	E_STOCK_DATA_ENV_E_SHDE_LIST_NEWQT    = 14
	E_STOCK_DATA_ENV_E_SHDE_LIST_ZXG      = 15
	E_STOCK_DATA_ENV_E_SHDE_LIST_CDDP     = 16
	E_STOCK_DATA_ENV_E_SHDE_LIST_CDFP     = 17
	E_STOCK_DATA_ENV_E_SHDE_LIST_JDCX     = 18
	E_STOCK_DATA_ENV_E_SHDE_LIST_FUND     = 19
	E_STOCK_DATA_ENV_E_SHDE_LIST_BOND     = 20
	E_STOCK_DATA_ENV_E_SHDE_LIST_HK       = 21
	E_STOCK_DATA_ENV_E_SHDE_LIST_US       = 22
	E_STOCK_DATA_ENV_E_SHDE_LIST_FX       = 23
	E_STOCK_DATA_ENV_E_SHDE_LIST_GPC      = 24
)

type E_HSTOCKHQ_BITMAP int32

const (
	E_HSTOCKHQ_BITMAP_EBIT_SIM_OPEN                = 0
	E_HSTOCKHQ_BITMAP_EBIT_SIM_HIGH                = 1
	E_HSTOCKHQ_BITMAP_EBIT_SIM_LOW                 = 2
	E_HSTOCKHQ_BITMAP_EBIT_SIM_CLOSE               = 3
	E_HSTOCKHQ_BITMAP_EBIT_SIM_VOLUME              = 4
	E_HSTOCKHQ_BITMAP_EBIT_SIM_AMOUNT              = 5
	E_HSTOCKHQ_BITMAP_EBIT_SIM_CHGVALUE            = 6
	E_HSTOCKHQ_BITMAP_EBIT_SIM_CHGRATIO            = 7
	E_HSTOCKHQ_BITMAP_EBIT_SIM_ZHENFU              = 8
	E_HSTOCKHQ_BITMAP_EBIT_SIM_ZT                  = 9
	E_HSTOCKHQ_BITMAP_EBIT_SIM_LEADBLOCK           = 10
	E_HSTOCKHQ_BITMAP_EBIT_SIM_OPENAMONNT          = 11
	E_HSTOCKHQ_BITMAP_EBIT_SIM_OPENVOLUME          = 12
	E_HSTOCKHQ_BITMAP_EBIT_SIM_LEAD_CODE           = 14
	E_HSTOCKHQ_BITMAP_EBIT_SIM_LEAD_NAME           = 15
	E_HSTOCKHQ_BITMAP_EBIT_EX_NOWVOL               = 16
	E_HSTOCKHQ_BITMAP_EBIT_EX_INSIDE               = 17
	E_HSTOCKHQ_BITMAP_EBIT_EX_OUTSIDE              = 18
	E_HSTOCKHQ_BITMAP_EBIT_EX_VBSELL               = 19
	E_HSTOCKHQ_BITMAP_EBIT_EX_AVGPRICE             = 20
	E_HSTOCKHQ_BITMAP_EBIT_EX_ZTPRICE              = 21
	E_HSTOCKHQ_BITMAP_EBIT_EX_DTPRICE              = 22
	E_HSTOCKHQ_BITMAP_EBIT_EX_TURNOVERRATE         = 23
	E_HSTOCKHQ_BITMAP_EBIT_EX_TRADEMIN             = 24
	E_HSTOCKHQ_BITMAP_EBIT_EX_TRADEDATE            = 25
	E_HSTOCKHQ_BITMAP_EBIT_EX_TRADETIME            = 26
	E_HSTOCKHQ_BITMAP_EBIT_EX_ZDMARK               = 27
	E_HSTOCKHQ_BITMAP_EBIT_EX_TRADESTATUS          = 28
	E_HSTOCKHQ_BITMAP_EBIT_EX_VBSNUM               = 29
	E_HSTOCKHQ_BITMAP_EBIT_EX_BSFLAG               = 30
	E_HSTOCKHQ_BITMAP_EBIT_EX_PERATIO              = 31
	E_HSTOCKHQ_BITMAP_EBIT_EX_PRICERATIO           = 32
	E_HSTOCKHQ_BITMAP_EBIT_EX_ZSZ                  = 33
	E_HSTOCKHQ_BITMAP_EBIT_EX_LTSZ                 = 34
	E_HSTOCKHQ_BITMAP_EBIT_QH_SETTLEMENTPRICE      = 35
	E_HSTOCKHQ_BITMAP_EBIT_QH_PRESETTLEMENTPRICE   = 36
	E_HSTOCKHQ_BITMAP_EBIT_QH_OPENINTEREST         = 37
	E_HSTOCKHQ_BITMAP_EBIT_QH_PREOPENINTEREST      = 38
	E_HSTOCKHQ_BITMAP_EBIT_QH_EVERYHAND            = 39
	E_HSTOCKHQ_BITMAP_EBIT_QH_DAYINCREASE          = 40
	E_HSTOCKHQ_BITMAP_EBIT_MF_BASE                 = 41
	E_HSTOCKHQ_BITMAP_EBIT_DDE_DDX                 = 42
	E_HSTOCKHQ_BITMAP_EBIT_DDE_DDY                 = 43
	E_HSTOCKHQ_BITMAP_EBIT_DDE_DDZ                 = 44
	E_HSTOCKHQ_BITMAP_EBIT_DDE_DDF                 = 45
	E_HSTOCKHQ_BITMAP_EBIT_DDE_DDX5                = 46
	E_HSTOCKHQ_BITMAP_EBIT_DDE_DDY5                = 47
	E_HSTOCKHQ_BITMAP_EBIT_DDE_DDX60               = 48
	E_HSTOCKHQ_BITMAP_EBIT_DDE_DDY60               = 49
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_HEADMARKET   = 50
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_HEADCODE     = 51
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_HEADNAME     = 52
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_HEADNOW      = 53
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_HEADCLOSE    = 54
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_STOCKNUM     = 55
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_EQUALNUM     = 56
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_ZTNUM        = 57
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_UPNUM        = 58
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_DOWNNUM      = 59
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_ZSZ          = 60
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_LTSZ         = 61
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_UPNDAY       = 62
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_3DAYCHG      = 63
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_5DAYCHG      = 64
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_10DAYCHG     = 65
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_LIANGBI          = 66
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_UPSPEED          = 67
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_TRADENUM         = 68
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_BSVOL            = 69
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_STATUS           = 70
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_5MINMAININFLOW   = 71
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_TICKNUM          = 72
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_ATPVOL           = 73
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_ATPAMOUNT        = 74
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_AVGBP            = 75
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_BP               = 76
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_IOPV             = 77
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_10DAYHBL         = 78
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_52WEEKSTAT       = 79
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_HISTORYSTAT      = 80
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_3DAYNETINFLOW    = 81
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_5DAYNETINFLOW    = 82
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_10DAYNETINFLOW   = 83
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_20DAYNETINFLOW   = 84
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_MATCHPRICE       = 85
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_5DAYCHG          = 86
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_10DAYCHG         = 87
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_20DAYCHG         = 88
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_MONTHCHG         = 89
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_SEASONCHG        = 90
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_YEARCHG          = 91
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_THISYEARCHG      = 92
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_REFPRICE         = 93
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_LYBRANK          = 94
	E_HSTOCKHQ_BITMAP_EBIT_CW_MGSY                 = 97
	E_HSTOCKHQ_BITMAP_EBIT_CW_MGJZC                = 98
	E_HSTOCKHQ_BITMAP_EBIT_CW_JZCSYL               = 99
	E_HSTOCKHQ_BITMAP_EBIT_CW_YSZZL3Y              = 100
	E_HSTOCKHQ_BITMAP_EBIT_CW_JLSZZL3Y             = 101
	E_HSTOCKHQ_BITMAP_EBIT_ZQ_BASE                 = 102
	E_HSTOCKHQ_BITMAP_EBIT_3MINMF_BASE             = 103
	E_HSTOCKHQ_BITMAP_EBIT_5MINMF_BASE             = 104
	E_HSTOCKHQ_BITMAP_EBIT_10MINMF_BASE            = 105
	E_HSTOCKHQ_BITMAP_EBIT_30MINMF_BASE            = 106
	E_HSTOCKHQ_BITMAP_EBIT_60MINMF_BASE            = 107
	E_HSTOCKHQ_BITMAP_EBIT_TB_BASE                 = 108
	E_HSTOCKHQ_BITMAP_EBIT_DAYMF_AMT_BASE          = 109
	E_HSTOCKHQ_BITMAP_EBIT_DAYMF_VOL_BASE          = 110
	E_HSTOCKHQ_BITMAP_EBIT_DAYMF_NUM_BASE          = 111
	E_HSTOCKHQ_BITMAP_EBIT_OPTION_BASE             = 112
	E_HSTOCKHQ_BITMAP_EBIT_SIM_MF_1DAY             = 113
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_LZDTZJ           = 114
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_WEIBI            = 115
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_LASTCHG          = 116
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_BLOCKTRADE       = 117
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_TOTALCHG         = 118
	E_HSTOCKHQ_BITMAP_EBIT_EX_JT_PE                = 119
	E_HSTOCKHQ_BITMAP_EBIT_EX_TTM_PE               = 120
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_LEAD         = 121
	E_HSTOCKHQ_BITMAP_EBIT_HK_BASE                 = 122
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_OPENCHG          = 123
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_AUCLAST          = 124
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_AUCVOL           = 125
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_AUCTURN          = 126
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_HEADCHGRATIO = 127
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_UPNUM_RATIO  = 128
	E_HSTOCKHQ_BITMAP_EBIT_BLOCKINDEX_20DAYCHG     = 129
	E_HSTOCKHQ_BITMAP_EBIT_MF_BASE_3DAY            = 130
	E_HSTOCKHQ_BITMAP_EBIT_MF_BASE_5DAY            = 131
	E_HSTOCKHQ_BITMAP_EBIT_MF_BASE_10DAY           = 132
	E_HSTOCKHQ_BITMAP_EBIT_SIM_MF_3DAY             = 133
	E_HSTOCKHQ_BITMAP_EBIT_SIM_MF_5DAY             = 134
	E_HSTOCKHQ_BITMAP_EBIT_SIM_MF_10DAY            = 135
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_HTB              = 136
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_GJB              = 137
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_HIGH_10DAYCHG    = 138
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_60DAYCHG         = 139
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_120DAYCHG        = 140
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_250DAYCHG        = 141
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_FINANCING_RATIO  = 142
	E_HSTOCKHQ_BITMAP_EBIT_DERIVE_3DAYCHG          = 143
)

type E_STOCK_HQ_SIMPLE_BITMAP int32

const (
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_NOW                       = 0
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_OPEN                      = 1
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_HIGH                      = 2
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_LOW                       = 3
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_CLOSE                     = 4
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_VOLUME                    = 5
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_AMOUNT                    = 6
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_CHGVALUE                  = 7
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_CHGRATIO                  = 8
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZHENFU                    = 9
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_OPEN_AMT                  = 10
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_OPEN_VOL                  = 11
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_NOW_VOL                   = 12
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_INSIDE                    = 13
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_OUTSIDE                   = 14
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BUY_PRICE                 = 15
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BUY_VOL                   = 16
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SELL_PRICE                = 17
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SELL_VOL                  = 18
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_AVG_PRICE                 = 19
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZT_PRICE                  = 20
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_DT_PRICE                  = 21
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TURNOVER_RATE             = 22
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_DATE                      = 23
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TIME                      = 24
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZT_MARK                   = 25
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_WP_STATUS                 = 26
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BS_FLAG                   = 27
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_DT_PE                     = 28
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_JT_PE                     = 29
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TTM_PE                    = 30
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZSZ                       = 31
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_LTSZ                      = 32
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZGB                       = 33
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_LTGB                      = 34
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_LIANGBI                   = 35
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_UP_SPEED                  = 36
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TRADE_NUM                 = 37
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_NP_STATUS                 = 38
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_5MIN_MAIN_INFLOW          = 39
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ATP_VOL                   = 40
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ATP_AMT                   = 41
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_10DAY_RATE                = 42
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_52WEEK_HIGH               = 43
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_52WEEK_LOW                = 44
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_HISTORY_HIGH              = 45
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_HISTORY_LOW               = 46
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_3DAY_NET_INFLOW           = 47
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_5DAY_NET_INFLOW           = 48
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_10DAY_NET_INFLOW          = 49
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_20DAY_NET_INFLOW          = 50
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_MATCH_PRICE               = 51
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_MATCH_VOL                 = 52
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_NOT_MATCH_VOL             = 53
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_5DAY_CHG                  = 54
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_10DAY_CHG                 = 55
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_20DAY_CHG                 = 56
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_MONTH_CHG                 = 57
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SEASON_CHG                = 58
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_YEAR_CHG                  = 59
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_THIS_YEAR_CHG             = 60
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TOTAL_CHG                 = 61
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_WEIBI                     = 62
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BIG_TRADE                 = 63
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_LYB_RANK                  = 64
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_LYB_PRE_RANK              = 65
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_OPEN_CHG                  = 66
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_LAST_AUC                  = 67
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_AUC_VOL                   = 68
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_AUC_TRUN                  = 69
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_MGSY                      = 70
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_MGJZC                     = 71
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BUY_AVG                   = 72
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SELL_AVG                  = 73
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BUY_PRICE_NUM             = 74
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SELL_PRICE_NUM            = 75
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BUY_VOLUME                = 76
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SELL_VOLUME               = 77
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_PRICE_RATIO               = 78
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TYPE                      = 79
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_FL_MAIN_BUY               = 80
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_FL_MAIN_RATIO             = 81
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_1DAY_FL                   = 82
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_3DAY_FL                   = 83
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_5DAY_FL                   = 84
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_10DAY_FL                  = 85
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_LEAD_MARKET         = 90
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_LEAD_CODE           = 91
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_LEAD_NAME           = 92
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_LEAD_NOW_PRICE      = 93
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_LEAD_HEAD_PRICE     = 94
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_TOTOAL              = 95
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_EQUAL               = 96
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_UP                  = 97
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_DOWN                = 98
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_ZT                  = 99
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_ZSZ                 = 100
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_LTSZ                = 101
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_UP_DAYS             = 102
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_3DAYS_CHG           = 103
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_5DAYS_CHG           = 104
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BLOCK_10DAYS_CHG          = 105
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_YEAR_ROR               = 110
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_10W_RATE               = 111
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_1K_RATE                = 112
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_DAYS                   = 113
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_ZK_DAYS                = 114
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_JX_FROM                = 115
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_JX_TO                  = 116
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_TODAY_BUY              = 117
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_ZJ_USE_DAYS            = 118
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_ZJ_FETCH_DAYS          = 119
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_GZJZ                   = 120
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_ZQ_YJL                    = 121
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_ZR_TYPE                = 130
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_ZR_STATUS              = 131
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_FC                     = 132
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_TYPE                   = 133
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_TP_STATUS              = 134
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_CQCX_STATUS            = 135
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_DIFF_RIGHT             = 136
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_ZSS_COUNT              = 137
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_TB_FX_TYPE                = 138
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_HK_BALANCE_PRICE          = 145
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_HK_BALANCE_VOL            = 146
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_HK_REFER_PRICE            = 147
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_HK_LOW_LIMIT_PRICE        = 148
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_HK_HIGH_LIMIT_PRICE       = 149
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_DIRECTION                 = 150
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_IMBALANCE_VOL             = 151
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BUY_LOW_LIMIT_PRICE       = 152
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_BUY_HIGHT_LIMIT_PRICE     = 153
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SELL_LOW_LIMIT_PRICE      = 154
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SELL_HIGH_LIMIT_PRICE     = 155
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SPQH_SETTLEMENT_PRICE     = 160
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SPQH_PRE_SETTLEMENT_PRICE = 161
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SPQH_OPEN_INTEREST        = 162
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SPQH_PRE_OPEN_INTEREST    = 163
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SPQH_EVERY_HAND           = 164
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_SPQH_DAY_INCREASE         = 165
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_LASTCHG                   = 166
	E_STOCK_HQ_SIMPLE_BITMAP_EBIT_10DAY_HIGH_CHG            = 167
)

type E_KLINE_BITMAP int32

const (
	E_KLINE_BITMAP_EBIT_KLINE_VOL  = 0
	E_KLINE_BITMAP_EBIT_KLINE_AMT  = 1
	E_KLINE_BITMAP_EBIT_KLINE_DAY  = 2
	E_KLINE_BITMAP_EBIT_KLINE_TIME = 3
	E_KLINE_BITMAP_EBIT_KLINE_UP   = 4
	E_KLINE_BITMAP_EBIT_KLINE_DOWN = 5
	E_KLINE_BITMAP_EBIT_KLINE_ZF   = 6
	E_KLINE_BITMAP_EBIT_KLINE_TUR  = 7
)

type E_RTMIN_BITMAP int32

const (
	E_RTMIN_BITMAP_EBIT_RTMIN_AVG      = 0
	E_RTMIN_BITMAP_EBIT_RTMIN_NOW_VOL  = 1
	E_RTMIN_BITMAP_EBIT_RTMIN_BUY_VOL  = 2
	E_RTMIN_BITMAP_EBIT_RTMIN_SELL_VOL = 3
	E_RTMIN_BITMAP_EBIT_RTMIN_AMT      = 4
	E_RTMIN_BITMAP_EBIT_RTMIN_VOL_IN   = 5
	E_RTMIN_BITMAP_EBIT_RTMIN_LEAD     = 6
	E_RTMIN_BITMAP_EBIT_RTMIN_FLAG     = 7
	E_RTMIN_BITMAP_EBIT_RTMIN_IOPV     = 8
	E_RTMIN_BITMAP_EBIT_RTMIN_DATE     = 9
)

type E_DICT_BITMAP int32

const (
	E_DICT_BITMAP_EBIT_DICT_UNIT1       = 0
	E_DICT_BITMAP_EBIT_DICT_VOL_BASE    = 1
	E_DICT_BITMAP_EBIT_DICT_PRECISE     = 2
	E_DICT_BITMAP_EBIT_DICT_CHG_HIS     = 3
	E_DICT_BITMAP_EBIT_DICT_DIFF_RIGHT  = 4
	E_DICT_BITMAP_EBIT_DICT_CDR         = 5
	E_DICT_BITMAP_EBIT_DICT_GDR         = 6
	E_DICT_BITMAP_EBIT_DICT_UNIT2       = 7
	E_DICT_BITMAP_EBIT_DICT_NAME_EX     = 8
	E_DICT_BITMAP_EBIT_DICT_DEFICIT     = 9
	E_DICT_BITMAP_EBIT_DICT_PRO_CONTROL = 10
)

type E_STOCKBASE_BITMAP int32

const (
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_NAME            = 0
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_PRECISE         = 1
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_SUB_TYPE        = 2
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_COIN_TYPE       = 3
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_LTGB            = 4
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_ZGB             = 5
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_RZ_MARK         = 6
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_RQ_MARK         = 7
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_NET_VALUE       = 8
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_CLOSE           = 9
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_ZT              = 10
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_DT              = 11
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_DIFF_RIGHT      = 12
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_CDR             = 13
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_GDR             = 14
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_IPO_DATE        = 15
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_FXJ             = 16
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_UNIT            = 17
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_JTMGSY          = 18
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_DTMGSY_BASE     = 19
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_JTMGSY_BASE     = 20
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_TTMMGSY_BASE    = 21
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_NAMEEX          = 22
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_DEFICIT         = 23
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_PRO_CONTROL     = 24
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_ZD_LIMIT        = 25
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_IPO_FLAG        = 26
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_IPO_PRIME       = 27
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_BLOCK_CODE      = 28
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_BLOCK_NAME      = 29
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_FLAG            = 30
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_END_DATE        = 31
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_RELATE_BLOCK_ID = 32
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_JZC             = 33
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_TSZLSR          = 34
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_CQCX_STATUS     = 35
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_ZSS_COUNT       = 36
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_RELATION        = 37
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_TAGS            = 38
	E_STOCKBASE_BITMAP_EBIT_STOCKBASE_ZCZB            = 39
)

type E_ORDER_ITEM_TYPE int32

const (
	E_ORDER_ITEM_TYPE_E_ORDER_ITEM_NO        = 0
	E_ORDER_ITEM_TYPE_E_ORDER_ITEM_TRADE     = 1
	E_ORDER_ITEM_TYPE_E_ORDER_ITEM_CANCEL    = 2
	E_ORDER_ITEM_TYPE_E_ORDER_ITEM_BIG       = 4
	E_ORDER_ITEM_TYPE_E_ORDER_ITEM_ADD       = 8
	E_ORDER_ITEM_TYPE_E_ORDER_ITEM_PARTTRADE = 16
	E_ORDER_ITEM_TYPE_E_ORDER_ITEM_MKTPRICE  = 32
)

type E_ORDER_OPERATE_TYPE int32

const (
	E_ORDER_OPERATE_TYPE_E_BUY_ORDER    = 0
	E_ORDER_OPERATE_TYPE_E_SELL_ORDER   = 1
	E_ORDER_OPERATE_TYPE_E_CANCAL_ORDER = 2
)

type E_ORDER_TRADE_KINDE int32

const (
	E_ORDER_TRADE_KINDE_E_ORDER_MARKET_PRICE = 0
	E_ORDER_TRADE_KINDE_E_ORDER_FIXED_PRICE  = 1
	E_ORDER_TRADE_KINDE_E_ORDER_BEST_SCHEME  = 2
)

type TRANS_VOL_RANGE int32

const (
	TRANS_VOL_RANGE_E_TRANS_VOL_0_1       = 0
	TRANS_VOL_RANGE_E_TRANS_VOL_1_3       = 1
	TRANS_VOL_RANGE_E_TRANS_VOL_3_7       = 2
	TRANS_VOL_RANGE_E_TRANS_VOL_7_10      = 3
	TRANS_VOL_RANGE_E_TRANS_VOL_10_15     = 4
	TRANS_VOL_RANGE_E_TRANS_VOL_15_20     = 5
	TRANS_VOL_RANGE_E_TRANS_VOL_20_30     = 6
	TRANS_VOL_RANGE_E_TRANS_VOL_30_50     = 7
	TRANS_VOL_RANGE_E_TRANS_VOL_50_70     = 8
	TRANS_VOL_RANGE_E_TRANS_VOL_70_100    = 9
	TRANS_VOL_RANGE_E_TRANS_VOL_100_200   = 10
	TRANS_VOL_RANGE_E_TRANS_VOL_200_500   = 11
	TRANS_VOL_RANGE_E_TRANS_VOL_500_700   = 12
	TRANS_VOL_RANGE_E_TRANS_VOL_700_1000  = 13
	TRANS_VOL_RANGE_E_TRANS_VOL_1000_1500 = 14
	TRANS_VOL_RANGE_E_TRANS_VOL_1500_2000 = 15
	TRANS_VOL_RANGE_E_TRANS_VOL_2000_3000 = 16
	TRANS_VOL_RANGE_E_TRANS_VOL_3000_5000 = 17
	TRANS_VOL_RANGE_E_TRANS_VOL_5000_7000 = 18
	TRANS_VOL_RANGE_E_TRANS_VOL_7000_MAX  = 19
)

type H_ZH_RANK_TYPE int32

const (
	H_ZH_RANK_TYPE_E_ZH_RANK_UP         = 1
	H_ZH_RANK_TYPE_E_ZH_RANK_DROP       = 2
	H_ZH_RANK_TYPE_E_ZH_RANK_SPEED_TOP  = 4
	H_ZH_RANK_TYPE_E_ZH_RANK_SPEED_LAST = 8
	H_ZH_RANK_TYPE_E_ZH_RANK_WEIBI_TOP  = 16
	H_ZH_RANK_TYPE_E_ZH_RANK_WEIBI_LAST = 32
	H_ZH_RANK_TYPE_E_ZH_RANK_LIANGBI    = 64
	H_ZH_RANK_TYPE_E_ZH_RANK_AMOUNT     = 128
	H_ZH_RANK_TYPE_E_ZH_RANK_ZHENFU     = 256
	H_ZH_RANK_TYPE_E_ZH_RANK_ALL        = 4095
)

type E_MARKET_TYPE int32

const (
	E_MARKET_TYPE_E_TYPE_SZ_AB     = 0
	E_MARKET_TYPE_E_TYPE_SH_AB     = 1
	E_MARKET_TYPE_E_TYPE_BK_ZS     = 2
	E_MARKET_TYPE_E_TYPE_QH_GZ     = 3
	E_MARKET_TYPE_E_TYPE_QH_TB     = 4
	E_MARKET_TYPE_E_TYPE_SH_ZQ_HG  = 5
	E_MARKET_TYPE_E_TYPE_SZ_ZQ_HG  = 6
	E_MARKET_TYPE_E_TYPE_GGT       = 7
	E_MARKET_TYPE_E_TYPE_SH_KCB    = 8
	E_MARKET_TYPE_E_TYPE_SH_OPTION = 9
	E_MARKET_TYPE_E_TYPE_SZ_OPTION = 10
	E_MARKET_TYPE_E_TYPE_SZ_GZGG   = 11
	E_MARKET_TYPE_E_TYPE_SZ_CYREG  = 12
	E_MARKET_TYPE_E_TYPE_SF_OPTION = 13
	E_MARKET_TYPE_E_TYPE_SZ_ZQXQ   = 14
	E_MARKET_TYPE_E_TYPE_BJ_AB     = 15
	E_MARKET_TYPE_E_TYPE_NONE      = 99
)

type E_LOGIN_CLIENT_TYPE int32

const (
	E_LOGIN_CLIENT_TYPE_EPC_LOGIN     = 0
	E_LOGIN_CLIENT_TYPE_EMOBILE_LOGIN = 1
	E_LOGIN_CLIENT_TYPE_EWEB_LOGIN    = 2
)

type E_KICK_OUT_STATUS int32

const (
	E_KICK_OUT_STATUS_E_NOT_KICK_OUT = 0
	E_KICK_OUT_STATUS_E_DO_KICK_OUT  = 1
)

type E_KICK_OUT_REASON int32

const (
	E_KICK_OUT_REASON_E_KICK_REPEAT  = 0
	E_KICK_OUT_REASON_E_KICK_OVERDUE = 1
)

type E_LOGIN_AUTH_TYPE int32

const (
	E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_SZ_SH  = 1
	E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_HK_US  = 2
	E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_LST    = 3
	E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_XW     = 4
	E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_AC     = 5
	E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_CLS    = 6
	E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_GNN    = 7
	E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_GNN_DL = 8
)

type E_AUTH_TYPE int32

const (
	E_AUTH_TYPE_E_AUTH_OEM       = 1
	E_AUTH_TYPE_E_AUTH_LOGIN     = 2
	E_AUTH_TYPE_E_AUTH_ALL_LOGIN = 3
	E_AUTH_TYPE_E_AUTH_KICK_USER = 4
)

type E_HK_WARRANT_TYPE int32

const (
	E_HK_WARRANT_TYPE_E_HWT_NONE  = 0
	E_HK_WARRANT_TYPE_E_HWT_WL    = 1
	E_HK_WARRANT_TYPE_E_HWT_NX    = 2
	E_HK_WARRANT_TYPE_E_HWT_WL_NX = 3
)

type E_SN_DATA_TYPE int32

const (
	E_SN_DATA_TYPE_E_SN_SZ_NET    = 0
	E_SN_DATA_TYPE_E_SN_SH_NET    = 1
	E_SN_DATA_TYPE_E_SN_SZ_INFLOW = 2
	E_SN_DATA_TYPE_E_SN_SH_INFLOW = 3
)

type E_ZDFENBU_TYPE int32

const (
	E_ZDFENBU_TYPE_E_ZD_SZ_AG   = 1
	E_ZDFENBU_TYPE_E_ZD_SH_AG   = 2
	E_ZDFENBU_TYPE_E_ZD_BJ_GP   = 3
	E_ZDFENBU_TYPE_E_ZD_SZSH_AG = 4
	E_ZDFENBU_TYPE_E_ZD_SZSHBJ  = 5
	E_ZDFENBU_TYPE_E_ZD_HK      = 6
	E_ZDFENBU_TYPE_E_ZD_AMEX    = 7
)

// HTolMoneyFlow struct implement
type HTolMoneyFlow struct {
	codec.JceStructBase
	ITime      int32   `json:"iTime"`
	Shtsetcode int16   `json:"shtsetcode"`
	SCode      string  `json:"sCode"`
	FSuperIn   float64 `json:"fSuperIn"`
	FSuperOut  float64 `json:"fSuperOut"`
	FBigIn     float64 `json:"fBigIn"`
	FBigOut    float64 `json:"fBigOut"`
	FMidIn     float64 `json:"fMidIn"`
	FMidOut    float64 `json:"fMidOut"`
	FSmallIn   float64 `json:"fSmallIn"`
	FSmallOut  float64 `json:"fSmallOut"`
	DPrevClose float64 `json:"dPrevClose"`
}

func (st *HTolMoneyFlow) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTolMoneyFlow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ITime, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Shtsetcode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSuperIn, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSuperOut, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FBigIn, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FBigOut, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FMidIn, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FMidOut, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSmallIn, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSmallOut, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrevClose, 12, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTolMoneyFlow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTolMoneyFlow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTolMoneyFlow) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ITime, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Shtsetcode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSuperIn, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSuperOut, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FBigIn, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FBigOut, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FMidIn, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FMidOut, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSmallIn, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSmallOut, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrevClose, 12)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTolMoneyFlow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTolMoneyFlow) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtsetcode:", st.Shtsetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSuperIn:", st.FSuperIn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSuperOut:", st.FSuperOut)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fBigIn:", st.FBigIn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fBigOut:", st.FBigOut)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMidIn:", st.FMidIn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMidOut:", st.FMidOut)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSmallIn:", st.FSmallIn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSmallOut:", st.FSmallOut)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrevClose:", st.DPrevClose)

	ret = ret + " }"
	return ret
}

// HSimpleMoneyFlow struct implement
type HSimpleMoneyFlow struct {
	codec.JceStructBase
	FMainBuy   float64 `json:"fMainBuy"`
	FMainRatio float32 `json:"fMainRatio"`
}

func (st *HSimpleMoneyFlow) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSimpleMoneyFlow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.FMainBuy, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FMainRatio, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSimpleMoneyFlow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSimpleMoneyFlow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSimpleMoneyFlow) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.FMainBuy, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FMainRatio, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSimpleMoneyFlow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSimpleMoneyFlow) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fMainBuy:", st.FMainBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMainRatio:", st.FMainRatio)

	ret = ret + " }"
	return ret
}

// HTolMoneyFlowSet struct implement
type HTolMoneyFlowSet struct {
	codec.JceStructBase
	Amt HTolMoneyFlow `json:"amt"`
	Vol HTolMoneyFlow `json:"vol"`
	Num HTolMoneyFlow `json:"num"`
}

func (st *HTolMoneyFlowSet) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Amt.ResetDefault()
	st.Vol.ResetDefault()
	st.Num.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTolMoneyFlowSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Amt.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Vol.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.Num.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTolMoneyFlowSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTolMoneyFlowSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTolMoneyFlowSet) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Amt.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Vol.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.Num.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTolMoneyFlowSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTolMoneyFlowSet) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "amt:" + st.Amt.Display()
	ret = ret + ",  "
	ret = ret + "vol:" + st.Vol.Display()
	ret = ret + ",  "
	ret = ret + "num:" + st.Num.Display()

	ret = ret + " }"
	return ret
}

// HRTMinData struct implement
type HRTMinData struct {
	codec.JceStructBase
	ShtMinute    int16   `json:"shtMinute"`
	FNow         float64 `json:"fNow"`
	FAverage     float64 `json:"fAverage"`
	UiNowVol     uint32  `json:"uiNowVol"`
	UiBuyv       uint32  `json:"uiBuyv"`
	UiSellv      uint32  `json:"uiSellv"`
	DAmount      float64 `json:"dAmount"`
	UiVolInStock uint32  `json:"uiVolInStock"`
	FLead        float64 `json:"fLead"`
	ShtFlag      int16   `json:"shtFlag"`
	DIOPV        float64 `json:"dIOPV"`
	IDate        int32   `json:"iDate"`
}

func (st *HRTMinData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtFlag = 0
	st.DIOPV = 0.0
	st.IDate = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HRTMinData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMinute, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNow, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FAverage, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiNowVol, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiBuyv, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiSellv, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAmount, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiVolInStock, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FLead, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtFlag, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DIOPV, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 12, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRTMinData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRTMinData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRTMinData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMinute, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNow, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FAverage, 3)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiNowVol, 4)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiBuyv, 5)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiSellv, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAmount, 7)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiVolInStock, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FLead, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtFlag, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DIOPV, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 12)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRTMinData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRTMinData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMinute:", st.ShtMinute)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNow:", st.FNow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAverage:", st.FAverage)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiNowVol:", st.UiNowVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiBuyv:", st.UiBuyv)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiSellv:", st.UiSellv)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAmount:", st.DAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiVolInStock:", st.UiVolInStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLead:", st.FLead)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtFlag:", st.ShtFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dIOPV:", st.DIOPV)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)

	ret = ret + " }"
	return ret
}

// HRTMinDataSimple struct implement
type HRTMinDataSimple struct {
	codec.JceStructBase
	ShtMinute int16             `json:"shtMinute"`
	FNow      float64           `json:"fNow"`
	M         map[int32]float64 `json:"m"`
}

func (st *HRTMinDataSimple) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRTMinDataSimple) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMinute, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNow, 2, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M = make(map[int32]float64)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 float64

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_float64(&v0, 1, false)
			if err != nil {
				return err
			}

			st.M[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRTMinDataSimple) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRTMinDataSimple, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRTMinDataSimple) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMinute, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNow, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.M {

		err = _os.Write_int32(k1, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(v1, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRTMinDataSimple) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRTMinDataSimple) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMinute:", st.ShtMinute)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNow:", st.FNow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m:", st.M)

	ret = ret + " }"
	return ret
}

// HRTMinDataSimp struct implement
type HRTMinDataSimp struct {
	codec.JceStructBase
	ShtMinute int16   `json:"shtMinute"`
	FNow      float32 `json:"fNow"`
	FAverage  float32 `json:"fAverage"`
}

func (st *HRTMinDataSimp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtMinute = 0
	st.FNow = 0.0
	st.FAverage = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HRTMinDataSimp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMinute, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FNow, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FAverage, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRTMinDataSimp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRTMinDataSimp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRTMinDataSimp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMinute, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FNow, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FAverage, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRTMinDataSimp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRTMinDataSimp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMinute:", st.ShtMinute)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNow:", st.FNow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAverage:", st.FAverage)

	ret = ret + " }"
	return ret
}

// HRTMinDataAuc struct implement
type HRTMinDataAuc struct {
	codec.JceStructBase
	ShtTime int32   `json:"shtTime"`
	FNow    float32 `json:"fNow"`
	LVol    int64   `json:"lVol"`
	LUmVol  int64   `json:"lUmVol"`
	ShtDir  int16   `json:"shtDir"`
}

func (st *HRTMinDataAuc) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRTMinDataAuc) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ShtTime, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FNow, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVol, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LUmVol, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDir, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRTMinDataAuc) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRTMinDataAuc, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRTMinDataAuc) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ShtTime, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FNow, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVol, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LUmVol, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDir, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRTMinDataAuc) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRTMinDataAuc) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtTime:", st.ShtTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNow:", st.FNow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVol:", st.LVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lUmVol:", st.LUmVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDir:", st.ShtDir)

	ret = ret + " }"
	return ret
}

// SZTData struct implement
type SZTData struct {
	codec.JceStructBase
	BZT         int8  `json:"bZT"`
	BPreZT      int8  `json:"bPreZT"`
	IBoardDays  int32 `json:"iBoardDays"`
	IStrongDays int32 `json:"iStrongDays"`
	IZDTDays    int32 `json:"iZDTDays"`
}

func (st *SZTData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *SZTData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int8(&st.BZT, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BPreZT, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IBoardDays, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStrongDays, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZDTDays, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SZTData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SZTData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SZTData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int8(st.BZT, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BPreZT, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IBoardDays, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStrongDays, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZDTDays, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SZTData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SZTData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("bZT:", st.BZT)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bPreZT:", st.BPreZT)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iBoardDays:", st.IBoardDays)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStrongDays:", st.IStrongDays)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZDTDays:", st.IZDTDays)

	ret = ret + " }"
	return ret
}

// BlockBasicInfo struct implement
type BlockBasicInfo struct {
	codec.JceStructBase
	SCode string `json:"sCode"`
	SName string `json:"sName"`
}

func (st *BlockBasicInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *BlockBasicInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BlockBasicInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BlockBasicInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BlockBasicInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BlockBasicInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *BlockBasicInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)

	ret = ret + " }"
	return ret
}

// HDateTime struct implement
type HDateTime struct {
	codec.JceStructBase
	IDate   int32 `json:"iDate"`
	ShtDay  int16 `json:"shtDay"`
	ShtTime int16 `json:"shtTime"`
}

func (st *HDateTime) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HDateTime) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDay, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtTime, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HDateTime) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HDateTime, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HDateTime) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDay, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtTime, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HDateTime) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HDateTime) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDay:", st.ShtDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtTime:", st.ShtTime)

	ret = ret + " }"
	return ret
}

// HTogetherZhiShu struct implement
type HTogetherZhiShu struct {
	codec.JceStructBase
	UiVolInStock uint32  `json:"uiVolInStock"`
	FYClose      float64 `json:"fYClose"`
	UsUp         uint16  `json:"usUp"`
	UsDown       uint16  `json:"usDown"`
}

func (st *HTogetherZhiShu) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTogetherZhiShu) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint32(&st.UiVolInStock, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FYClose, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint16(&st.UsUp, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint16(&st.UsDown, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTogetherZhiShu) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTogetherZhiShu, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTogetherZhiShu) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint32(st.UiVolInStock, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FYClose, 2)
	if err != nil {
		return err
	}

	err = _os.Write_uint16(st.UsUp, 3)
	if err != nil {
		return err
	}

	err = _os.Write_uint16(st.UsDown, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTogetherZhiShu) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTogetherZhiShu) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("uiVolInStock:", st.UiVolInStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fYClose:", st.FYClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("usUp:", st.UsUp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("usDown:", st.UsDown)

	ret = ret + " }"
	return ret
}

// HAnalyData struct implement
type HAnalyData struct {
	codec.JceStructBase
	SttDateTime      HDateTime       `json:"sttDateTime"`
	FOpen            float64         `json:"fOpen"`
	FHigh            float64         `json:"fHigh"`
	FLow             float64         `json:"fLow"`
	FClose           float64         `json:"fClose"`
	FAmount          float64         `json:"fAmount"`
	LVolume          int64           `json:"lVolume"`
	DSettlementPrice float64         `json:"dSettlementPrice"`
	SttZhiShu        HTogetherZhiShu `json:"sttZhiShu"`
	UiAtpVolume      uint32          `json:"uiAtpVolume"`
	DAtpAmount       float64         `json:"dAtpAmount"`
	UiAtpTradeNum    uint32          `json:"uiAtpTradeNum"`
	FZhenfu          float32         `json:"fZhenfu"`
	FTurnoverRate    float32         `json:"fTurnoverRate"`
}

func (st *HAnalyData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.SttDateTime.ResetDefault()
	st.SttZhiShu.ResetDefault()
	st.UiAtpVolume = 0
	st.DAtpAmount = 0
	st.UiAtpTradeNum = 0
	st.FZhenfu = 0
	st.FTurnoverRate = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HAnalyData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.SttDateTime.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FOpen, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHigh, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FLow, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FClose, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FAmount, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSettlementPrice, 9, false)
	if err != nil {
		return err
	}

	err = st.SttZhiShu.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiAtpVolume, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAtpAmount, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiAtpTradeNum, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FZhenfu, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FTurnoverRate, 15, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HAnalyData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HAnalyData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HAnalyData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.SttDateTime.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FOpen, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHigh, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FLow, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FClose, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FAmount, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSettlementPrice, 9)
	if err != nil {
		return err
	}

	err = st.SttZhiShu.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiAtpVolume, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAtpAmount, 12)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiAtpTradeNum, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FZhenfu, 14)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FTurnoverRate, 15)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HAnalyData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HAnalyData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "sttDateTime:" + st.SttDateTime.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fOpen:", st.FOpen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHigh:", st.FHigh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLow:", st.FLow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fClose:", st.FClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAmount:", st.FAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSettlementPrice:", st.DSettlementPrice)
	ret = ret + ",  "
	ret = ret + "sttZhiShu:" + st.SttZhiShu.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiAtpVolume:", st.UiAtpVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAtpAmount:", st.DAtpAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiAtpTradeNum:", st.UiAtpTradeNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fZhenfu:", st.FZhenfu)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTurnoverRate:", st.FTurnoverRate)

	ret = ret + " }"
	return ret
}

// HCQAnalyData struct implement
type HCQAnalyData struct {
	codec.JceStructBase
	StLine     HAnalyData `json:"stLine"`
	LOpenDate  int64      `json:"lOpenDate"`
	LCloseDate int64      `json:"lCloseDate"`
	LHighDate  int64      `json:"lHighDate"`
	LLowDate   int64      `json:"lLowDate"`
	DHigh      float64    `json:"dHigh"`
	DLow       float64    `json:"dLow"`
}

func (st *HCQAnalyData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StLine.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCQAnalyData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StLine.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LOpenDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LCloseDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LHighDate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LLowDate, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHigh, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLow, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCQAnalyData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCQAnalyData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCQAnalyData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StLine.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LOpenDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LCloseDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LHighDate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LLowDate, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHigh, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLow, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCQAnalyData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCQAnalyData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stLine:" + st.StLine.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lOpenDate:", st.LOpenDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lCloseDate:", st.LCloseDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lHighDate:", st.LHighDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lLowDate:", st.LLowDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHigh:", st.DHigh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLow:", st.DLow)

	ret = ret + " }"
	return ret
}

// HCQAnalyDataSimple struct implement
type HCQAnalyDataSimple struct {
	codec.JceStructBase
	D int32             `json:"d"`
	O float64           `json:"o"`
	H float64           `json:"h"`
	L float64           `json:"l"`
	C float64           `json:"c"`
	M map[int32]float64 `json:"m"`
}

func (st *HCQAnalyDataSimple) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCQAnalyDataSimple) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.D, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.O, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.H, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.L, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.C, 5, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 6, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M = make(map[int32]float64)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 float64

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_float64(&v0, 1, false)
			if err != nil {
				return err
			}

			st.M[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCQAnalyDataSimple) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCQAnalyDataSimple, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCQAnalyDataSimple) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.D, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.O, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.H, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.L, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.C, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.M {

		err = _os.Write_int32(k1, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(v1, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCQAnalyDataSimple) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCQAnalyDataSimple) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("d:", st.D)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("o:", st.O)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("h:", st.H)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("l:", st.L)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("c:", st.C)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m:", st.M)

	ret = ret + " }"
	return ret
}

// HTickData struct implement
type HTickData struct {
	codec.JceStructBase
	ShtMinute      int16   `json:"shtMinute"`
	FNowPrice      float64 `json:"fNowPrice"`
	UiNowVol       uint32  `json:"uiNowVol"`
	ShtInOutFlag   int16   `json:"shtInOutFlag"`
	ITime          int32   `json:"iTime"`
	ITradeNum      int32   `json:"iTradeNum"`
	DAvgPrice      float64 `json:"dAvgPrice"`
	UiFrontTrans   uint32  `json:"uiFrontTrans"`
	IVolInStockDif int32   `json:"iVolInStockDif"`
	ShtType        int16   `json:"shtType"`
}

func (st *HTickData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTickData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMinute, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNowPrice, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiNowVol, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtInOutFlag, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITime, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeNum, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAvgPrice, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiFrontTrans, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IVolInStockDif, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 10, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTickData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTickData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTickData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMinute, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNowPrice, 2)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiNowVol, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtInOutFlag, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITime, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeNum, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAvgPrice, 7)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiFrontTrans, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IVolInStockDif, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 10)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTickData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTickData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMinute:", st.ShtMinute)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiNowVol:", st.UiNowVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtInOutFlag:", st.ShtInOutFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeNum:", st.ITradeNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAvgPrice:", st.DAvgPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiFrontTrans:", st.UiFrontTrans)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iVolInStockDif:", st.IVolInStockDif)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)

	ret = ret + " }"
	return ret
}

// HMarketTradePeriod struct implement
type HMarketTradePeriod struct {
	codec.JceStructBase
	VTradePeriod []int16 `json:"vTradePeriod"`
}

func (st *HMarketTradePeriod) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketTradePeriod) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTradePeriod = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VTradePeriod[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketTradePeriod) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketTradePeriod, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketTradePeriod) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTradePeriod)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTradePeriod {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketTradePeriod) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketTradePeriod) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vTradePeriod:", st.VTradePeriod)

	ret = ret + " }"
	return ret
}

// HStock struct implement
type HStock struct {
	codec.JceStructBase
	ShtSetcode int16  `json:"shtSetcode"`
	SCode      string `json:"sCode"`
	SName      string `json:"sName"`
}

func (st *HStock) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStock) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStock) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)

	ret = ret + " }"
	return ret
}

// HMarketTypeData struct implement
type HMarketTypeData struct {
	codec.JceStructBase
	ShtMarket int16 `json:"shtMarket"`
	ShtType   int16 `json:"shtType"`
}

func (st *HMarketTypeData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtMarket = 0
	st.ShtType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketTypeData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketTypeData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketTypeData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketTypeData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketTypeData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketTypeData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)

	ret = ret + " }"
	return ret
}

// HStockDatePeriod struct implement
type HStockDatePeriod struct {
	codec.JceStructBase
	StStock        HStockUnique `json:"stStock"`
	IStartDate     int32        `json:"iStartDate"`
	IEndDate       int32        `json:"iEndDate"`
	INum           int32        `json:"iNum"`
	IStartDateTime int64        `json:"iStartDateTime"`
	IEndDateTime   int64        `json:"iEndDateTime"`
}

func (st *HStockDatePeriod) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StStock.ResetDefault()
	st.IStartDate = 11110101
	st.IEndDate = 22220101
	st.INum = 0
	st.IStartDateTime = 0
	st.IEndDateTime = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDatePeriod) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StStock.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEndDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.INum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.IStartDateTime, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.IEndDateTime, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDatePeriod) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDatePeriod, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDatePeriod) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StStock.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEndDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.INum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.IStartDateTime, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.IEndDateTime, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDatePeriod) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDatePeriod) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stStock:" + st.StStock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartDate:", st.IStartDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDate:", st.IEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNum:", st.INum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartDateTime:", st.IStartDateTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDateTime:", st.IEndDateTime)

	ret = ret + " }"
	return ret
}

// HStockAnalyData struct implement
type HStockAnalyData struct {
	codec.JceStructBase
	StStock     HStockUnique `json:"stStock"`
	VAnalayData []HAnalyData `json:"vAnalayData"`
	ISumCount   int32        `json:"iSumCount"`
}

func (st *HStockAnalyData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StStock.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAnalyData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StStock.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VAnalayData = make([]HAnalyData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VAnalayData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.ISumCount, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAnalyData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAnalyData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAnalyData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StStock.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VAnalayData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VAnalayData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.ISumCount, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAnalyData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAnalyData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stStock:" + st.StStock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vAnalayData:", st.VAnalayData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSumCount:", st.ISumCount)

	ret = ret + " }"
	return ret
}

// HStockAnalySimpleData struct implement
type HStockAnalySimpleData struct {
	codec.JceStructBase
	Stock HStockUnique         `json:"stock"`
	VData []HCQAnalyDataSimple `json:"vData"`
	ISum  int32                `json:"iSum"`
}

func (st *HStockAnalySimpleData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Stock.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAnalySimpleData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Stock.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HCQAnalyDataSimple, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.ISum, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAnalySimpleData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAnalySimpleData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAnalySimpleData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Stock.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.ISum, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAnalySimpleData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAnalySimpleData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stock:" + st.Stock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vData:", st.VData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSum:", st.ISum)

	ret = ret + " }"
	return ret
}

// HMFlowTrend struct implement
type HMFlowTrend struct {
	codec.JceStructBase
	FMainMoneyInflow   float64 `json:"fMainMoneyInflow"`
	FMainMoneyRatio    float64 `json:"fMainMoneyRatio"`
	FRetailMoneyInflow float64 `json:"fRetailMoneyInflow"`
	FRetailMoneyRatio  float64 `json:"fRetailMoneyRatio"`
	FSuperLargeInflow  float64 `json:"fSuperLargeInflow"`
	FSuperLargeRatio   float64 `json:"fSuperLargeRatio"`
	FLargeInflow       float64 `json:"fLargeInflow"`
	FLargeRatio        float64 `json:"fLargeRatio"`
	FMiddleInflow      float64 `json:"fMiddleInflow"`
	FMiddleRatio       float64 `json:"fMiddleRatio"`
	FSmallInflow       float64 `json:"fSmallInflow"`
	FSmallRatio        float64 `json:"fSmallRatio"`
}

func (st *HMFlowTrend) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFlowTrend) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.FMainMoneyInflow, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FMainMoneyRatio, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FRetailMoneyInflow, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FRetailMoneyRatio, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSuperLargeInflow, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSuperLargeRatio, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FLargeInflow, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FLargeRatio, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FMiddleInflow, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FMiddleRatio, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSmallInflow, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSmallRatio, 12, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFlowTrend) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFlowTrend, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFlowTrend) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.FMainMoneyInflow, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FMainMoneyRatio, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FRetailMoneyInflow, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FRetailMoneyRatio, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSuperLargeInflow, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSuperLargeRatio, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FLargeInflow, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FLargeRatio, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FMiddleInflow, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FMiddleRatio, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSmallInflow, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSmallRatio, 12)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFlowTrend) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFlowTrend) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fMainMoneyInflow:", st.FMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMainMoneyRatio:", st.FMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRetailMoneyInflow:", st.FRetailMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRetailMoneyRatio:", st.FRetailMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSuperLargeInflow:", st.FSuperLargeInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSuperLargeRatio:", st.FSuperLargeRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLargeInflow:", st.FLargeInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLargeRatio:", st.FLargeRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMiddleInflow:", st.FMiddleInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMiddleRatio:", st.FMiddleRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSmallInflow:", st.FSmallInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSmallRatio:", st.FSmallRatio)

	ret = ret + " }"
	return ret
}

// HMFlowRank struct implement
type HMFlowRank struct {
	codec.JceStructBase
	ShtSetcode         int16          `json:"shtSetcode"`
	SCode              string         `json:"sCode"`
	SName              string         `json:"sName"`
	IType              int32          `json:"iType"`
	FNowPrice          float64        `json:"fNowPrice"`
	FChg               float64        `json:"fChg"`
	FChange            float64        `json:"fChange"`
	FDayMFlowTrend     HMFlowTrend    `json:"fDayMFlowTrend"`
	F3DayMFlowTrend    HMFlowTrend    `json:"f3DayMFlowTrend"`
	F5DayMFlowTrend    HMFlowTrend    `json:"f5DayMFlowTrend"`
	F10DayMFlowTrend   HMFlowTrend    `json:"f10DayMFlowTrend"`
	BTransactionStatus int8           `json:"bTransactionStatus"`
	F3MinMFlowTrend    HMFlowTrend    `json:"f3MinMFlowTrend"`
	F5MinMFlowTrend    HMFlowTrend    `json:"f5MinMFlowTrend"`
	ZtData             SZTData        `json:"ztData"`
	LeadBlock          BlockBasicInfo `json:"leadBlock"`
	F10MinMFlowTrend   HMFlowTrend    `json:"f10MinMFlowTrend"`
	F30MinMFlowTrend   HMFlowTrend    `json:"f30MinMFlowTrend"`
	F60MinMFlowTrend   HMFlowTrend    `json:"f60MinMFlowTrend"`
}

func (st *HMFlowRank) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.FDayMFlowTrend.ResetDefault()
	st.F3DayMFlowTrend.ResetDefault()
	st.F5DayMFlowTrend.ResetDefault()
	st.F10DayMFlowTrend.ResetDefault()
	st.F3MinMFlowTrend.ResetDefault()
	st.F5MinMFlowTrend.ResetDefault()
	st.ZtData.ResetDefault()
	st.LeadBlock.ResetDefault()
	st.F10MinMFlowTrend.ResetDefault()
	st.F30MinMFlowTrend.ResetDefault()
	st.F60MinMFlowTrend.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMFlowRank) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IType, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNowPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChg, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChange, 6, false)
	if err != nil {
		return err
	}

	err = st.FDayMFlowTrend.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.F3DayMFlowTrend.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.F5DayMFlowTrend.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.F10DayMFlowTrend.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BTransactionStatus, 11, false)
	if err != nil {
		return err
	}

	err = st.F3MinMFlowTrend.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = st.F5MinMFlowTrend.ReadBlock(_is, 13, false)
	if err != nil {
		return err
	}

	err = st.ZtData.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = st.LeadBlock.ReadBlock(_is, 15, false)
	if err != nil {
		return err
	}

	err = st.F10MinMFlowTrend.ReadBlock(_is, 16, false)
	if err != nil {
		return err
	}

	err = st.F30MinMFlowTrend.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	err = st.F60MinMFlowTrend.ReadBlock(_is, 18, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMFlowRank) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMFlowRank, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMFlowRank) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IType, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNowPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChg, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChange, 6)
	if err != nil {
		return err
	}

	err = st.FDayMFlowTrend.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.F3DayMFlowTrend.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.F5DayMFlowTrend.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.F10DayMFlowTrend.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BTransactionStatus, 11)
	if err != nil {
		return err
	}

	err = st.F3MinMFlowTrend.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = st.F5MinMFlowTrend.WriteBlock(_os, 13)
	if err != nil {
		return err
	}

	err = st.ZtData.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = st.LeadBlock.WriteBlock(_os, 15)
	if err != nil {
		return err
	}

	err = st.F10MinMFlowTrend.WriteBlock(_os, 16)
	if err != nil {
		return err
	}

	err = st.F30MinMFlowTrend.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	err = st.F60MinMFlowTrend.WriteBlock(_os, 18)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMFlowRank) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMFlowRank) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iType:", st.IType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChange:", st.FChange)
	ret = ret + ",  "
	ret = ret + "fDayMFlowTrend:" + st.FDayMFlowTrend.Display()
	ret = ret + ",  "
	ret = ret + "f3DayMFlowTrend:" + st.F3DayMFlowTrend.Display()
	ret = ret + ",  "
	ret = ret + "f5DayMFlowTrend:" + st.F5DayMFlowTrend.Display()
	ret = ret + ",  "
	ret = ret + "f10DayMFlowTrend:" + st.F10DayMFlowTrend.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bTransactionStatus:", st.BTransactionStatus)
	ret = ret + ",  "
	ret = ret + "f3MinMFlowTrend:" + st.F3MinMFlowTrend.Display()
	ret = ret + ",  "
	ret = ret + "f5MinMFlowTrend:" + st.F5MinMFlowTrend.Display()
	ret = ret + ",  "
	ret = ret + "ztData:" + st.ZtData.Display()
	ret = ret + ",  "
	ret = ret + "leadBlock:" + st.LeadBlock.Display()
	ret = ret + ",  "
	ret = ret + "f10MinMFlowTrend:" + st.F10MinMFlowTrend.Display()
	ret = ret + ",  "
	ret = ret + "f30MinMFlowTrend:" + st.F30MinMFlowTrend.Display()
	ret = ret + ",  "
	ret = ret + "f60MinMFlowTrend:" + st.F60MinMFlowTrend.Display()

	ret = ret + " }"
	return ret
}

// HDDERank struct implement
type HDDERank struct {
	codec.JceStructBase
	ShtSetcode    int16   `json:"shtSetcode"`
	SCode         string  `json:"sCode"`
	SName         string  `json:"sName"`
	FNowPrice     float64 `json:"fNowPrice"`
	FChg          float64 `json:"fChg"`
	FTurnoverRate float64 `json:"fTurnoverRate"`
	FDDX          float64 `json:"fDDX"`
	FDDY          float64 `json:"fDDY"`
	FDDZ          float64 `json:"fDDZ"`
	FDDF          float64 `json:"fDDF"`
	FDDX5         float64 `json:"fDDX5"`
	FDDY5         float64 `json:"fDDY5"`
	FDDX60        float64 `json:"fDDX60"`
	FDDY60        float64 `json:"fDDY60"`
}

func (st *HDDERank) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HDDERank) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNowPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChg, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FTurnoverRate, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDX, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDY, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDZ, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDF, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDX5, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDY5, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDX60, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDY60, 14, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HDDERank) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HDDERank, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HDDERank) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNowPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChg, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FTurnoverRate, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDX, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDY, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDZ, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDF, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDX5, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDY5, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDX60, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDY60, 14)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HDDERank) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HDDERank) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTurnoverRate:", st.FTurnoverRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX:", st.FDDX)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDY:", st.FDDY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDZ:", st.FDDZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDF:", st.FDDF)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX5:", st.FDDX5)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDY5:", st.FDDY5)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX60:", st.FDDX60)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDY60:", st.FDDY60)

	ret = ret + " }"
	return ret
}

// HDxjl struct implement
type HDxjl struct {
	codec.JceStructBase
	ShtSetcode int16     `json:"shtSetcode"`
	SCode      string    `json:"sCode"`
	SName      string    `json:"sName"`
	IOrderTime int32     `json:"iOrderTime"`
	IShtType   int32     `json:"iShtType"`
	DOrderVol  float64   `json:"dOrderVol"`
	FNowPrice  float64   `json:"fNowPrice"`
	INum       int32     `json:"iNum"`
	FChg       float64   `json:"fChg"`
	VExts      []float64 `json:"vExts"`
}

func (st *HDxjl) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HDxjl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IOrderTime, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IShtType, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOrderVol, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNowPrice, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.INum, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChg, 11, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(12, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VExts = make([]float64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_float64(&st.VExts[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HDxjl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HDxjl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HDxjl) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IOrderTime, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IShtType, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOrderVol, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNowPrice, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.INum, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChg, 11)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VExts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VExts {

		err = _os.Write_float64(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HDxjl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HDxjl) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iOrderTime:", st.IOrderTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iShtType:", st.IShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOrderVol:", st.DOrderVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNum:", st.INum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vExts:", st.VExts)

	ret = ret + " }"
	return ret
}

// HOrderUnit struct implement
type HOrderUnit struct {
	codec.JceStructBase
	DPadOrderPrice   float64 `json:"dPadOrderPrice"`
	IPadOrderNum     int32   `json:"iPadOrderNum"`
	DPressOrderPrice float64 `json:"dPressOrderPrice"`
	IPressOrderNum   int32   `json:"iPressOrderNum"`
	DNowPrice        float64 `json:"dNowPrice"`
	IVolume          int32   `json:"iVolume"`
	DBuyAmt          float64 `json:"dBuyAmt"`
	DSellAmt         float64 `json:"dSellAmt"`
}

func (st *HOrderUnit) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderUnit) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DPadOrderPrice, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IPadOrderNum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPressOrderPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IPressOrderNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNowPrice, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IVolume, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuyAmt, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellAmt, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderUnit) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderUnit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderUnit) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DPadOrderPrice, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IPadOrderNum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPressOrderPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IPressOrderNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNowPrice, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IVolume, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuyAmt, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellAmt, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderUnit) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderUnit) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dPadOrderPrice:", st.DPadOrderPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iPadOrderNum:", st.IPadOrderNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPressOrderPrice:", st.DPressOrderPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iPressOrderNum:", st.IPressOrderNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNowPrice:", st.DNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iVolume:", st.IVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuyAmt:", st.DBuyAmt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellAmt:", st.DSellAmt)

	ret = ret + " }"
	return ret
}

// HOrderClassify struct implement
type HOrderClassify struct {
	codec.JceStructBase
	ShtSetcode  int16      `json:"shtSetcode"`
	SCode       string     `json:"sCode"`
	SName       string     `json:"sName"`
	IOrderTime  int32      `json:"iOrderTime"`
	IShtType    int32      `json:"iShtType"`
	StOrderUnit HOrderUnit `json:"stOrderUnit"`
}

func (st *HOrderClassify) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StOrderUnit.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderClassify) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IOrderTime, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IShtType, 5, false)
	if err != nil {
		return err
	}

	err = st.StOrderUnit.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderClassify) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderClassify, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderClassify) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IOrderTime, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IShtType, 5)
	if err != nil {
		return err
	}

	err = st.StOrderUnit.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderClassify) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderClassify) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iOrderTime:", st.IOrderTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iShtType:", st.IShtType)
	ret = ret + ",  "
	ret = ret + "stOrderUnit:" + st.StOrderUnit.Display()

	ret = ret + " }"
	return ret
}

// TagInfo struct implement
type TagInfo struct {
	codec.JceStructBase
	ShtType int16  `json:"shtType"`
	SDesc   string `json:"sDesc"`
}

func (st *TagInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *TagInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtType, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SDesc, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TagInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TagInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TagInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtType, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SDesc, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TagInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *TagInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sDesc:", st.SDesc)

	ret = ret + " }"
	return ret
}

// RelationStock struct implement
type RelationStock struct {
	codec.JceStructBase
	ShtMarket   int16    `json:"shtMarket"`
	SCode       string   `json:"sCode"`
	ShtType     int16    `json:"shtType"`
	SYYInfo     HYYInfo  `json:"sYYInfo"`
	SFXInfo     HFXInfo  `json:"sFXInfo"`
	SKZZInfo    HKZZInfo `json:"sKZZInfo"`
	SName       string   `json:"sName"`
	ShtMainType int16    `json:"shtMainType"`
	ShtSubType  int16    `json:"shtSubType"`
}

func (st *RelationStock) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtType = 0
	st.SYYInfo.ResetDefault()
	st.SFXInfo.ResetDefault()
	st.SKZZInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *RelationStock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 2, false)
	if err != nil {
		return err
	}

	err = st.SYYInfo.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.SFXInfo.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.SKZZInfo.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtMainType, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSubType, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RelationStock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RelationStock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RelationStock) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 2)
	if err != nil {
		return err
	}

	err = st.SYYInfo.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.SFXInfo.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.SKZZInfo.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtMainType, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSubType, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RelationStock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *RelationStock) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + "sYYInfo:" + st.SYYInfo.Display()
	ret = ret + ",  "
	ret = ret + "sFXInfo:" + st.SFXInfo.Display()
	ret = ret + ",  "
	ret = ret + "sKZZInfo:" + st.SKZZInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtMainType:", st.ShtMainType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSubType:", st.ShtSubType)

	ret = ret + " }"
	return ret
}

// RelationStockSimple struct implement
type RelationStockSimple struct {
	codec.JceStructBase
	Market int16      `json:"market"`
	Code   string     `json:"code"`
	Name   string     `json:"name"`
	Type   int16      `json:"type"`
	SType  int16      `json:"sType"`
	RType  int16      `json:"rType"`
	VYy    []HYYInfo  `json:"vYy"`
	VFx    []HFXInfo  `json:"vFx"`
	VKzz   []HKZZInfo `json:"vKzz"`
}

func (st *RelationStockSimple) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.RType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *RelationStockSimple) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.Market, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Code, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Type, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.SType, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.RType, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VYy = make([]HYYInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VYy[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VFx = make([]HFXInfo, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VFx[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VKzz = make([]HKZZInfo, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.VKzz[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RelationStockSimple) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RelationStockSimple, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RelationStockSimple) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.Market, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Code, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Type, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.SType, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.RType, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VYy)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VYy {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VFx)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VFx {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VKzz)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VKzz {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RelationStockSimple) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *RelationStockSimple) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("market:", st.Market)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("code:", st.Code)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("name:", st.Name)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("type:", st.Type)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sType:", st.SType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("rType:", st.RType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vYy:", st.VYy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vFx:", st.VFx)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vKzz:", st.VKzz)

	ret = ret + " }"
	return ret
}

// BdStock struct implement
type BdStock struct {
	codec.JceStructBase
	ShtMarket int16    `json:"shtMarket"`
	SCode     string   `json:"sCode"`
	ShtType   int16    `json:"shtType"`
	SKZZInfo  HKZZInfo `json:"sKZZInfo"`
	SName     string   `json:"sName"`
}

func (st *BdStock) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtType = 0
	st.SKZZInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BdStock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 2, false)
	if err != nil {
		return err
	}

	err = st.SKZZInfo.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BdStock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BdStock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BdStock) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 2)
	if err != nil {
		return err
	}

	err = st.SKZZInfo.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BdStock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *BdStock) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + "sKZZInfo:" + st.SKZZInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)

	ret = ret + " }"
	return ret
}

// HStockBaseInfo struct implement
type HStockBaseInfo struct {
	codec.JceStructBase
	ShtSetcode                   int16              `json:"shtSetcode"`
	SCode                        string             `json:"sCode"`
	SName                        string             `json:"sName"`
	FPeRatio                     float64            `json:"fPeRatio"`
	CCoinType                    int8               `json:"cCoinType"`
	FCirculationStocks           float64            `json:"fCirculationStocks"`
	FTotalMarketValue            float64            `json:"fTotalMarketValue"`
	FCirculationMarketValue      float64            `json:"fCirculationMarketValue"`
	BMarginMark                  int8               `json:"bMarginMark"`
	BSecuritiesMark              int8               `json:"bSecuritiesMark"`
	FPriceRatio                  float64            `json:"fPriceRatio"`
	IType                        int32              `json:"iType"`
	DNetValue                    float64            `json:"dNetValue"`
	DZGB                         float64            `json:"dZGB"`
	DDTSY                        float64            `json:"dDTSY"`
	ETarget                      E_FINANCING_TARGET `json:"eTarget"`
	VTags                        []TagInfo          `json:"vTags"`
	DPreClose                    float64            `json:"dPreClose"`
	DZTPrice                     float64            `json:"dZTPrice"`
	DDTPrice                     float64            `json:"dDTPrice"`
	BDiffRight                   bool               `json:"bDiffRight"`
	BCDR                         bool               `json:"bCDR"`
	BGDR                         bool               `json:"bGDR"`
	IIPODate                     int32              `json:"iIPODate"`
	DFXJ                         float64            `json:"dFXJ"`
	DPE_Static                   float64            `json:"dPE_Static"`
	DPE_TTM                      float64            `json:"dPE_TTM"`
	DDivide_TTM                  float64            `json:"dDivide_TTM"`
	DDivide_LFY                  float64            `json:"dDivide_LFY"`
	DDivideRate_TTM              float64            `json:"dDivideRate_TTM"`
	DDivideRate_LFY              float64            `json:"dDivideRate_LFY"`
	IUnit                        int32              `json:"iUnit"`
	ISubType                     int32              `json:"iSubType"`
	DMGSY                        float64            `json:"dMGSY"`
	DMGSYTTM                     float64            `json:"dMGSYTTM"`
	DFXGB                        float64            `json:"dFXGB"`
	VRelationStock               []RelationStock    `json:"vRelationStock"`
	SNameEx                      string             `json:"sNameEx"`
	VBdStock                     []BdStock          `json:"vBdStock"`
	BDeficit                     bool               `json:"bDeficit"`
	BProControl                  bool               `json:"bProControl"`
	CPrecise                     int8               `json:"cPrecise"`
	FZDLimit                     float32            `json:"fZDLimit"`
	BIpoFlag                     bool               `json:"bIpoFlag"`
	BIpoPrime                    bool               `json:"bIpoPrime"`
	ISwitch                      int32              `json:"iSwitch"`
	DZCZB                        float64            `json:"dZCZB"`
	SHyBlockCode                 string             `json:"sHyBlockCode"`
	SHyBlockName                 string             `json:"sHyBlockName"`
	CFlag                        int8               `json:"cFlag"`
	IEndDate                     uint32             `json:"iEndDate"`
	SRelationBlockId             string             `json:"sRelationBlockId"`
	FMGSYBase                    float32            `json:"fMGSYBase"`
	FJZCSYL                      float32            `json:"fJZCSYL"`
	FYSZZL3Y                     float32            `json:"fYSZZL3Y"`
	FJLRZZL3Y                    float32            `json:"fJLRZZL3Y"`
	StHK                         HStaticDataHK      `json:"stHK"`
	DJZC                         float64            `json:"dJZC"`
	BLXBD                        bool               `json:"bLXBD"`
	SCodeExt                     string             `json:"sCodeExt"`
	BTSZLSR                      bool               `json:"bTSZLSR"`
	ShtCQCXStatus                int16              `json:"shtCQCXStatus"`
	ShtMarketMakeCount           int16              `json:"shtMarketMakeCount"`
	BSellBack                    bool               `json:"bSellBack"`
	BTransferShare               bool               `json:"bTransferShare"`
	FConvStockPrice              float64            `json:"fConvStockPrice"`
	IConvStockEndDate            int32              `json:"iConvStockEndDate"`
	ShtTradeType                 int16              `json:"shtTradeType"`
	FSellBackPrice               float64            `json:"fSellBackPrice"`
	FRedemptionPrice             float64            `json:"fRedemptionPrice"`
	FIssueAmount                 float64            `json:"fIssueAmount"`
	FRemainAmount                float64            `json:"fRemainAmount"`
	SBondRating                  string             `json:"sBondRating"`
	BIsZQXQ                      bool               `json:"bIsZQXQ"`
	CTradePrecise                int8               `json:"cTradePrecise"`
	FSellBackTriggerPrice        float64            `json:"fSellBackTriggerPrice"`
	FForceRedemptionTriggerPrice float64            `json:"fForceRedemptionTriggerPrice"`
	BRegist                      bool               `json:"bRegist"`
}

func (st *HStockBaseInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ETarget = E_FINANCING_TARGET_E_FT_NULL
	st.BDiffRight = true
	st.BCDR = false
	st.BGDR = false
	st.IIPODate = 0
	st.DFXJ = 0.0
	st.IUnit = 100
	st.ISubType = 0
	st.BDeficit = false
	st.BProControl = false
	st.CPrecise = 0
	st.FZDLimit = 0.0
	st.BIpoFlag = false
	st.BIpoPrime = false
	st.ISwitch = 1
	st.DZCZB = 0.0
	st.CFlag = 0
	st.IEndDate = 0
	st.FMGSYBase = 0.0
	st.FJZCSYL = 0.0
	st.FYSZZL3Y = 0.0
	st.FJLRZZL3Y = 0.0
	st.StHK.ResetDefault()
	st.BLXBD = false
	st.BTSZLSR = false
	st.ShtCQCXStatus = 0
	st.ShtMarketMakeCount = 0
	st.BSellBack = false
	st.BTransferShare = false
	st.FConvStockPrice = 0.0
	st.IConvStockEndDate = 0
	st.ShtTradeType = 0
	st.FSellBackPrice = 0.0
	st.FRedemptionPrice = 0.0
	st.FIssueAmount = 0.0
	st.FRemainAmount = 0.0
	st.BIsZQXQ = false
	st.CTradePrecise = 0
	st.FSellBackTriggerPrice = 0.0
	st.FForceRedemptionTriggerPrice = 0.0
	st.BRegist = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBaseInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FPeRatio, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CCoinType, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FCirculationStocks, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FTotalMarketValue, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FCirculationMarketValue, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BMarginMark, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BSecuritiesMark, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FPriceRatio, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IType, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNetValue, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZGB, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDTSY, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ETarget), 16, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(17, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTags = make([]TagInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VTags[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_float64(&st.DPreClose, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZTPrice, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDTPrice, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDiffRight, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCDR, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BGDR, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IIPODate, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFXJ, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPE_Static, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPE_TTM, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivide_TTM, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivide_LFY, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivideRate_TTM, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivideRate_LFY, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUnit, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ISubType, 33, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGSY, 34, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGSYTTM, 35, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFXGB, 36, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(37, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRelationStock = make([]RelationStock, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VRelationStock[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.SNameEx, 38, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(39, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBdStock = make([]BdStock, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.VBdStock[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.BDeficit, 40, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BProControl, 41, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CPrecise, 42, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FZDLimit, 43, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BIpoFlag, 44, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BIpoPrime, 45, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ISwitch, 46, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZCZB, 47, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SHyBlockCode, 48, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SHyBlockName, 49, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CFlag, 50, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.IEndDate, 51, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SRelationBlockId, 52, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FMGSYBase, 53, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FJZCSYL, 54, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FYSZZL3Y, 55, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FJLRZZL3Y, 56, false)
	if err != nil {
		return err
	}

	err = st.StHK.ReadBlock(_is, 57, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJZC, 58, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BLXBD, 59, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCodeExt, 60, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BTSZLSR, 62, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtCQCXStatus, 63, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtMarketMakeCount, 64, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BSellBack, 65, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BTransferShare, 66, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FConvStockPrice, 67, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IConvStockEndDate, 68, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtTradeType, 69, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSellBackPrice, 70, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FRedemptionPrice, 71, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FIssueAmount, 72, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FRemainAmount, 73, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SBondRating, 74, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BIsZQXQ, 75, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CTradePrecise, 76, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FSellBackTriggerPrice, 77, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FForceRedemptionTriggerPrice, 78, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BRegist, 79, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBaseInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBaseInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBaseInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FPeRatio, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CCoinType, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FCirculationStocks, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FTotalMarketValue, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FCirculationMarketValue, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BMarginMark, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BSecuritiesMark, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FPriceRatio, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IType, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNetValue, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZGB, 14)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDTSY, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ETarget), 16)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTags)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTags {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_float64(st.DPreClose, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZTPrice, 19)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDTPrice, 20)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDiffRight, 21)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCDR, 22)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BGDR, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IIPODate, 24)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFXJ, 25)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPE_Static, 26)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPE_TTM, 27)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivide_TTM, 28)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivide_LFY, 29)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivideRate_TTM, 30)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivideRate_LFY, 31)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUnit, 32)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ISubType, 33)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGSY, 34)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGSYTTM, 35)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFXGB, 36)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 37)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRelationStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRelationStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.SNameEx, 38)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 39)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBdStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBdStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.BDeficit, 40)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BProControl, 41)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CPrecise, 42)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FZDLimit, 43)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BIpoFlag, 44)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BIpoPrime, 45)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ISwitch, 46)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZCZB, 47)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SHyBlockCode, 48)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SHyBlockName, 49)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CFlag, 50)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.IEndDate, 51)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SRelationBlockId, 52)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FMGSYBase, 53)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FJZCSYL, 54)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FYSZZL3Y, 55)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FJLRZZL3Y, 56)
	if err != nil {
		return err
	}

	err = st.StHK.WriteBlock(_os, 57)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJZC, 58)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BLXBD, 59)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCodeExt, 60)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BTSZLSR, 62)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtCQCXStatus, 63)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtMarketMakeCount, 64)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BSellBack, 65)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BTransferShare, 66)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FConvStockPrice, 67)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IConvStockEndDate, 68)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtTradeType, 69)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSellBackPrice, 70)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FRedemptionPrice, 71)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FIssueAmount, 72)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FRemainAmount, 73)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SBondRating, 74)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BIsZQXQ, 75)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CTradePrecise, 76)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FSellBackTriggerPrice, 77)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FForceRedemptionTriggerPrice, 78)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BRegist, 79)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBaseInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBaseInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPeRatio:", st.FPeRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cCoinType:", st.CCoinType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fCirculationStocks:", st.FCirculationStocks)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTotalMarketValue:", st.FTotalMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fCirculationMarketValue:", st.FCirculationMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bMarginMark:", st.BMarginMark)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bSecuritiesMark:", st.BSecuritiesMark)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPriceRatio:", st.FPriceRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iType:", st.IType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNetValue:", st.DNetValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZGB:", st.DZGB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDTSY:", st.DDTSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eTarget:", st.ETarget)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vTags:", st.VTags)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreClose:", st.DPreClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZTPrice:", st.DZTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDTPrice:", st.DDTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDiffRight:", st.BDiffRight)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCDR:", st.BCDR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bGDR:", st.BGDR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iIPODate:", st.IIPODate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFXJ:", st.DFXJ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPE_Static:", st.DPE_Static)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPE_TTM:", st.DPE_TTM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivide_TTM:", st.DDivide_TTM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivide_LFY:", st.DDivide_LFY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivideRate_TTM:", st.DDivideRate_TTM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivideRate_LFY:", st.DDivideRate_LFY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUnit:", st.IUnit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSubType:", st.ISubType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGSY:", st.DMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGSYTTM:", st.DMGSYTTM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFXGB:", st.DFXGB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vRelationStock:", st.VRelationStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sNameEx:", st.SNameEx)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBdStock:", st.VBdStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDeficit:", st.BDeficit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bProControl:", st.BProControl)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cPrecise:", st.CPrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fZDLimit:", st.FZDLimit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bIpoFlag:", st.BIpoFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bIpoPrime:", st.BIpoPrime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSwitch:", st.ISwitch)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZCZB:", st.DZCZB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sHyBlockCode:", st.SHyBlockCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sHyBlockName:", st.SHyBlockName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cFlag:", st.CFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDate:", st.IEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sRelationBlockId:", st.SRelationBlockId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMGSYBase:", st.FMGSYBase)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fJZCSYL:", st.FJZCSYL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fYSZZL3Y:", st.FYSZZL3Y)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fJLRZZL3Y:", st.FJLRZZL3Y)
	ret = ret + ",  "
	ret = ret + "stHK:" + st.StHK.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJZC:", st.DJZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bLXBD:", st.BLXBD)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCodeExt:", st.SCodeExt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bTSZLSR:", st.BTSZLSR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtCQCXStatus:", st.ShtCQCXStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtMarketMakeCount:", st.ShtMarketMakeCount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bSellBack:", st.BSellBack)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bTransferShare:", st.BTransferShare)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fConvStockPrice:", st.FConvStockPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iConvStockEndDate:", st.IConvStockEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtTradeType:", st.ShtTradeType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSellBackPrice:", st.FSellBackPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRedemptionPrice:", st.FRedemptionPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fIssueAmount:", st.FIssueAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRemainAmount:", st.FRemainAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sBondRating:", st.SBondRating)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bIsZQXQ:", st.BIsZQXQ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cTradePrecise:", st.CTradePrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSellBackTriggerPrice:", st.FSellBackTriggerPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fForceRedemptionTriggerPrice:", st.FForceRedemptionTriggerPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bRegist:", st.BRegist)

	ret = ret + " }"
	return ret
}

// HStockBaseInfoSimple struct implement
type HStockBaseInfoSimple struct {
	codec.JceStructBase
	Market int16                 `json:"market"`
	Code   string                `json:"code"`
	Type   int32                 `json:"type"`
	M1     map[int32]float64     `json:"m1"`
	M2     map[int32]string      `json:"m2"`
	Vr     []RelationStockSimple `json:"vr"`
	Vt     []TagInfo             `json:"vt"`
}

func (st *HStockBaseInfoSimple) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockBaseInfoSimple) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.Market, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Code, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Type, 2, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M1 = make(map[int32]float64)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 float64

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_float64(&v0, 1, false)
			if err != nil {
				return err
			}

			st.M1[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 4, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M2 = make(map[int32]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 string

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v1, 1, false)
			if err != nil {
				return err
			}

			st.M2[k1] = v1
		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vr = make([]RelationStockSimple, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Vr[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vt = make([]TagInfo, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Vt[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockBaseInfoSimple) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockBaseInfoSimple, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockBaseInfoSimple) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.Market, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Code, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Type, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M1)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.M1 {

		err = _os.Write_int32(k4, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(v4, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M2)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.M2 {

		err = _os.Write_int32(k5, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v5, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Vr)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vr {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Vt)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vt {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockBaseInfoSimple) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockBaseInfoSimple) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("market:", st.Market)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("code:", st.Code)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("type:", st.Type)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m1:", st.M1)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m2:", st.M2)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vr:", st.Vr)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vt:", st.Vt)

	ret = ret + " }"
	return ret
}

// HMarketBaseInfo struct implement
type HMarketBaseInfo struct {
	codec.JceStructBase
	ShtMarket  int16            `json:"shtMarket"`
	VStockInfo []HStockBaseInfo `json:"vStockInfo"`
}

func (st *HMarketBaseInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketBaseInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStockInfo = make([]HStockBaseInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStockInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketBaseInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketBaseInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketBaseInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStockInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStockInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketBaseInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketBaseInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStockInfo:", st.VStockInfo)

	ret = ret + " }"
	return ret
}

// HMarketBaseBuf struct implement
type HMarketBaseBuf struct {
	codec.JceStructBase
	ShtMarket   int16  `json:"shtMarket"`
	VBuf        []int8 `json:"vBuf"`
	ShtCompress int16  `json:"shtCompress"`
	SMD5        string `json:"sMD5"`
}

func (st *HMarketBaseBuf) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketBaseBuf) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuf = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBuf[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBuf, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int16(&st.ShtCompress, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SMD5, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketBaseBuf) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketBaseBuf, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketBaseBuf) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuf)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBuf)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtCompress, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SMD5, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketBaseBuf) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketBaseBuf) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuf:", st.VBuf)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtCompress:", st.ShtCompress)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sMD5:", st.SMD5)

	ret = ret + " }"
	return ret
}

// StockStaticData struct implement
type StockStaticData struct {
	codec.JceStructBase
	ShtMarket       int16              `json:"shtMarket"`
	SCode           string             `json:"sCode"`
	SName           string             `json:"sName"`
	ShtType         int16              `json:"shtType"`
	DLtg            float64            `json:"dLtg"`
	DZgb            float64            `json:"dZgb"`
	DJzc            float64            `json:"dJzc"`
	DNetValue       float64            `json:"dNetValue"`
	DDTSY           float64            `json:"dDTSY"`
	D5SumVol        float64            `json:"d5SumVol"`
	DZTPrice        float64            `json:"dZTPrice"`
	DDTPrice        float64            `json:"dDTPrice"`
	DPreClose       float64            `json:"dPreClose"`
	BMarginMark     int8               `json:"bMarginMark"`
	BSecuritiesMark int8               `json:"bSecuritiesMark"`
	CCoinType       int8               `json:"cCoinType"`
	ETarget         E_FINANCING_TARGET `json:"eTarget"`
	VTags           []TagInfo          `json:"vTags"`
	IIPODate        int32              `json:"iIPODate"`
	DFXJ            float64            `json:"dFXJ"`
}

func (st *StockStaticData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ETarget = E_FINANCING_TARGET_E_FT_NULL
	st.IIPODate = 0
	st.DFXJ = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *StockStaticData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLtg, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZgb, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJzc, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNetValue, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDTSY, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D5SumVol, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZTPrice, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDTPrice, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreClose, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BMarginMark, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BSecuritiesMark, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CCoinType, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ETarget), 16, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(17, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTags = make([]TagInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VTags[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IIPODate, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFXJ, 19, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StockStaticData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StockStaticData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StockStaticData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLtg, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZgb, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJzc, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNetValue, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDTSY, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D5SumVol, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZTPrice, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDTPrice, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreClose, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BMarginMark, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BSecuritiesMark, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CCoinType, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ETarget), 16)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTags)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTags {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IIPODate, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFXJ, 19)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StockStaticData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *StockStaticData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLtg:", st.DLtg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZgb:", st.DZgb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJzc:", st.DJzc)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNetValue:", st.DNetValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDTSY:", st.DDTSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d5SumVol:", st.D5SumVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZTPrice:", st.DZTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDTPrice:", st.DDTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreClose:", st.DPreClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bMarginMark:", st.BMarginMark)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bSecuritiesMark:", st.BSecuritiesMark)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cCoinType:", st.CCoinType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eTarget:", st.ETarget)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vTags:", st.VTags)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iIPODate:", st.IIPODate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFXJ:", st.DFXJ)

	ret = ret + " }"
	return ret
}

// HStockSimHq struct implement
type HStockSimHq struct {
	codec.JceStructBase
	FNowPrice   float64        `json:"fNowPrice"`
	FOpen       float64        `json:"fOpen"`
	FHigh       float64        `json:"fHigh"`
	FLow        float64        `json:"fLow"`
	FClose      float64        `json:"fClose"`
	LVolume     int64          `json:"lVolume"`
	FAmount     float64        `json:"fAmount"`
	FChgValue   float64        `json:"fChgValue"`
	FChgRatio   float64        `json:"fChgRatio"`
	FZhenfu     float64        `json:"fZhenfu"`
	ZtData      SZTData        `json:"ztData"`
	LeadBlock   BlockBasicInfo `json:"leadBlock"`
	DOpenAmount float64        `json:"dOpenAmount"`
	LOpenVolume int64          `json:"lOpenVolume"`
}

func (st *HStockSimHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ZtData.ResetDefault()
	st.LeadBlock.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockSimHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.FNowPrice, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FOpen, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHigh, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FLow, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FClose, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FAmount, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChgValue, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChgRatio, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FZhenfu, 10, false)
	if err != nil {
		return err
	}

	err = st.ZtData.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = st.LeadBlock.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOpenAmount, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LOpenVolume, 14, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockSimHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockSimHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockSimHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.FNowPrice, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FOpen, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHigh, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FLow, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FClose, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FAmount, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChgValue, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChgRatio, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FZhenfu, 10)
	if err != nil {
		return err
	}

	err = st.ZtData.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = st.LeadBlock.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOpenAmount, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LOpenVolume, 14)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockSimHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockSimHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fOpen:", st.FOpen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHigh:", st.FHigh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLow:", st.FLow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fClose:", st.FClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAmount:", st.FAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChgValue:", st.FChgValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChgRatio:", st.FChgRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fZhenfu:", st.FZhenfu)
	ret = ret + ",  "
	ret = ret + "ztData:" + st.ZtData.Display()
	ret = ret + ",  "
	ret = ret + "leadBlock:" + st.LeadBlock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOpenAmount:", st.DOpenAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lOpenVolume:", st.LOpenVolume)

	ret = ret + " }"
	return ret
}

// HStockQhHq struct implement
type HStockQhHq struct {
	codec.JceStructBase
	DSettlementPrice    float64 `json:"dSettlementPrice"`
	DPreSettlementPrice float64 `json:"dPreSettlementPrice"`
	DOpenInterest       float64 `json:"dOpenInterest"`
	DPreOpenInterest    float64 `json:"dPreOpenInterest"`
	IEveryHand          int32   `json:"iEveryHand"`
	DDayIncrease        float64 `json:"dDayIncrease"`
}

func (st *HStockQhHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockQhHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DSettlementPrice, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreSettlementPrice, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOpenInterest, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreOpenInterest, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEveryHand, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDayIncrease, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockQhHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockQhHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockQhHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DSettlementPrice, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreSettlementPrice, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOpenInterest, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreOpenInterest, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEveryHand, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDayIncrease, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockQhHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockQhHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dSettlementPrice:", st.DSettlementPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreSettlementPrice:", st.DPreSettlementPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOpenInterest:", st.DOpenInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreOpenInterest:", st.DPreOpenInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEveryHand:", st.IEveryHand)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDayIncrease:", st.DDayIncrease)

	ret = ret + " }"
	return ret
}

// HStockTB struct implement
type HStockTB struct {
	codec.JceStructBase
	ShtZRType          int16  `json:"shtZRType"`
	ShtZRStatus        int16  `json:"shtZRStatus"`
	ShtFC              int16  `json:"shtFC"`
	ShtType            int16  `json:"shtType"`
	ShtTpStatus        int16  `json:"shtTpStatus"`
	ShtCQCXStatus      int16  `json:"shtCQCXStatus"`
	CDiffRight         int8   `json:"cDiffRight"`
	ShtMarketMakeCount uint16 `json:"shtMarketMakeCount"`
	ShtFXMethod        int16  `json:"shtFXMethod"`
}

func (st *HStockTB) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtZRType = 0
	st.ShtZRStatus = 0
	st.ShtFC = 0
	st.ShtType = 0
	st.ShtTpStatus = 0
	st.ShtCQCXStatus = 0
	st.CDiffRight = 0
	st.ShtMarketMakeCount = 0
	st.ShtFXMethod = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockTB) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtZRType, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtZRStatus, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtFC, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtTpStatus, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtCQCXStatus, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CDiffRight, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint16(&st.ShtMarketMakeCount, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtFXMethod, 9, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockTB) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockTB, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockTB) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtZRType, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtZRStatus, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtFC, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtTpStatus, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtCQCXStatus, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CDiffRight, 7)
	if err != nil {
		return err
	}

	err = _os.Write_uint16(st.ShtMarketMakeCount, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtFXMethod, 9)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockTB) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockTB) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtZRType:", st.ShtZRType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtZRStatus:", st.ShtZRStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtFC:", st.ShtFC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtTpStatus:", st.ShtTpStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtCQCXStatus:", st.ShtCQCXStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cDiffRight:", st.CDiffRight)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtMarketMakeCount:", st.ShtMarketMakeCount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtFXMethod:", st.ShtFXMethod)

	ret = ret + " }"
	return ret
}

// HStockHK struct implement
type HStockHK struct {
	codec.JceStructBase
	DBalancePrice       float64 `json:"dBalancePrice"`
	LBalanceVol         int64   `json:"lBalanceVol"`
	DReferencePrice     float64 `json:"dReferencePrice"`
	DLowLimitPrice      float64 `json:"dLowLimitPrice"`
	DHighLimitPrice     float64 `json:"dHighLimitPrice"`
	CDirection          int8    `json:"cDirection"`
	LImbalanceVol       int64   `json:"lImbalanceVol"`
	DBuyLowLimitPrice   float64 `json:"dBuyLowLimitPrice"`
	DBuyHighLimitPrice  float64 `json:"dBuyHighLimitPrice"`
	DSellLowLimitPrice  float64 `json:"dSellLowLimitPrice"`
	DSellHighLimitPrice float64 `json:"dSellHighLimitPrice"`
}

func (st *HStockHK) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.DBalancePrice = 0.0
	st.LBalanceVol = 0
	st.DReferencePrice = 0.0
	st.DLowLimitPrice = 0.0
	st.DHighLimitPrice = 0.0
	st.CDirection = 0
	st.LImbalanceVol = 0
	st.DBuyLowLimitPrice = 0.0
	st.DBuyHighLimitPrice = 0.0
	st.DSellLowLimitPrice = 0.0
	st.DSellHighLimitPrice = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockHK) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DBalancePrice, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBalanceVol, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DReferencePrice, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLowLimitPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHighLimitPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CDirection, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LImbalanceVol, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuyLowLimitPrice, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuyHighLimitPrice, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellLowLimitPrice, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellHighLimitPrice, 10, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockHK) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockHK, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockHK) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DBalancePrice, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBalanceVol, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DReferencePrice, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLowLimitPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHighLimitPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CDirection, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LImbalanceVol, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuyLowLimitPrice, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuyHighLimitPrice, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellLowLimitPrice, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellHighLimitPrice, 10)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockHK) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockHK) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dBalancePrice:", st.DBalancePrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBalanceVol:", st.LBalanceVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dReferencePrice:", st.DReferencePrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLowLimitPrice:", st.DLowLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHighLimitPrice:", st.DHighLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cDirection:", st.CDirection)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lImbalanceVol:", st.LImbalanceVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuyLowLimitPrice:", st.DBuyLowLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuyHighLimitPrice:", st.DBuyHighLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellLowLimitPrice:", st.DSellLowLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellHighLimitPrice:", st.DSellHighLimitPrice)

	ret = ret + " }"
	return ret
}

// HStockZQHq struct implement
type HStockZQHq struct {
	codec.JceStructBase
	FRoRPerYear float32 `json:"fRoRPerYear"`
	DRatePer10w float64 `json:"dRatePer10w"`
	DRatePer1k  float64 `json:"dRatePer1k"`
	ShtDays     int16   `json:"shtDays"`
	ShtZkDays   int16   `json:"shtZkDays"`
	IJxFrom     int32   `json:"iJxFrom"`
	IJxTo       int32   `json:"iJxTo"`
	ITodayBuy   int32   `json:"iTodayBuy"`
	IZjUserDay  int32   `json:"iZjUserDay"`
	IZjFetchDay int32   `json:"iZjFetchDay"`
	FGZJZ       float32 `json:"fGZJZ"`
	FYJL        float32 `json:"fYJL"`
	DBdPrice    float64 `json:"dBdPrice"`
}

func (st *HStockZQHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.FRoRPerYear = 0
	st.DRatePer10w = 0
	st.DRatePer1k = 0
	st.ShtDays = 0
	st.ShtZkDays = 0
	st.IJxFrom = 0
	st.IJxTo = 0
	st.ITodayBuy = 0
	st.IZjUserDay = 0
	st.IZjFetchDay = 0
	st.FGZJZ = 0.0
	st.FYJL = 0.0
	st.DBdPrice = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockZQHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float32(&st.FRoRPerYear, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRatePer10w, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRatePer1k, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDays, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtZkDays, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IJxFrom, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IJxTo, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITodayBuy, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZjUserDay, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZjFetchDay, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FGZJZ, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FYJL, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBdPrice, 12, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockZQHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockZQHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockZQHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float32(st.FRoRPerYear, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRatePer10w, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRatePer1k, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDays, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtZkDays, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IJxFrom, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IJxTo, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITodayBuy, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZjUserDay, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZjFetchDay, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FGZJZ, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FYJL, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBdPrice, 12)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockZQHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockZQHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fRoRPerYear:", st.FRoRPerYear)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRatePer10w:", st.DRatePer10w)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRatePer1k:", st.DRatePer1k)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDays:", st.ShtDays)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtZkDays:", st.ShtZkDays)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iJxFrom:", st.IJxFrom)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iJxTo:", st.IJxTo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTodayBuy:", st.ITodayBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZjUserDay:", st.IZjUserDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZjFetchDay:", st.IZjFetchDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fGZJZ:", st.FGZJZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fYJL:", st.FYJL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBdPrice:", st.DBdPrice)

	ret = ret + " }"
	return ret
}

// HStockExHq struct implement
type HStockExHq struct {
	codec.JceStructBase
	LNowVol            int64     `json:"lNowVol"`
	LInside            int64     `json:"lInside"`
	LOutside           int64     `json:"lOutside"`
	VBuyp              []float64 `json:"vBuyp"`
	VBuyv              []int64   `json:"vBuyv"`
	VSellp             []float64 `json:"vSellp"`
	VSellv             []int64   `json:"vSellv"`
	FAveragePrice      float64   `json:"fAveragePrice"`
	FZTPrice           float64   `json:"fZTPrice"`
	FDTPrice           float64   `json:"fDTPrice"`
	FTurnoverRate      float64   `json:"fTurnoverRate"`
	ITradeMin          int32     `json:"iTradeMin"`
	ITradeDate         int32     `json:"iTradeDate"`
	ITradeTime         int32     `json:"iTradeTime"`
	BZDMark            int8      `json:"bZDMark"`
	BTransactionStatus int8      `json:"bTransactionStatus"`
	VBuyNum            []int32   `json:"vBuyNum"`
	VSellNum           []int32   `json:"vSellNum"`
	IBSFlag            int32     `json:"iBSFlag"`
	DPeRatio           float64   `json:"dPeRatio"`
	DPriceRatio        float64   `json:"dPriceRatio"`
	DZSZ               float64   `json:"dZSZ"`
	DLTZS              float64   `json:"dLTZS"`
	FJTPe              float32   `json:"fJTPe"`
	FTTMPe             float32   `json:"fTTMPe"`
}

func (st *HStockExHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.FJTPe = 0.0
	st.FTTMPe = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockExHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LNowVol, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LInside, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LOutside, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuyp = make([]float64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_float64(&st.VBuyp[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuyv = make([]int64, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int64(&st.VBuyv[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSellp = make([]float64, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_float64(&st.VSellp[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSellv = make([]int64, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = _is.Read_int64(&st.VSellv[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_float64(&st.FAveragePrice, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FZTPrice, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDTPrice, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FTurnoverRate, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeMin, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeDate, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeTime, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BZDMark, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BTransactionStatus, 21, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(50, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuyNum = make([]int32, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = _is.Read_int32(&st.VBuyNum[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(51, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSellNum = make([]int32, length)
			for i5, e5 := int32(0), length; i5 < e5; i5++ {

				err = _is.Read_int32(&st.VSellNum[i5], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IBSFlag, 52, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPeRatio, 53, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPriceRatio, 54, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZSZ, 55, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLTZS, 56, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FJTPe, 57, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FTTMPe, 58, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockExHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockExHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockExHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LNowVol, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LInside, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LOutside, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuyp)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBuyp {

		err = _os.Write_float64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuyv)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBuyv {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSellp)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSellp {

		err = _os.Write_float64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSellv)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSellv {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_float64(st.FAveragePrice, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FZTPrice, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDTPrice, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FTurnoverRate, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeMin, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeDate, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeTime, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BZDMark, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BTransactionStatus, 21)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 50)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuyNum)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBuyNum {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 51)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSellNum)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSellNum {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IBSFlag, 52)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPeRatio, 53)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPriceRatio, 54)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZSZ, 55)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLTZS, 56)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FJTPe, 57)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FTTMPe, 58)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockExHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockExHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lNowVol:", st.LNowVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lInside:", st.LInside)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lOutside:", st.LOutside)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuyp:", st.VBuyp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuyv:", st.VBuyv)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSellp:", st.VSellp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSellv:", st.VSellv)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAveragePrice:", st.FAveragePrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fZTPrice:", st.FZTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDTPrice:", st.FDTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTurnoverRate:", st.FTurnoverRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeMin:", st.ITradeMin)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeDate:", st.ITradeDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeTime:", st.ITradeTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bZDMark:", st.BZDMark)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bTransactionStatus:", st.BTransactionStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuyNum:", st.VBuyNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSellNum:", st.VSellNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iBSFlag:", st.IBSFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPeRatio:", st.DPeRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPriceRatio:", st.DPriceRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZSZ:", st.DZSZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLTZS:", st.DLTZS)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fJTPe:", st.FJTPe)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTTMPe:", st.FTTMPe)

	ret = ret + " }"
	return ret
}

// HStockDeriveHq struct implement
type HStockDeriveHq struct {
	codec.JceStructBase
	DLiangBi             float64              `json:"dLiangBi"`
	DUpSpeed             float64              `json:"dUpSpeed"`
	LTradeNum            int64                `json:"lTradeNum"`
	DBuyAvg              float64              `json:"dBuyAvg"`
	DSellAvg             float64              `json:"dSellAvg"`
	LBuyPriceNum         int64                `json:"lBuyPriceNum"`
	LSellPriceNum        int64                `json:"lSellPriceNum"`
	LBuyVol              int64                `json:"lBuyVol"`
	LSellVol             int64                `json:"lSellVol"`
	EStatus              E_STOCK_TRADE_STATUS `json:"eStatus"`
	DMainMoneyInflow5Min float64              `json:"dMainMoneyInflow5Min"`
	UiItemNum            uint32               `json:"uiItemNum"`
	LAtpVolume           int64                `json:"lAtpVolume"`
	DAtpAmount           float64              `json:"dAtpAmount"`
	IGzhgAvgBP           int32                `json:"iGzhgAvgBP"`
	IGzhgBP              int32                `json:"iGzhgBP"`
	DIOPV                float64              `json:"dIOPV"`
	D10DayReturnRate     float64              `json:"d10DayReturnRate"`
	D52WeekMax           float64              `json:"d52WeekMax"`
	D52WeekMin           float64              `json:"d52WeekMin"`
	DHistoryMax          float64              `json:"dHistoryMax"`
	DHistoryMin          float64              `json:"dHistoryMin"`
	D3DayNetInflow       float64              `json:"d3DayNetInflow"`
	D5DayNetInflow       float64              `json:"d5DayNetInflow"`
	D10DayNetInflow      float64              `json:"d10DayNetInflow"`
	D20DayNetInflow      float64              `json:"d20DayNetInflow"`
	DMatchPrice          float64              `json:"dMatchPrice"`
	LMatchVol            int64                `json:"lMatchVol"`
	LNoMatchVol          int64                `json:"lNoMatchVol"`
	D5DayChg             float64              `json:"d5DayChg"`
	D10DayChg            float64              `json:"d10DayChg"`
	D20DayChg            float64              `json:"d20DayChg"`
	DMonthChg            float64              `json:"dMonthChg"`
	DSeasonChg           float64              `json:"dSeasonChg"`
	DYearChg             float64              `json:"dYearChg"`
	BActBSFlag           int8                 `json:"bActBSFlag"`
	DRefBeginPrice       float64              `json:"dRefBeginPrice"`
	DRefEndPrice         float64              `json:"dRefEndPrice"`
	DThisYearChg         float64              `json:"dThisYearChg"`
	DLztzj               float64              `json:"dLztzj"`
	Dldtzj               float64              `json:"dldtzj"`
	FLastChg             float32              `json:"fLastChg"`
	FWeiBi               float32              `json:"fWeiBi"`
	BBlockTrade          bool                 `json:"bBlockTrade"`
	DTotalChg            float64              `json:"dTotalChg"`
	DCfgYjSz             float64              `json:"dCfgYjSz"`
	DCfgZjSz             float64              `json:"dCfgZjSz"`
	DCfgSz               float64              `json:"dCfgSz"`
	UiLYBCurrDayRank     uint32               `json:"uiLYBCurrDayRank"`
	UiLYBPreDayRank      uint32               `json:"uiLYBPreDayRank"`
	FOpenChg             float32              `json:"fOpenChg"`
	FAucLast             float32              `json:"fAucLast"`
	IAucVol              int32                `json:"iAucVol"`
	FAucTurn             float32              `json:"fAucTurn"`
	FHTB                 float32              `json:"fHTB"`
	FGJB                 float32              `json:"fGJB"`
	F10DayHighChg        float32              `json:"f10DayHighChg"`
	D60DayChg            float64              `json:"d60DayChg"`
	D120DayChg           float64              `json:"d120DayChg"`
	D250DayChg           float64              `json:"d250DayChg"`
	DFinancingRatio      float64              `json:"dFinancingRatio"`
	D3DayChg             float64              `json:"d3DayChg"`
}

func (st *HStockDeriveHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.LAtpVolume = 0
	st.DAtpAmount = 0
	st.IGzhgAvgBP = 0
	st.IGzhgBP = 0
	st.DIOPV = 0.0
	st.D10DayReturnRate = 0.0
	st.D52WeekMax = 0.0
	st.D52WeekMin = 0.0
	st.DHistoryMax = 0.0
	st.DHistoryMin = 0.0
	st.D3DayNetInflow = 0.0
	st.D5DayNetInflow = 0.0
	st.D10DayNetInflow = 0.0
	st.D20DayNetInflow = 0.0
	st.DMatchPrice = 0.0
	st.LMatchVol = 0
	st.LNoMatchVol = 0
	st.D5DayChg = 0.0
	st.D10DayChg = 0.0
	st.D20DayChg = 0.0
	st.DMonthChg = 0.0
	st.DSeasonChg = 0.0
	st.DYearChg = 0.0
	st.BActBSFlag = 0
	st.DRefBeginPrice = 0.0
	st.DRefEndPrice = 0.0
	st.DThisYearChg = 0.0
	st.DLztzj = 0.0
	st.Dldtzj = 0.0
	st.FLastChg = 0.0
	st.FWeiBi = 0.0
	st.BBlockTrade = false
	st.DTotalChg = 0.0
	st.DCfgYjSz = 0.0
	st.DCfgZjSz = 0.0
	st.DCfgSz = 0.0
	st.UiLYBCurrDayRank = 0
	st.UiLYBPreDayRank = 0
	st.FOpenChg = 0.0
	st.FAucLast = 0.0
	st.IAucVol = 0
	st.FAucTurn = 0.0
	st.FHTB = 0.0
	st.FGJB = 0.0
	st.F10DayHighChg = 0.0
	st.D60DayChg = 0.0
	st.D120DayChg = 0.0
	st.D250DayChg = 0.0
	st.DFinancingRatio = 0.0
	st.D3DayChg = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDeriveHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DLiangBi, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DUpSpeed, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTradeNum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuyAvg, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellAvg, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyPriceNum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellPriceNum, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyVol, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellVol, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStatus), 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMainMoneyInflow5Min, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiItemNum, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LAtpVolume, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAtpAmount, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IGzhgAvgBP, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IGzhgBP, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DIOPV, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D10DayReturnRate, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D52WeekMax, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D52WeekMin, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHistoryMax, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHistoryMin, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D3DayNetInflow, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D5DayNetInflow, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D10DayNetInflow, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D20DayNetInflow, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMatchPrice, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LMatchVol, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LNoMatchVol, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D5DayChg, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D10DayChg, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D20DayChg, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMonthChg, 33, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSeasonChg, 34, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYearChg, 35, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BActBSFlag, 36, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRefBeginPrice, 37, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRefEndPrice, 38, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DThisYearChg, 39, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLztzj, 40, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Dldtzj, 41, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FLastChg, 42, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FWeiBi, 43, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BBlockTrade, 44, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTotalChg, 45, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCfgYjSz, 46, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCfgZjSz, 47, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCfgSz, 48, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiLYBCurrDayRank, 49, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiLYBPreDayRank, 50, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FOpenChg, 51, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FAucLast, 52, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IAucVol, 53, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FAucTurn, 54, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FHTB, 55, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FGJB, 56, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.F10DayHighChg, 57, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D60DayChg, 58, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D120DayChg, 59, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D250DayChg, 60, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFinancingRatio, 61, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D3DayChg, 62, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDeriveHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDeriveHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDeriveHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DLiangBi, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DUpSpeed, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTradeNum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuyAvg, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellAvg, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyPriceNum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellPriceNum, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyVol, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellVol, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStatus), 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMainMoneyInflow5Min, 10)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiItemNum, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LAtpVolume, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAtpAmount, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IGzhgAvgBP, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IGzhgBP, 16)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DIOPV, 17)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D10DayReturnRate, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D52WeekMax, 19)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D52WeekMin, 20)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHistoryMax, 21)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHistoryMin, 22)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D3DayNetInflow, 23)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D5DayNetInflow, 24)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D10DayNetInflow, 25)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D20DayNetInflow, 26)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMatchPrice, 27)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LMatchVol, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LNoMatchVol, 29)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D5DayChg, 30)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D10DayChg, 31)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D20DayChg, 32)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMonthChg, 33)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSeasonChg, 34)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYearChg, 35)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BActBSFlag, 36)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRefBeginPrice, 37)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRefEndPrice, 38)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DThisYearChg, 39)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLztzj, 40)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Dldtzj, 41)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FLastChg, 42)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FWeiBi, 43)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BBlockTrade, 44)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTotalChg, 45)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCfgYjSz, 46)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCfgZjSz, 47)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCfgSz, 48)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiLYBCurrDayRank, 49)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiLYBPreDayRank, 50)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FOpenChg, 51)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FAucLast, 52)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IAucVol, 53)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FAucTurn, 54)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FHTB, 55)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FGJB, 56)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.F10DayHighChg, 57)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D60DayChg, 58)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D120DayChg, 59)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D250DayChg, 60)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFinancingRatio, 61)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D3DayChg, 62)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDeriveHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDeriveHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dLiangBi:", st.DLiangBi)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dUpSpeed:", st.DUpSpeed)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTradeNum:", st.LTradeNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuyAvg:", st.DBuyAvg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellAvg:", st.DSellAvg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyPriceNum:", st.LBuyPriceNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellPriceNum:", st.LSellPriceNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyVol:", st.LBuyVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellVol:", st.LSellVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMainMoneyInflow5Min:", st.DMainMoneyInflow5Min)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiItemNum:", st.UiItemNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lAtpVolume:", st.LAtpVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAtpAmount:", st.DAtpAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iGzhgAvgBP:", st.IGzhgAvgBP)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iGzhgBP:", st.IGzhgBP)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dIOPV:", st.DIOPV)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d10DayReturnRate:", st.D10DayReturnRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d52WeekMax:", st.D52WeekMax)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d52WeekMin:", st.D52WeekMin)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHistoryMax:", st.DHistoryMax)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHistoryMin:", st.DHistoryMin)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d3DayNetInflow:", st.D3DayNetInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d5DayNetInflow:", st.D5DayNetInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d10DayNetInflow:", st.D10DayNetInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d20DayNetInflow:", st.D20DayNetInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMatchPrice:", st.DMatchPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lMatchVol:", st.LMatchVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lNoMatchVol:", st.LNoMatchVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d5DayChg:", st.D5DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d10DayChg:", st.D10DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d20DayChg:", st.D20DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMonthChg:", st.DMonthChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSeasonChg:", st.DSeasonChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYearChg:", st.DYearChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bActBSFlag:", st.BActBSFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRefBeginPrice:", st.DRefBeginPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRefEndPrice:", st.DRefEndPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dThisYearChg:", st.DThisYearChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLztzj:", st.DLztzj)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dldtzj:", st.Dldtzj)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLastChg:", st.FLastChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fWeiBi:", st.FWeiBi)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bBlockTrade:", st.BBlockTrade)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTotalChg:", st.DTotalChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCfgYjSz:", st.DCfgYjSz)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCfgZjSz:", st.DCfgZjSz)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCfgSz:", st.DCfgSz)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiLYBCurrDayRank:", st.UiLYBCurrDayRank)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiLYBPreDayRank:", st.UiLYBPreDayRank)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fOpenChg:", st.FOpenChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAucLast:", st.FAucLast)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iAucVol:", st.IAucVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAucTurn:", st.FAucTurn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHTB:", st.FHTB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fGJB:", st.FGJB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f10DayHighChg:", st.F10DayHighChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d60DayChg:", st.D60DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d120DayChg:", st.D120DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d250DayChg:", st.D250DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFinancingRatio:", st.DFinancingRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d3DayChg:", st.D3DayChg)

	ret = ret + " }"
	return ret
}

// HBlockIndexHq struct implement
type HBlockIndexHq struct {
	codec.JceStructBase
	SHeadMarket             int16   `json:"sHeadMarket"`
	SHeadCode               string  `json:"sHeadCode"`
	SHeadName               string  `json:"sHeadName"`
	FHeadNow                float64 `json:"fHeadNow"`
	FHeadClose              float64 `json:"fHeadClose"`
	IStockNum               int32   `json:"iStockNum"`
	IEqualNum               int32   `json:"iEqualNum"`
	IZTNum                  int32   `json:"iZTNum"`
	IUpNum                  int32   `json:"iUpNum"`
	IDownNum                int32   `json:"iDownNum"`
	DTotalMarketValue       float64 `json:"dTotalMarketValue"`
	DCirculationMarketValue float64 `json:"dCirculationMarketValue"`
	IUpNDay                 int32   `json:"iUpNDay"`
	D3DayChg                float64 `json:"d3DayChg"`
	D5DayChg                float64 `json:"d5DayChg"`
	D10DayChg               float64 `json:"d10DayChg"`
	DLead                   float64 `json:"dLead"`
	DHeadChgRatio           float64 `json:"dHeadChgRatio"`
	DUpNumRatio             float64 `json:"dUpNumRatio"`
	D20DayChg               float64 `json:"d20DayChg"`
}

func (st *HBlockIndexHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.DLead = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HBlockIndexHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.SHeadMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SHeadCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SHeadName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHeadNow, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHeadClose, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStockNum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEqualNum, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZTNum, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpNum, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDownNum, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTotalMarketValue, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCirculationMarketValue, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpNDay, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D3DayChg, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D5DayChg, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D10DayChg, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLead, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHeadChgRatio, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DUpNumRatio, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D20DayChg, 19, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBlockIndexHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBlockIndexHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBlockIndexHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.SHeadMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SHeadCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SHeadName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHeadNow, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHeadClose, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStockNum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEqualNum, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZTNum, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpNum, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDownNum, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTotalMarketValue, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCirculationMarketValue, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpNDay, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D3DayChg, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D5DayChg, 14)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D10DayChg, 15)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLead, 16)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHeadChgRatio, 17)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DUpNumRatio, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D20DayChg, 19)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBlockIndexHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBlockIndexHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sHeadMarket:", st.SHeadMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sHeadCode:", st.SHeadCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sHeadName:", st.SHeadName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHeadNow:", st.FHeadNow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHeadClose:", st.FHeadClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStockNum:", st.IStockNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEqualNum:", st.IEqualNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZTNum:", st.IZTNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpNum:", st.IUpNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDownNum:", st.IDownNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTotalMarketValue:", st.DTotalMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCirculationMarketValue:", st.DCirculationMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpNDay:", st.IUpNDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d3DayChg:", st.D3DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d5DayChg:", st.D5DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d10DayChg:", st.D10DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLead:", st.DLead)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHeadChgRatio:", st.DHeadChgRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dUpNumRatio:", st.DUpNumRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d20DayChg:", st.D20DayChg)

	ret = ret + " }"
	return ret
}

// HStockCwHq struct implement
type HStockCwHq struct {
	codec.JceStructBase
	DMGSY     float64 `json:"dMGSY"`
	DMGJZC    float64 `json:"dMGJZC"`
	DJZCSYL   float64 `json:"dJZCSYL"`
	DYSZZL3Y  float64 `json:"dYSZZL3Y"`
	DJLSZZL3Y float64 `json:"dJLSZZL3Y"`
}

func (st *HStockCwHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockCwHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DMGSY, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGJZC, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJZCSYL, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYSZZL3Y, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJLSZZL3Y, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockCwHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockCwHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockCwHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DMGSY, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGJZC, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJZCSYL, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYSZZL3Y, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJLSZZL3Y, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockCwHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockCwHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dMGSY:", st.DMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGJZC:", st.DMGJZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJZCSYL:", st.DJZCSYL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYSZZL3Y:", st.DYSZZL3Y)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJLSZZL3Y:", st.DJLSZZL3Y)

	ret = ret + " }"
	return ret
}

// HOptionHq struct implement
type HOptionHq struct {
	codec.JceStructBase
	FImpliedVolatility float32 `json:"fImpliedVolatility"`
	FDelta             float32 `json:"fDelta"`
	FGamma             float32 `json:"fGamma"`
	FVega              float32 `json:"fVega"`
	FTheta             float32 `json:"fTheta"`
	FRho               float32 `json:"fRho"`
	FLeverageRatio     float32 `json:"fLeverageRatio"`
	FRealLeverageRatio float32 `json:"fRealLeverageRatio"`
	FInstrinsicValue   float32 `json:"fInstrinsicValue"`
	FPremiumRatio      float32 `json:"fPremiumRatio"`
	FXushiDu           float32 `json:"fXushiDu"`
	FHisVol            float32 `json:"fHisVol"`
}

func (st *HOptionHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float32(&st.FImpliedVolatility, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FDelta, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FGamma, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FVega, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FTheta, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FRho, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FLeverageRatio, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FRealLeverageRatio, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FInstrinsicValue, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FPremiumRatio, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FXushiDu, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FHisVol, 11, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float32(st.FImpliedVolatility, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FDelta, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FGamma, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FVega, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FTheta, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FRho, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FLeverageRatio, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FRealLeverageRatio, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FInstrinsicValue, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FPremiumRatio, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FXushiDu, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FHisVol, 11)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fImpliedVolatility:", st.FImpliedVolatility)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDelta:", st.FDelta)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fGamma:", st.FGamma)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fVega:", st.FVega)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTheta:", st.FTheta)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRho:", st.FRho)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLeverageRatio:", st.FLeverageRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRealLeverageRatio:", st.FRealLeverageRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fInstrinsicValue:", st.FInstrinsicValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPremiumRatio:", st.FPremiumRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fXushiDu:", st.FXushiDu)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHisVol:", st.FHisVol)

	ret = ret + " }"
	return ret
}

// HStockHq struct implement
type HStockHq struct {
	codec.JceStructBase
	ShtPrecise uint16                     `json:"shtPrecise"`
	ShtSetcode int16                      `json:"shtSetcode"`
	SCode      string                     `json:"sCode"`
	SName      string                     `json:"sName"`
	StSimHq    HStockSimHq                `json:"stSimHq"`
	StExHq     HStockExHq                 `json:"stExHq"`
	StQhHq     HStockQhHq                 `json:"stQhHq"`
	StMF       HTolMoneyFlow              `json:"stMF"`
	StDDE      HDDERank                   `json:"stDDE"`
	StBlockHq  HBlockIndexHq              `json:"stBlockHq"`
	StDeriveHq HStockDeriveHq             `json:"stDeriveHq"`
	StCwHq     HStockCwHq                 `json:"stCwHq"`
	StZQhq     HStockZQHq                 `json:"stZQhq"`
	St3MinMF   HTolMoneyFlow              `json:"st3MinMF"`
	St5MinMF   HTolMoneyFlow              `json:"st5MinMF"`
	St10MinMF  HTolMoneyFlow              `json:"st10MinMF"`
	St30MinMF  HTolMoneyFlow              `json:"st30MinMF"`
	St60MinMF  HTolMoneyFlow              `json:"st60MinMF"`
	StTB       HStockTB                   `json:"stTB"`
	StDayMF    HTolMoneyFlowSet           `json:"stDayMF"`
	StOpt      HOptionHq                  `json:"stOpt"`
	MapSimMf   map[int32]HSimpleMoneyFlow `json:"mapSimMf"`
	StHK       HStockHK                   `json:"stHK"`
}

func (st *HStockHq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StSimHq.ResetDefault()
	st.StExHq.ResetDefault()
	st.StQhHq.ResetDefault()
	st.StMF.ResetDefault()
	st.StDDE.ResetDefault()
	st.StBlockHq.ResetDefault()
	st.StDeriveHq.ResetDefault()
	st.StCwHq.ResetDefault()
	st.StZQhq.ResetDefault()
	st.St3MinMF.ResetDefault()
	st.St5MinMF.ResetDefault()
	st.St10MinMF.ResetDefault()
	st.St30MinMF.ResetDefault()
	st.St60MinMF.ResetDefault()
	st.StTB.ResetDefault()
	st.StDayMF.ResetDefault()
	st.StOpt.ResetDefault()
	st.StHK.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockHq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint16(&st.ShtPrecise, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = st.StSimHq.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.StExHq.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.StQhHq.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = st.StMF.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.StDDE.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.StBlockHq.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.StDeriveHq.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = st.StCwHq.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = st.StZQhq.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = st.St3MinMF.ReadBlock(_is, 13, false)
	if err != nil {
		return err
	}

	err = st.St5MinMF.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = st.St10MinMF.ReadBlock(_is, 15, false)
	if err != nil {
		return err
	}

	err = st.St30MinMF.ReadBlock(_is, 16, false)
	if err != nil {
		return err
	}

	err = st.St60MinMF.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	err = st.StTB.ReadBlock(_is, 18, false)
	if err != nil {
		return err
	}

	err = st.StDayMF.ReadBlock(_is, 19, false)
	if err != nil {
		return err
	}

	err = st.StOpt.ReadBlock(_is, 20, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 21, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapSimMf = make(map[int32]HSimpleMoneyFlow)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 HSimpleMoneyFlow

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapSimMf[k0] = v0
		}
	}

	err = st.StHK.ReadBlock(_is, 22, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockHq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockHq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockHq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint16(st.ShtPrecise, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = st.StSimHq.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.StExHq.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.StQhHq.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = st.StMF.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.StDDE.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.StBlockHq.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.StDeriveHq.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = st.StCwHq.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = st.StZQhq.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = st.St3MinMF.WriteBlock(_os, 13)
	if err != nil {
		return err
	}

	err = st.St5MinMF.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = st.St10MinMF.WriteBlock(_os, 15)
	if err != nil {
		return err
	}

	err = st.St30MinMF.WriteBlock(_os, 16)
	if err != nil {
		return err
	}

	err = st.St60MinMF.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	err = st.StTB.WriteBlock(_os, 18)
	if err != nil {
		return err
	}

	err = st.StDayMF.WriteBlock(_os, 19)
	if err != nil {
		return err
	}

	err = st.StOpt.WriteBlock(_os, 20)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapSimMf)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapSimMf {

		err = _os.Write_int32(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	err = st.StHK.WriteBlock(_os, 22)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockHq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockHq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtPrecise:", st.ShtPrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + "stSimHq:" + st.StSimHq.Display()
	ret = ret + ",  "
	ret = ret + "stExHq:" + st.StExHq.Display()
	ret = ret + ",  "
	ret = ret + "stQhHq:" + st.StQhHq.Display()
	ret = ret + ",  "
	ret = ret + "stMF:" + st.StMF.Display()
	ret = ret + ",  "
	ret = ret + "stDDE:" + st.StDDE.Display()
	ret = ret + ",  "
	ret = ret + "stBlockHq:" + st.StBlockHq.Display()
	ret = ret + ",  "
	ret = ret + "stDeriveHq:" + st.StDeriveHq.Display()
	ret = ret + ",  "
	ret = ret + "stCwHq:" + st.StCwHq.Display()
	ret = ret + ",  "
	ret = ret + "stZQhq:" + st.StZQhq.Display()
	ret = ret + ",  "
	ret = ret + "st3MinMF:" + st.St3MinMF.Display()
	ret = ret + ",  "
	ret = ret + "st5MinMF:" + st.St5MinMF.Display()
	ret = ret + ",  "
	ret = ret + "st10MinMF:" + st.St10MinMF.Display()
	ret = ret + ",  "
	ret = ret + "st30MinMF:" + st.St30MinMF.Display()
	ret = ret + ",  "
	ret = ret + "st60MinMF:" + st.St60MinMF.Display()
	ret = ret + ",  "
	ret = ret + "stTB:" + st.StTB.Display()
	ret = ret + ",  "
	ret = ret + "stDayMF:" + st.StDayMF.Display()
	ret = ret + ",  "
	ret = ret + "stOpt:" + st.StOpt.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapSimMf:", st.MapSimMf)
	ret = ret + ",  "
	ret = ret + "stHK:" + st.StHK.Display()

	ret = ret + " }"
	return ret
}

// HStockHqSimple struct implement
type HStockHqSimple struct {
	codec.JceStructBase
	Precise uint16              `json:"precise"`
	Market  int16               `json:"market"`
	Code    string              `json:"code"`
	Name    string              `json:"name"`
	M1      map[int32]float64   `json:"m1"`
	M2      map[int32][]float64 `json:"m2"`
	M3      map[int32]string    `json:"m3"`
}

func (st *HStockHqSimple) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockHqSimple) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint16(&st.Precise, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Market, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Code, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 3, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 4, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M1 = make(map[int32]float64)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 float64

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_float64(&v0, 1, false)
			if err != nil {
				return err
			}

			st.M1[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 5, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M2 = make(map[int32][]float64)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 []float64

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v1 = make([]float64, length)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {

						err = _is.Read_float64(&v1[i2], 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.M2[k1] = v1
		}
	}

	err, have = _is.SkipTo(codec.MAP, 6, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M3 = make(map[int32]string)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 int32
			var v3 string

			err = _is.Read_int32(&k3, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v3, 1, false)
			if err != nil {
				return err
			}

			st.M3[k3] = v3
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockHqSimple) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockHqSimple, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockHqSimple) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint16(st.Precise, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Market, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Code, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M1)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.M1 {

		err = _os.Write_int32(k4, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(v4, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M2)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.M2 {

		err = _os.Write_int32(k5, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v5)), 0)
		if err != nil {
			return err
		}

		for _, v := range v5 {

			err = _os.Write_float64(v, 0)
			if err != nil {
				return err
			}

		}
	}

	err = _os.WriteHead(codec.MAP, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M3)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.M3 {

		err = _os.Write_int32(k6, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v6, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockHqSimple) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockHqSimple) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("precise:", st.Precise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("market:", st.Market)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("code:", st.Code)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("name:", st.Name)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m1:", st.M1)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m2:", st.M2)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m3:", st.M3)

	ret = ret + " }"
	return ret
}

// HStockSimHqNew struct implement
type HStockSimHqNew struct {
	codec.JceStructBase
	ShtPrecise              uint16         `json:"shtPrecise"`
	ShtSetcode              int16          `json:"shtSetcode"`
	SCode                   string         `json:"sCode"`
	SName                   string         `json:"sName"`
	FNowPrice               float64        `json:"fNowPrice"`
	FOpen                   float64        `json:"fOpen"`
	FHigh                   float64        `json:"fHigh"`
	FLow                    float64        `json:"fLow"`
	FClose                  float64        `json:"fClose"`
	LVolume                 int64          `json:"lVolume"`
	FAmount                 float64        `json:"fAmount"`
	FChgValue               float64        `json:"fChgValue"`
	FChgRatio               float64        `json:"fChgRatio"`
	FZhenfu                 float64        `json:"fZhenfu"`
	ZtData                  SZTData        `json:"ztData"`
	LeadBlock               BlockBasicInfo `json:"leadBlock"`
	DOpenAmount             float64        `json:"dOpenAmount"`
	LOpenVolume             int64          `json:"lOpenVolume"`
	LNowVol                 int64          `json:"lNowVol"`
	LInside                 int64          `json:"lInside"`
	LOutside                int64          `json:"lOutside"`
	VBuyp                   []float64      `json:"vBuyp"`
	VBuyv                   []int64        `json:"vBuyv"`
	VSellp                  []float64      `json:"vSellp"`
	VSellv                  []int64        `json:"vSellv"`
	FAveragePrice           float64        `json:"fAveragePrice"`
	FZTPrice                float64        `json:"fZTPrice"`
	FDTPrice                float64        `json:"fDTPrice"`
	FTurnoverRate           float64        `json:"fTurnoverRate"`
	ITradeMin               int32          `json:"iTradeMin"`
	ITradeDate              int32          `json:"iTradeDate"`
	ITradeTime              int32          `json:"iTradeTime"`
	BZDMark                 int8           `json:"bZDMark"`
	BTransactionStatus      int8           `json:"bTransactionStatus"`
	VBuyNum                 []int32        `json:"vBuyNum"`
	VSellNum                []int32        `json:"vSellNum"`
	IBSFlag                 int32          `json:"iBSFlag"`
	DPeRatio                float64        `json:"dPeRatio"`
	DPriceRatio             float64        `json:"dPriceRatio"`
	DZSZ                    float64        `json:"dZSZ"`
	DLTZS                   float64        `json:"dLTZS"`
	FJTPe                   float32        `json:"fJTPe"`
	FTTMPe                  float32        `json:"fTTMPe"`
	DSettlementPrice        float64        `json:"dSettlementPrice"`
	DPreSettlementPrice     float64        `json:"dPreSettlementPrice"`
	DOpenInterest           float64        `json:"dOpenInterest"`
	DPreOpenInterest        float64        `json:"dPreOpenInterest"`
	IEveryHand              int32          `json:"iEveryHand"`
	DDayIncrease            float64        `json:"dDayIncrease"`
	SHeadMarket             int16          `json:"sHeadMarket"`
	SHeadCode               string         `json:"sHeadCode"`
	SHeadName               string         `json:"sHeadName"`
	FHeadNow                float64        `json:"fHeadNow"`
	FHeadClose              float64        `json:"fHeadClose"`
	IStockNum               int32          `json:"iStockNum"`
	IEqualNum               int32          `json:"iEqualNum"`
	IZTNum                  int32          `json:"iZTNum"`
	IUpNum                  int32          `json:"iUpNum"`
	IDownNum                int32          `json:"iDownNum"`
	DTotalMarketValue       float64        `json:"dTotalMarketValue"`
	DCirculationMarketValue float64        `json:"dCirculationMarketValue"`
	IUpNDay                 int32          `json:"iUpNDay"`
	D3DayChg                float64        `json:"d3DayChg"`
	D5DayChg                float64        `json:"d5DayChg"`
	D10DayChg               float64        `json:"d10DayChg"`
	DLead                   float64        `json:"dLead"`
	DMGSY                   float64        `json:"dMGSY"`
	DMGJZC                  float64        `json:"dMGJZC"`
	DJZCSYL                 float64        `json:"dJZCSYL"`
	DYSZZL3Y                float64        `json:"dYSZZL3Y"`
	DJLSZZL3Y               float64        `json:"dJLSZZL3Y"`
	FRoRPerYear             float32        `json:"fRoRPerYear"`
	DRatePer10w             float64        `json:"dRatePer10w"`
	DRatePer1k              float64        `json:"dRatePer1k"`
	ShtDays                 int16          `json:"shtDays"`
	ShtZkDays               int16          `json:"shtZkDays"`
	IJxFrom                 int32          `json:"iJxFrom"`
	IJxTo                   int32          `json:"iJxTo"`
	ITodayBuy               int32          `json:"iTodayBuy"`
	IZjUserDay              int32          `json:"iZjUserDay"`
	IZjFetchDay             int32          `json:"iZjFetchDay"`
	FGZJZ                   float32        `json:"fGZJZ"`
	FYJL                    float32        `json:"fYJL"`
	ShtZRType               int16          `json:"shtZRType"`
	ShtZRStatus             int16          `json:"shtZRStatus"`
	ShtFC                   int16          `json:"shtFC"`
	ShtType                 int16          `json:"shtType"`
	ShtTpStatus             int16          `json:"shtTpStatus"`
	ShtCQCXStatus           int16          `json:"shtCQCXStatus"`
	CDiffRight              int8           `json:"cDiffRight"`
	ShtMarketMakeCount      uint16         `json:"shtMarketMakeCount"`
	FImpliedVolatility      float32        `json:"fImpliedVolatility"`
	FDelta                  float32        `json:"fDelta"`
	FGamma                  float32        `json:"fGamma"`
	FVega                   float32        `json:"fVega"`
	FTheta                  float32        `json:"fTheta"`
	FRho                    float32        `json:"fRho"`
	FLeverageRatio          float32        `json:"fLeverageRatio"`
	FRealLeverageRatio      float32        `json:"fRealLeverageRatio"`
	FInstrinsicValue        float32        `json:"fInstrinsicValue"`
	FPremiumRatio           float32        `json:"fPremiumRatio"`
	FXushiDu                float32        `json:"fXushiDu"`
	FHisVol                 float32        `json:"fHisVol"`
	DBalancePrice           float64        `json:"dBalancePrice"`
	LBalanceVol             int64          `json:"lBalanceVol"`
	DReferencePrice         float64        `json:"dReferencePrice"`
	DLowLimitPrice          float64        `json:"dLowLimitPrice"`
	DHighLimitPrice         float64        `json:"dHighLimitPrice"`
	CDirection              int8           `json:"cDirection"`
	LImbalanceVol           int64          `json:"lImbalanceVol"`
	DBuyLowLimitPrice       float64        `json:"dBuyLowLimitPrice"`
	DBuyHighLimitPrice      float64        `json:"dBuyHighLimitPrice"`
	DSellLowLimitPrice      float64        `json:"dSellLowLimitPrice"`
	DSellHighLimitPrice     float64        `json:"dSellHighLimitPrice"`
	FDDX                    float64        `json:"fDDX"`
	FDDY                    float64        `json:"fDDY"`
	FDDZ                    float64        `json:"fDDZ"`
	FDDF                    float64        `json:"fDDF"`
	FDDX5                   float64        `json:"fDDX5"`
	FDDY5                   float64        `json:"fDDY5"`
	FDDX60                  float64        `json:"fDDX60"`
	FDDY60                  float64        `json:"fDDY60"`
}

func (st *HStockSimHqNew) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ZtData.ResetDefault()
	st.LeadBlock.ResetDefault()
	st.FJTPe = 0.0
	st.FTTMPe = 0.0
	st.DLead = 0.0
	st.FRoRPerYear = 0
	st.DRatePer10w = 0
	st.DRatePer1k = 0
	st.ShtDays = 0
	st.ShtZkDays = 0
	st.IJxFrom = 0
	st.IJxTo = 0
	st.ITodayBuy = 0
	st.IZjUserDay = 0
	st.IZjFetchDay = 0
	st.FGZJZ = 0.0
	st.FYJL = 0.0
	st.ShtZRType = 0
	st.ShtZRStatus = 0
	st.ShtFC = 0
	st.ShtType = 0
	st.ShtTpStatus = 0
	st.ShtCQCXStatus = 0
	st.CDiffRight = 0
	st.ShtMarketMakeCount = 0
	st.DBalancePrice = 0.0
	st.LBalanceVol = 0
	st.DReferencePrice = 0.0
	st.DLowLimitPrice = 0.0
	st.DHighLimitPrice = 0.0
	st.CDirection = 0
	st.LImbalanceVol = 0
	st.DBuyLowLimitPrice = 0.0
	st.DBuyHighLimitPrice = 0.0
	st.DSellLowLimitPrice = 0.0
	st.DSellHighLimitPrice = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockSimHqNew) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint16(&st.ShtPrecise, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNowPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FOpen, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHigh, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FLow, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FClose, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FAmount, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChgValue, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChgRatio, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FZhenfu, 13, false)
	if err != nil {
		return err
	}

	err = st.ZtData.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = st.LeadBlock.ReadBlock(_is, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOpenAmount, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LOpenVolume, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LNowVol, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LInside, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LOutside, 20, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(21, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuyp = make([]float64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_float64(&st.VBuyp[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(22, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuyv = make([]int64, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int64(&st.VBuyv[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(23, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSellp = make([]float64, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_float64(&st.VSellp[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(24, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSellv = make([]int64, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = _is.Read_int64(&st.VSellv[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_float64(&st.FAveragePrice, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FZTPrice, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDTPrice, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FTurnoverRate, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeMin, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeDate, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeTime, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BZDMark, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BTransactionStatus, 33, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(34, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuyNum = make([]int32, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = _is.Read_int32(&st.VBuyNum[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(35, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSellNum = make([]int32, length)
			for i5, e5 := int32(0), length; i5 < e5; i5++ {

				err = _is.Read_int32(&st.VSellNum[i5], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.IBSFlag, 36, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPeRatio, 37, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPriceRatio, 38, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZSZ, 39, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLTZS, 40, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FJTPe, 41, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FTTMPe, 42, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSettlementPrice, 43, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreSettlementPrice, 44, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOpenInterest, 45, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreOpenInterest, 46, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEveryHand, 47, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDayIncrease, 48, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.SHeadMarket, 49, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SHeadCode, 50, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SHeadName, 51, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHeadNow, 52, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHeadClose, 53, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStockNum, 54, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEqualNum, 55, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZTNum, 56, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpNum, 57, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDownNum, 58, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTotalMarketValue, 59, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCirculationMarketValue, 60, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpNDay, 61, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D3DayChg, 62, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D5DayChg, 63, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D10DayChg, 64, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLead, 65, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGSY, 66, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGJZC, 67, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJZCSYL, 68, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYSZZL3Y, 69, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJLSZZL3Y, 70, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FRoRPerYear, 71, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRatePer10w, 72, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRatePer1k, 73, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDays, 74, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtZkDays, 75, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IJxFrom, 76, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IJxTo, 77, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITodayBuy, 78, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZjUserDay, 79, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZjFetchDay, 80, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FGZJZ, 81, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FYJL, 82, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtZRType, 83, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtZRStatus, 84, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtFC, 85, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 86, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtTpStatus, 87, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtCQCXStatus, 88, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CDiffRight, 89, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint16(&st.ShtMarketMakeCount, 90, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FImpliedVolatility, 91, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FDelta, 92, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FGamma, 93, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FVega, 94, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FTheta, 95, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FRho, 96, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FLeverageRatio, 97, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FRealLeverageRatio, 98, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FInstrinsicValue, 99, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FPremiumRatio, 100, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FXushiDu, 101, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FHisVol, 102, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBalancePrice, 103, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBalanceVol, 104, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DReferencePrice, 105, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLowLimitPrice, 106, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHighLimitPrice, 107, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CDirection, 108, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LImbalanceVol, 109, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuyLowLimitPrice, 110, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuyHighLimitPrice, 111, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellLowLimitPrice, 112, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellHighLimitPrice, 113, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDX, 114, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDY, 115, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDZ, 116, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDF, 117, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDX5, 118, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDY5, 119, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDX60, 120, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDDY60, 121, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockSimHqNew) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockSimHqNew, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockSimHqNew) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint16(st.ShtPrecise, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNowPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FOpen, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHigh, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FLow, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FClose, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FAmount, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChgValue, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChgRatio, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FZhenfu, 13)
	if err != nil {
		return err
	}

	err = st.ZtData.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = st.LeadBlock.WriteBlock(_os, 15)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOpenAmount, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LOpenVolume, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LNowVol, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LInside, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LOutside, 20)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuyp)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBuyp {

		err = _os.Write_float64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 22)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuyv)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBuyv {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSellp)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSellp {

		err = _os.Write_float64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSellv)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSellv {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_float64(st.FAveragePrice, 25)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FZTPrice, 26)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDTPrice, 27)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FTurnoverRate, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeMin, 29)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeDate, 30)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeTime, 31)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BZDMark, 32)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BTransactionStatus, 33)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 34)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuyNum)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VBuyNum {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 35)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSellNum)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSellNum {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.IBSFlag, 36)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPeRatio, 37)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPriceRatio, 38)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZSZ, 39)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLTZS, 40)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FJTPe, 41)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FTTMPe, 42)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSettlementPrice, 43)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreSettlementPrice, 44)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOpenInterest, 45)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreOpenInterest, 46)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEveryHand, 47)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDayIncrease, 48)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.SHeadMarket, 49)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SHeadCode, 50)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SHeadName, 51)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHeadNow, 52)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHeadClose, 53)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStockNum, 54)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEqualNum, 55)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZTNum, 56)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpNum, 57)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDownNum, 58)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTotalMarketValue, 59)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCirculationMarketValue, 60)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpNDay, 61)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D3DayChg, 62)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D5DayChg, 63)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D10DayChg, 64)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLead, 65)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGSY, 66)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGJZC, 67)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJZCSYL, 68)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYSZZL3Y, 69)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJLSZZL3Y, 70)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FRoRPerYear, 71)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRatePer10w, 72)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRatePer1k, 73)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDays, 74)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtZkDays, 75)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IJxFrom, 76)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IJxTo, 77)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITodayBuy, 78)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZjUserDay, 79)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZjFetchDay, 80)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FGZJZ, 81)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FYJL, 82)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtZRType, 83)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtZRStatus, 84)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtFC, 85)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 86)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtTpStatus, 87)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtCQCXStatus, 88)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CDiffRight, 89)
	if err != nil {
		return err
	}

	err = _os.Write_uint16(st.ShtMarketMakeCount, 90)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FImpliedVolatility, 91)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FDelta, 92)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FGamma, 93)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FVega, 94)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FTheta, 95)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FRho, 96)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FLeverageRatio, 97)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FRealLeverageRatio, 98)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FInstrinsicValue, 99)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FPremiumRatio, 100)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FXushiDu, 101)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FHisVol, 102)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBalancePrice, 103)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBalanceVol, 104)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DReferencePrice, 105)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLowLimitPrice, 106)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHighLimitPrice, 107)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CDirection, 108)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LImbalanceVol, 109)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuyLowLimitPrice, 110)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuyHighLimitPrice, 111)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellLowLimitPrice, 112)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellHighLimitPrice, 113)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDX, 114)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDY, 115)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDZ, 116)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDF, 117)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDX5, 118)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDY5, 119)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDX60, 120)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDDY60, 121)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockSimHqNew) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockSimHqNew) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtPrecise:", st.ShtPrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fOpen:", st.FOpen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHigh:", st.FHigh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLow:", st.FLow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fClose:", st.FClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAmount:", st.FAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChgValue:", st.FChgValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChgRatio:", st.FChgRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fZhenfu:", st.FZhenfu)
	ret = ret + ",  "
	ret = ret + "ztData:" + st.ZtData.Display()
	ret = ret + ",  "
	ret = ret + "leadBlock:" + st.LeadBlock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOpenAmount:", st.DOpenAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lOpenVolume:", st.LOpenVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lNowVol:", st.LNowVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lInside:", st.LInside)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lOutside:", st.LOutside)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuyp:", st.VBuyp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuyv:", st.VBuyv)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSellp:", st.VSellp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSellv:", st.VSellv)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAveragePrice:", st.FAveragePrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fZTPrice:", st.FZTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDTPrice:", st.FDTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTurnoverRate:", st.FTurnoverRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeMin:", st.ITradeMin)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeDate:", st.ITradeDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeTime:", st.ITradeTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bZDMark:", st.BZDMark)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bTransactionStatus:", st.BTransactionStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuyNum:", st.VBuyNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSellNum:", st.VSellNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iBSFlag:", st.IBSFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPeRatio:", st.DPeRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPriceRatio:", st.DPriceRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZSZ:", st.DZSZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLTZS:", st.DLTZS)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fJTPe:", st.FJTPe)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTTMPe:", st.FTTMPe)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSettlementPrice:", st.DSettlementPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreSettlementPrice:", st.DPreSettlementPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOpenInterest:", st.DOpenInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreOpenInterest:", st.DPreOpenInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEveryHand:", st.IEveryHand)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDayIncrease:", st.DDayIncrease)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sHeadMarket:", st.SHeadMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sHeadCode:", st.SHeadCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sHeadName:", st.SHeadName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHeadNow:", st.FHeadNow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHeadClose:", st.FHeadClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStockNum:", st.IStockNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEqualNum:", st.IEqualNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZTNum:", st.IZTNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpNum:", st.IUpNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDownNum:", st.IDownNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTotalMarketValue:", st.DTotalMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCirculationMarketValue:", st.DCirculationMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpNDay:", st.IUpNDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d3DayChg:", st.D3DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d5DayChg:", st.D5DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d10DayChg:", st.D10DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLead:", st.DLead)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGSY:", st.DMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGJZC:", st.DMGJZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJZCSYL:", st.DJZCSYL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYSZZL3Y:", st.DYSZZL3Y)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJLSZZL3Y:", st.DJLSZZL3Y)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRoRPerYear:", st.FRoRPerYear)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRatePer10w:", st.DRatePer10w)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRatePer1k:", st.DRatePer1k)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDays:", st.ShtDays)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtZkDays:", st.ShtZkDays)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iJxFrom:", st.IJxFrom)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iJxTo:", st.IJxTo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTodayBuy:", st.ITodayBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZjUserDay:", st.IZjUserDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZjFetchDay:", st.IZjFetchDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fGZJZ:", st.FGZJZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fYJL:", st.FYJL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtZRType:", st.ShtZRType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtZRStatus:", st.ShtZRStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtFC:", st.ShtFC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtTpStatus:", st.ShtTpStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtCQCXStatus:", st.ShtCQCXStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cDiffRight:", st.CDiffRight)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtMarketMakeCount:", st.ShtMarketMakeCount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fImpliedVolatility:", st.FImpliedVolatility)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDelta:", st.FDelta)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fGamma:", st.FGamma)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fVega:", st.FVega)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTheta:", st.FTheta)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRho:", st.FRho)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLeverageRatio:", st.FLeverageRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fRealLeverageRatio:", st.FRealLeverageRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fInstrinsicValue:", st.FInstrinsicValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPremiumRatio:", st.FPremiumRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fXushiDu:", st.FXushiDu)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHisVol:", st.FHisVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBalancePrice:", st.DBalancePrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBalanceVol:", st.LBalanceVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dReferencePrice:", st.DReferencePrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLowLimitPrice:", st.DLowLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHighLimitPrice:", st.DHighLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cDirection:", st.CDirection)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lImbalanceVol:", st.LImbalanceVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuyLowLimitPrice:", st.DBuyLowLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuyHighLimitPrice:", st.DBuyHighLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellLowLimitPrice:", st.DSellLowLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellHighLimitPrice:", st.DSellHighLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX:", st.FDDX)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDY:", st.FDDY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDZ:", st.FDDZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDF:", st.FDDF)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX5:", st.FDDX5)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDY5:", st.FDDY5)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX60:", st.FDDX60)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDY60:", st.FDDY60)

	ret = ret + " }"
	return ret
}

// HStockDeriveHqNew struct implement
type HStockDeriveHqNew struct {
	codec.JceStructBase
	DLiangBi             float64              `json:"dLiangBi"`
	DUpSpeed             float64              `json:"dUpSpeed"`
	LTradeNum            int64                `json:"lTradeNum"`
	DBuyAvg              float64              `json:"dBuyAvg"`
	DSellAvg             float64              `json:"dSellAvg"`
	LBuyPriceNum         int64                `json:"lBuyPriceNum"`
	LSellPriceNum        int64                `json:"lSellPriceNum"`
	LBuyVol              int64                `json:"lBuyVol"`
	LSellVol             int64                `json:"lSellVol"`
	EStatus              E_STOCK_TRADE_STATUS `json:"eStatus"`
	DMainMoneyInflow5Min float64              `json:"dMainMoneyInflow5Min"`
	UiItemNum            uint32               `json:"uiItemNum"`
	LAtpVolume           int64                `json:"lAtpVolume"`
	DAtpAmount           float64              `json:"dAtpAmount"`
	IGzhgAvgBP           int32                `json:"iGzhgAvgBP"`
	IGzhgBP              int32                `json:"iGzhgBP"`
	DIOPV                float64              `json:"dIOPV"`
	D10DayReturnRate     float64              `json:"d10DayReturnRate"`
	D52WeekMax           float64              `json:"d52WeekMax"`
	D52WeekMin           float64              `json:"d52WeekMin"`
	DHistoryMax          float64              `json:"dHistoryMax"`
	DHistoryMin          float64              `json:"dHistoryMin"`
	D3DayNetInflow       float64              `json:"d3DayNetInflow"`
	D5DayNetInflow       float64              `json:"d5DayNetInflow"`
	D10DayNetInflow      float64              `json:"d10DayNetInflow"`
	D20DayNetInflow      float64              `json:"d20DayNetInflow"`
	DMatchPrice          float64              `json:"dMatchPrice"`
	LMatchVol            int64                `json:"lMatchVol"`
	LNoMatchVol          int64                `json:"lNoMatchVol"`
	D5DayChg             float64              `json:"d5DayChg"`
	D10DayChg            float64              `json:"d10DayChg"`
	D20DayChg            float64              `json:"d20DayChg"`
	DMonthChg            float64              `json:"dMonthChg"`
	DSeasonChg           float64              `json:"dSeasonChg"`
	DYearChg             float64              `json:"dYearChg"`
	BActBSFlag           int8                 `json:"bActBSFlag"`
	DRefBeginPrice       float64              `json:"dRefBeginPrice"`
	DRefEndPrice         float64              `json:"dRefEndPrice"`
	DThisYearChg         float64              `json:"dThisYearChg"`
	DLztzj               float64              `json:"dLztzj"`
	Dldtzj               float64              `json:"dldtzj"`
	FLastChg             float32              `json:"fLastChg"`
	FWeiBi               float32              `json:"fWeiBi"`
	BBlockTrade          bool                 `json:"bBlockTrade"`
	DTotalChg            float64              `json:"dTotalChg"`
	DCfgYjSz             float64              `json:"dCfgYjSz"`
	DCfgZjSz             float64              `json:"dCfgZjSz"`
	DCfgSz               float64              `json:"dCfgSz"`
	UiLYBCurrDayRank     uint32               `json:"uiLYBCurrDayRank"`
	UiLYBPreDayRank      uint32               `json:"uiLYBPreDayRank"`
}

func (st *HStockDeriveHqNew) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.LAtpVolume = 0
	st.DAtpAmount = 0
	st.IGzhgAvgBP = 0
	st.IGzhgBP = 0
	st.DIOPV = 0.0
	st.D10DayReturnRate = 0.0
	st.D52WeekMax = 0.0
	st.D52WeekMin = 0.0
	st.DHistoryMax = 0.0
	st.DHistoryMin = 0.0
	st.D3DayNetInflow = 0.0
	st.D5DayNetInflow = 0.0
	st.D10DayNetInflow = 0.0
	st.D20DayNetInflow = 0.0
	st.DMatchPrice = 0.0
	st.LMatchVol = 0
	st.LNoMatchVol = 0
	st.D5DayChg = 0.0
	st.D10DayChg = 0.0
	st.D20DayChg = 0.0
	st.DMonthChg = 0.0
	st.DSeasonChg = 0.0
	st.DYearChg = 0.0
	st.BActBSFlag = 0
	st.DRefBeginPrice = 0.0
	st.DRefEndPrice = 0.0
	st.DThisYearChg = 0.0
	st.DLztzj = 0.0
	st.Dldtzj = 0.0
	st.FLastChg = 0.0
	st.FWeiBi = 0.0
	st.BBlockTrade = false
	st.DTotalChg = 0.0
	st.DCfgYjSz = 0.0
	st.DCfgZjSz = 0.0
	st.DCfgSz = 0.0
	st.UiLYBCurrDayRank = 0
	st.UiLYBPreDayRank = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDeriveHqNew) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DLiangBi, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DUpSpeed, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTradeNum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuyAvg, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellAvg, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyPriceNum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellPriceNum, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyVol, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellVol, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStatus), 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMainMoneyInflow5Min, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiItemNum, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LAtpVolume, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAtpAmount, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IGzhgAvgBP, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IGzhgBP, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DIOPV, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D10DayReturnRate, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D52WeekMax, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D52WeekMin, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHistoryMax, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHistoryMin, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D3DayNetInflow, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D5DayNetInflow, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D10DayNetInflow, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D20DayNetInflow, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMatchPrice, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LMatchVol, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LNoMatchVol, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D5DayChg, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D10DayChg, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D20DayChg, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMonthChg, 33, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSeasonChg, 34, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYearChg, 35, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BActBSFlag, 36, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRefBeginPrice, 37, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRefEndPrice, 38, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DThisYearChg, 39, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLztzj, 40, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Dldtzj, 41, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FLastChg, 42, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FWeiBi, 43, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BBlockTrade, 44, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTotalChg, 45, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCfgYjSz, 46, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCfgZjSz, 47, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCfgSz, 48, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiLYBCurrDayRank, 49, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiLYBPreDayRank, 50, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDeriveHqNew) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDeriveHqNew, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDeriveHqNew) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DLiangBi, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DUpSpeed, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTradeNum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuyAvg, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellAvg, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyPriceNum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellPriceNum, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyVol, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellVol, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStatus), 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMainMoneyInflow5Min, 10)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiItemNum, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LAtpVolume, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAtpAmount, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IGzhgAvgBP, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IGzhgBP, 16)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DIOPV, 17)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D10DayReturnRate, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D52WeekMax, 19)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D52WeekMin, 20)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHistoryMax, 21)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHistoryMin, 22)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D3DayNetInflow, 23)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D5DayNetInflow, 24)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D10DayNetInflow, 25)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D20DayNetInflow, 26)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMatchPrice, 27)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LMatchVol, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LNoMatchVol, 29)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D5DayChg, 30)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D10DayChg, 31)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D20DayChg, 32)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMonthChg, 33)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSeasonChg, 34)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYearChg, 35)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BActBSFlag, 36)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRefBeginPrice, 37)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRefEndPrice, 38)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DThisYearChg, 39)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLztzj, 40)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Dldtzj, 41)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FLastChg, 42)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FWeiBi, 43)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BBlockTrade, 44)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTotalChg, 45)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCfgYjSz, 46)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCfgZjSz, 47)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCfgSz, 48)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiLYBCurrDayRank, 49)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiLYBPreDayRank, 50)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDeriveHqNew) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDeriveHqNew) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dLiangBi:", st.DLiangBi)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dUpSpeed:", st.DUpSpeed)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTradeNum:", st.LTradeNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuyAvg:", st.DBuyAvg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellAvg:", st.DSellAvg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyPriceNum:", st.LBuyPriceNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellPriceNum:", st.LSellPriceNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyVol:", st.LBuyVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellVol:", st.LSellVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMainMoneyInflow5Min:", st.DMainMoneyInflow5Min)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiItemNum:", st.UiItemNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lAtpVolume:", st.LAtpVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAtpAmount:", st.DAtpAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iGzhgAvgBP:", st.IGzhgAvgBP)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iGzhgBP:", st.IGzhgBP)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dIOPV:", st.DIOPV)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d10DayReturnRate:", st.D10DayReturnRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d52WeekMax:", st.D52WeekMax)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d52WeekMin:", st.D52WeekMin)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHistoryMax:", st.DHistoryMax)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHistoryMin:", st.DHistoryMin)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d3DayNetInflow:", st.D3DayNetInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d5DayNetInflow:", st.D5DayNetInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d10DayNetInflow:", st.D10DayNetInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d20DayNetInflow:", st.D20DayNetInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMatchPrice:", st.DMatchPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lMatchVol:", st.LMatchVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lNoMatchVol:", st.LNoMatchVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d5DayChg:", st.D5DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d10DayChg:", st.D10DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d20DayChg:", st.D20DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMonthChg:", st.DMonthChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSeasonChg:", st.DSeasonChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYearChg:", st.DYearChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bActBSFlag:", st.BActBSFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRefBeginPrice:", st.DRefBeginPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRefEndPrice:", st.DRefEndPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dThisYearChg:", st.DThisYearChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLztzj:", st.DLztzj)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dldtzj:", st.Dldtzj)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLastChg:", st.FLastChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fWeiBi:", st.FWeiBi)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bBlockTrade:", st.BBlockTrade)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTotalChg:", st.DTotalChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCfgYjSz:", st.DCfgYjSz)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCfgZjSz:", st.DCfgZjSz)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCfgSz:", st.DCfgSz)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiLYBCurrDayRank:", st.UiLYBCurrDayRank)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiLYBPreDayRank:", st.UiLYBPreDayRank)

	ret = ret + " }"
	return ret
}

// HStockHqNew struct implement
type HStockHqNew struct {
	codec.JceStructBase
	StSimHq    HStockSimHqNew             `json:"stSimHq"`
	StDeriveHq HStockDeriveHqNew          `json:"stDeriveHq"`
	StMF       HTolMoneyFlow              `json:"stMF"`
	StDayMF    HTolMoneyFlowSet           `json:"stDayMF"`
	MapSimMf   map[int32]HSimpleMoneyFlow `json:"mapSimMf"`
}

func (st *HStockHqNew) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StSimHq.ResetDefault()
	st.StDeriveHq.ResetDefault()
	st.StMF.ResetDefault()
	st.StDayMF.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockHqNew) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StSimHq.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.StDeriveHq.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.StMF.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.StDayMF.ReadBlock(_is, 19, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 21, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapSimMf = make(map[int32]HSimpleMoneyFlow)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 HSimpleMoneyFlow

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			st.MapSimMf[k0] = v0
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockHqNew) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockHqNew, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockHqNew) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StSimHq.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.StDeriveHq.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.StMF.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.StDayMF.WriteBlock(_os, 19)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapSimMf)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapSimMf {

		err = _os.Write_int32(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(_os, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockHqNew) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockHqNew) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stSimHq:" + st.StSimHq.Display()
	ret = ret + ",  "
	ret = ret + "stDeriveHq:" + st.StDeriveHq.Display()
	ret = ret + ",  "
	ret = ret + "stMF:" + st.StMF.Display()
	ret = ret + ",  "
	ret = ret + "stDayMF:" + st.StDayMF.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapSimMf:", st.MapSimMf)

	ret = ret + " }"
	return ret
}

// OptStockPrePostInfo struct implement
type OptStockPrePostInfo struct {
	codec.JceStructBase
	ShtStatus int16   `json:"shtStatus"`
	FNowPrice float64 `json:"fNowPrice"`
	FChg      float64 `json:"fChg"`
	FChgValue float64 `json:"fChgValue"`
}

func (st *OptStockPrePostInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *OptStockPrePostInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtStatus, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNowPrice, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChg, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChgValue, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *OptStockPrePostInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OptStockPrePostInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *OptStockPrePostInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtStatus, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNowPrice, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChg, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChgValue, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *OptStockPrePostInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *OptStockPrePostInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtStatus:", st.ShtStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChgValue:", st.FChgValue)

	ret = ret + " }"
	return ret
}

// OptStockHqEx struct implement
type OptStockHqEx struct {
	codec.JceStructBase
	FNowPrice               float64             `json:"fNowPrice"`
	FChg                    float64             `json:"fChg"`
	FChgValue               float64             `json:"fChgValue"`
	DUpSpeed                float64             `json:"dUpSpeed"`
	FTurnoverRate           float64             `json:"fTurnoverRate"`
	FPeRatio                float64             `json:"fPeRatio"`
	ShtSetcode              int16               `json:"shtSetcode"`
	SCode                   string              `json:"sCode"`
	SName                   string              `json:"sName"`
	FDayMainMoneyInflow     float64             `json:"fDayMainMoneyInflow"`
	FDayMainMoneyRatio      float64             `json:"fDayMainMoneyRatio"`
	F3DayMainMoneyInflow    float64             `json:"f3DayMainMoneyInflow"`
	F3DayMainMoneyRatio     float64             `json:"f3DayMainMoneyRatio"`
	F5DayMainMoneyInflow    float64             `json:"f5DayMainMoneyInflow"`
	F5DayMainMoneyRatio     float64             `json:"f5DayMainMoneyRatio"`
	BTransactionStatus      int8                `json:"bTransactionStatus"`
	Precise                 int8                `json:"precise"`
	F3MinMainMoneyInflow    float64             `json:"f3MinMainMoneyInflow"`
	F3MinMainMoneyRatio     float64             `json:"f3MinMainMoneyRatio"`
	F5MinMainMoneyInflow    float64             `json:"f5MinMainMoneyInflow"`
	F5MinMainMoneyRatio     float64             `json:"f5MinMainMoneyRatio"`
	ZtData                  SZTData             `json:"ztData"`
	LeadBlock               BlockBasicInfo      `json:"leadBlock"`
	F10MinMainMoneyInflow   float64             `json:"f10MinMainMoneyInflow"`
	F10MinMainMoneyRatio    float64             `json:"f10MinMainMoneyRatio"`
	F30MinMainMoneyInflow   float64             `json:"f30MinMainMoneyInflow"`
	F30MinMainMoneyRatio    float64             `json:"f30MinMainMoneyRatio"`
	F60MinMainMoneyInflow   float64             `json:"f60MinMainMoneyInflow"`
	F60MinMainMoneyRatio    float64             `json:"f60MinMainMoneyRatio"`
	DOpen                   float64             `json:"dOpen"`
	DHigh                   float64             `json:"dHigh"`
	DLow                    float64             `json:"dLow"`
	DPreClose               float64             `json:"dPreClose"`
	LVolume                 int64               `json:"lVolume"`
	LTradeNum               int64               `json:"lTradeNum"`
	DAmount                 float64             `json:"dAmount"`
	StTB                    HStockTB            `json:"stTB"`
	VRTMinData              []HRTMinDataSimp    `json:"vRTMinData"`
	FZhenfu                 float32             `json:"fZhenfu"`
	FLiangBi                float32             `json:"fLiangBi"`
	FWeibi                  float32             `json:"fWeibi"`
	UiLYBCurrDayRank        uint32              `json:"uiLYBCurrDayRank"`
	UiLYBPreDayRank         uint32              `json:"uiLYBPreDayRank"`
	F5DayChg                float32             `json:"f5DayChg"`
	F10DayChg               float32             `json:"f10DayChg"`
	F20DayChg               float32             `json:"f20DayChg"`
	FMonthChg               float32             `json:"fMonthChg"`
	FSeasonChg              float32             `json:"fSeasonChg"`
	FThisYearChg            float32             `json:"fThisYearChg"`
	FYearChg                float32             `json:"fYearChg"`
	StPrePostHq             OptStockPrePostInfo `json:"stPrePostHq"`
	IStockNum               int32               `json:"iStockNum"`
	FTotalMarketValue       float64             `json:"fTotalMarketValue"`
	FCirculationMarketValue float64             `json:"fCirculationMarketValue"`
	IUpNDay                 int32               `json:"iUpNDay"`
	ShtThisYearUpTotalDay   int16               `json:"shtThisYearUpTotalDay"`
}

func (st *OptStockHqEx) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ZtData.ResetDefault()
	st.LeadBlock.ResetDefault()
	st.StTB.ResetDefault()
	st.FZhenfu = 0.0
	st.FLiangBi = 0.0
	st.FWeibi = 0.0
	st.UiLYBCurrDayRank = 0
	st.UiLYBPreDayRank = 0
	st.F5DayChg = 0.0
	st.F10DayChg = 0.0
	st.F20DayChg = 0.0
	st.FMonthChg = 0.0
	st.FSeasonChg = 0.0
	st.FThisYearChg = 0.0
	st.FYearChg = 0.0
	st.StPrePostHq.ResetDefault()
	st.IStockNum = 0
	st.FTotalMarketValue = 0.0
	st.FCirculationMarketValue = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *OptStockHqEx) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.FNowPrice, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChg, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChgValue, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DUpSpeed, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FTurnoverRate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FPeRatio, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDayMainMoneyInflow, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDayMainMoneyRatio, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F3DayMainMoneyInflow, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F3DayMainMoneyRatio, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F5DayMainMoneyInflow, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F5DayMainMoneyRatio, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BTransactionStatus, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.Precise, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F3MinMainMoneyInflow, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F3MinMainMoneyRatio, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F5MinMainMoneyInflow, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F5MinMainMoneyRatio, 20, false)
	if err != nil {
		return err
	}

	err = st.ZtData.ReadBlock(_is, 21, false)
	if err != nil {
		return err
	}

	err = st.LeadBlock.ReadBlock(_is, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F10MinMainMoneyInflow, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F10MinMainMoneyRatio, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F30MinMainMoneyInflow, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F30MinMainMoneyRatio, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F60MinMainMoneyInflow, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.F60MinMainMoneyRatio, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOpen, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHigh, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLow, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreClose, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 33, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTradeNum, 34, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAmount, 35, false)
	if err != nil {
		return err
	}

	err = st.StTB.ReadBlock(_is, 36, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(37, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRTMinData = make([]HRTMinDataSimp, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRTMinData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_float32(&st.FZhenfu, 38, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FLiangBi, 39, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FWeibi, 40, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiLYBCurrDayRank, 41, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiLYBPreDayRank, 42, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.F5DayChg, 43, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.F10DayChg, 44, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.F20DayChg, 45, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FMonthChg, 46, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FSeasonChg, 47, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FThisYearChg, 48, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FYearChg, 49, false)
	if err != nil {
		return err
	}

	err = st.StPrePostHq.ReadBlock(_is, 50, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStockNum, 51, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FTotalMarketValue, 52, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FCirculationMarketValue, 53, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpNDay, 54, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtThisYearUpTotalDay, 55, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *OptStockHqEx) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OptStockHqEx, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *OptStockHqEx) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.FNowPrice, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChg, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChgValue, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DUpSpeed, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FTurnoverRate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FPeRatio, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDayMainMoneyInflow, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDayMainMoneyRatio, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F3DayMainMoneyInflow, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F3DayMainMoneyRatio, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F5DayMainMoneyInflow, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F5DayMainMoneyRatio, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BTransactionStatus, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.Precise, 16)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F3MinMainMoneyInflow, 17)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F3MinMainMoneyRatio, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F5MinMainMoneyInflow, 19)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F5MinMainMoneyRatio, 20)
	if err != nil {
		return err
	}

	err = st.ZtData.WriteBlock(_os, 21)
	if err != nil {
		return err
	}

	err = st.LeadBlock.WriteBlock(_os, 22)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F10MinMainMoneyInflow, 23)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F10MinMainMoneyRatio, 24)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F30MinMainMoneyInflow, 25)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F30MinMainMoneyRatio, 26)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F60MinMainMoneyInflow, 27)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.F60MinMainMoneyRatio, 28)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOpen, 29)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHigh, 30)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLow, 31)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreClose, 32)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 33)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTradeNum, 34)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAmount, 35)
	if err != nil {
		return err
	}

	err = st.StTB.WriteBlock(_os, 36)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 37)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRTMinData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRTMinData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_float32(st.FZhenfu, 38)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FLiangBi, 39)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FWeibi, 40)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiLYBCurrDayRank, 41)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiLYBPreDayRank, 42)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.F5DayChg, 43)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.F10DayChg, 44)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.F20DayChg, 45)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FMonthChg, 46)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FSeasonChg, 47)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FThisYearChg, 48)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FYearChg, 49)
	if err != nil {
		return err
	}

	err = st.StPrePostHq.WriteBlock(_os, 50)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStockNum, 51)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FTotalMarketValue, 52)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FCirculationMarketValue, 53)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpNDay, 54)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtThisYearUpTotalDay, 55)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *OptStockHqEx) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *OptStockHqEx) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChgValue:", st.FChgValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dUpSpeed:", st.DUpSpeed)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTurnoverRate:", st.FTurnoverRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPeRatio:", st.FPeRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDayMainMoneyInflow:", st.FDayMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDayMainMoneyRatio:", st.FDayMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f3DayMainMoneyInflow:", st.F3DayMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f3DayMainMoneyRatio:", st.F3DayMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f5DayMainMoneyInflow:", st.F5DayMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f5DayMainMoneyRatio:", st.F5DayMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bTransactionStatus:", st.BTransactionStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("precise:", st.Precise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f3MinMainMoneyInflow:", st.F3MinMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f3MinMainMoneyRatio:", st.F3MinMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f5MinMainMoneyInflow:", st.F5MinMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f5MinMainMoneyRatio:", st.F5MinMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + "ztData:" + st.ZtData.Display()
	ret = ret + ",  "
	ret = ret + "leadBlock:" + st.LeadBlock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f10MinMainMoneyInflow:", st.F10MinMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f10MinMainMoneyRatio:", st.F10MinMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f30MinMainMoneyInflow:", st.F30MinMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f30MinMainMoneyRatio:", st.F30MinMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f60MinMainMoneyInflow:", st.F60MinMainMoneyInflow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f60MinMainMoneyRatio:", st.F60MinMainMoneyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOpen:", st.DOpen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHigh:", st.DHigh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLow:", st.DLow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreClose:", st.DPreClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTradeNum:", st.LTradeNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAmount:", st.DAmount)
	ret = ret + ",  "
	ret = ret + "stTB:" + st.StTB.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vRTMinData:", st.VRTMinData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fZhenfu:", st.FZhenfu)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLiangBi:", st.FLiangBi)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fWeibi:", st.FWeibi)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiLYBCurrDayRank:", st.UiLYBCurrDayRank)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiLYBPreDayRank:", st.UiLYBPreDayRank)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f5DayChg:", st.F5DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f10DayChg:", st.F10DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("f20DayChg:", st.F20DayChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMonthChg:", st.FMonthChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fSeasonChg:", st.FSeasonChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fThisYearChg:", st.FThisYearChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fYearChg:", st.FYearChg)
	ret = ret + ",  "
	ret = ret + "stPrePostHq:" + st.StPrePostHq.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStockNum:", st.IStockNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTotalMarketValue:", st.FTotalMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fCirculationMarketValue:", st.FCirculationMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpNDay:", st.IUpNDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtThisYearUpTotalDay:", st.ShtThisYearUpTotalDay)

	ret = ret + " }"
	return ret
}

// HCQCX struct implement
type HCQCX struct {
	codec.JceStructBase
	SCode           string  `json:"sCode"`
	ShtSetCode      int16   `json:"shtSetCode"`
	IType           int32   `json:"iType"`
	IDate           int32   `json:"iDate"`
	FDividend       float64 `json:"fDividend"`
	FAllotmentPrice float64 `json:"fAllotmentPrice"`
	FBonusStock     float64 `json:"fBonusStock"`
	FAllotmentStock float64 `json:"fAllotmentStock"`
}

func (st *HCQCX) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCQCX) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IType, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FDividend, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FAllotmentPrice, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FBonusStock, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FAllotmentStock, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCQCX) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCQCX, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCQCX) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IType, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FDividend, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FAllotmentPrice, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FBonusStock, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FAllotmentStock, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCQCX) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCQCX) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetCode:", st.ShtSetCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iType:", st.IType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDividend:", st.FDividend)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAllotmentPrice:", st.FAllotmentPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fBonusStock:", st.FBonusStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fAllotmentStock:", st.FAllotmentStock)

	ret = ret + " }"
	return ret
}

// HAHItem struct implement
type HAHItem struct {
	codec.JceStructBase
	ShtMarket       int16   `json:"shtMarket"`
	SCode           string  `json:"sCode"`
	SName           string  `json:"sName"`
	FNowPrice       float64 `json:"fNowPrice"`
	FChg            float64 `json:"fChg"`
	FCurMarketValue float64 `json:"fCurMarketValue"`
	FTurnoverRate   float64 `json:"fTurnoverRate"`
	ITotalHand      int32   `json:"iTotalHand"`
	ShtOwnIndustry  int16   `json:"shtOwnIndustry"`
	DChangeValue    float64 `json:"dChangeValue"`
	ITradeDate      int32   `json:"iTradeDate"`
	ITradeTime      int32   `json:"iTradeTime"`
}

func (st *HAHItem) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HAHItem) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FNowPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FChg, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FCurMarketValue, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FTurnoverRate, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITotalHand, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtOwnIndustry, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DChangeValue, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeDate, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITradeTime, 11, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HAHItem) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HAHItem, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HAHItem) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FNowPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FChg, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FCurMarketValue, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FTurnoverRate, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITotalHand, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtOwnIndustry, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DChangeValue, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeDate, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITradeTime, 11)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HAHItem) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HAHItem) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNowPrice:", st.FNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fCurMarketValue:", st.FCurMarketValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTurnoverRate:", st.FTurnoverRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalHand:", st.ITotalHand)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtOwnIndustry:", st.ShtOwnIndustry)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dChangeValue:", st.DChangeValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeDate:", st.ITradeDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeTime:", st.ITradeTime)

	ret = ret + " }"
	return ret
}

// HAHStock struct implement
type HAHStock struct {
	codec.JceStructBase
	FPremiumRate float64 `json:"fPremiumRate"`
	StAItem      HAHItem `json:"stAItem"`
	StHItem      HAHItem `json:"stHItem"`
}

func (st *HAHStock) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StAItem.ResetDefault()
	st.StHItem.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HAHStock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.FPremiumRate, 1, false)
	if err != nil {
		return err
	}

	err = st.StAItem.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.StHItem.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HAHStock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HAHStock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HAHStock) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.FPremiumRate, 1)
	if err != nil {
		return err
	}

	err = st.StAItem.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.StHItem.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HAHStock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HAHStock) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fPremiumRate:", st.FPremiumRate)
	ret = ret + ",  "
	ret = ret + "stAItem:" + st.StAItem.Display()
	ret = ret + ",  "
	ret = ret + "stHItem:" + st.StHItem.Display()

	ret = ret + " }"
	return ret
}

// HTradePeriod struct implement
type HTradePeriod struct {
	codec.JceStructBase
	VTradePeriod []int16 `json:"vTradePeriod"`
}

func (st *HTradePeriod) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTradePeriod) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VTradePeriod = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VTradePeriod[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTradePeriod) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTradePeriod, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTradePeriod) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VTradePeriod)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VTradePeriod {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTradePeriod) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTradePeriod) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vTradePeriod:", st.VTradePeriod)

	ret = ret + " }"
	return ret
}

// HHotPlateStock struct implement
type HHotPlateStock struct {
	codec.JceStructBase
	ShtSetcode int16   `json:"shtSetcode"`
	SCode      string  `json:"sCode"`
	FClose     float64 `json:"fClose"`
	FPrice     float64 `json:"fPrice"`
	LVolume    int64   `json:"lVolume"`
	LAmount    int64   `json:"lAmount"`
	FOpen      float64 `json:"fOpen"`
	FHigh      float64 `json:"fHigh"`
	FLow       float64 `json:"fLow"`
	CDecimal   int8    `json:"cDecimal"`
}

func (st *HHotPlateStock) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHotPlateStock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FClose, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LAmount, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FOpen, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FHigh, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FLow, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CDecimal, 9, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHotPlateStock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHotPlateStock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHotPlateStock) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FClose, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LAmount, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FOpen, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FHigh, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FLow, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CDecimal, 9)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHotPlateStock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHotPlateStock) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fClose:", st.FClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPrice:", st.FPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lAmount:", st.LAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fOpen:", st.FOpen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fHigh:", st.FHigh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fLow:", st.FLow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cDecimal:", st.CDecimal)

	ret = ret + " }"
	return ret
}

// HL2Monit struct implement
type HL2Monit struct {
	codec.JceStructBase
	ShtSetcode int16   `json:"shtSetcode"`
	SCode      string  `json:"sCode"`
	SName      string  `json:"sName"`
	FPrice     float64 `json:"fPrice"`
	FChg       float32 `json:"fChg"`
	ITime      int32   `json:"iTime"`
	IType      int32   `json:"iType"`
	Djb        float64 `json:"djb"`
	Djs        float64 `json:"djs"`
	Tljb       float64 `json:"tljb"`
	Tljs       float64 `json:"tljs"`
	Dbcb       float64 `json:"dbcb"`
	Dbcs       float64 `json:"dbcs"`
	Cdb        float64 `json:"cdb"`
	Cds        float64 `json:"cds"`
	Dbb        float64 `json:"dbb"`
	Dbs        float64 `json:"dbs"`
	Fzt        int32   `json:"fzt"`
	Dkzt       int32   `json:"dkzt"`
	Fdt        int32   `json:"fdt"`
	Dkdt       int32   `json:"dkdt"`
	Ydb        float64 `json:"ydb"`
	Yds        float64 `json:"yds"`
	Hjfs       int32   `json:"hjfs"`
	Jsxd       int32   `json:"jsxd"`
	Ksft       int32   `json:"ksft"`
	Gtts       int32   `json:"gtts"`
}

func (st *HL2Monit) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HL2Monit) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FChg, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITime, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IType, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Djb, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Djs, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Tljb, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Tljs, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Dbcb, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Dbcs, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Cdb, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Cds, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Dbb, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Dbs, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Fzt, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Dkzt, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Fdt, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Dkdt, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Ydb, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Yds, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hjfs, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Jsxd, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Ksft, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Gtts, 26, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HL2Monit) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HL2Monit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HL2Monit) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FChg, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITime, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IType, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Djb, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Djs, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Tljb, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Tljs, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Dbcb, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Dbcs, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Cdb, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Cds, 14)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Dbb, 15)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Dbs, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Fzt, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Dkzt, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Fdt, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Dkdt, 20)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Ydb, 21)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Yds, 22)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hjfs, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Jsxd, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Ksft, 25)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Gtts, 26)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HL2Monit) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HL2Monit) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPrice:", st.FPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iType:", st.IType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("djb:", st.Djb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("djs:", st.Djs)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("tljb:", st.Tljb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("tljs:", st.Tljs)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dbcb:", st.Dbcb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dbcs:", st.Dbcs)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cdb:", st.Cdb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cds:", st.Cds)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dbb:", st.Dbb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dbs:", st.Dbs)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fzt:", st.Fzt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dkzt:", st.Dkzt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fdt:", st.Fdt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dkdt:", st.Dkdt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ydb:", st.Ydb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("yds:", st.Yds)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("hjfs:", st.Hjfs)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("jsxd:", st.Jsxd)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("ksft:", st.Ksft)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("gtts:", st.Gtts)

	ret = ret + " }"
	return ret
}

// HSZDetail struct implement
type HSZDetail struct {
	codec.JceStructBase
	ITime  int32   `json:"iTime"`
	INum   int32   `json:"iNum"`
	DPrice float64 `json:"dPrice"`
	DVol   float64 `json:"dVol"`
}

func (st *HSZDetail) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSZDetail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ITime, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.INum, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DVol, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSZDetail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSZDetail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSZDetail) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ITime, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.INum, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DVol, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSZDetail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSZDetail) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNum:", st.INum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dVol:", st.DVol)

	ret = ret + " }"
	return ret
}

// HSZFY struct implement
type HSZFY struct {
	codec.JceStructBase
	ShtSetcode int16       `json:"shtSetcode"`
	SCode      string      `json:"sCode"`
	SName      string      `json:"sName"`
	FPrice     float64     `json:"fPrice"`
	FChg       float32     `json:"fChg"`
	INum       int32       `json:"iNum"`
	Vol        float64     `json:"vol"`
	Value      float64     `json:"value"`
	VDetail    []HSZDetail `json:"vDetail"`
}

func (st *HSZFY) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSZFY) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FChg, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.INum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Vol, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Value, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VDetail = make([]HSZDetail, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VDetail[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSZFY) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSZFY, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSZFY) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FChg, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.INum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Vol, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Value, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VDetail)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VDetail {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSZFY) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSZFY) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPrice:", st.FPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iNum:", st.INum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vol:", st.Vol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("value:", st.Value)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vDetail:", st.VDetail)

	ret = ret + " }"
	return ret
}

// DxjlUnit struct implement
type DxjlUnit struct {
	codec.JceStructBase
	ICount int32   `json:"iCount"`
	DVol   float64 `json:"dVol"`
	DAmt   float64 `json:"dAmt"`
}

func (st *DxjlUnit) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *DxjlUnit) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ICount, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DVol, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAmt, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DxjlUnit) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DxjlUnit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DxjlUnit) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ICount, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DVol, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAmt, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DxjlUnit) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *DxjlUnit) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iCount:", st.ICount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dVol:", st.DVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAmt:", st.DAmt)

	ret = ret + " }"
	return ret
}

// HSZFYCom struct implement
type HSZFYCom struct {
	codec.JceStructBase
	ShtSetcode int16    `json:"shtSetcode"`
	SCode      string   `json:"sCode"`
	SName      string   `json:"sName"`
	FPrice     float64  `json:"fPrice"`
	FChg       float32  `json:"fChg"`
	StBuyUnit  DxjlUnit `json:"stBuyUnit"`
	StSellUnit DxjlUnit `json:"stSellUnit"`
}

func (st *HSZFYCom) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StBuyUnit.ResetDefault()
	st.StSellUnit.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSZFYCom) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.FPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FChg, 4, false)
	if err != nil {
		return err
	}

	err = st.StBuyUnit.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.StSellUnit.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSZFYCom) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSZFYCom, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSZFYCom) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.FPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FChg, 4)
	if err != nil {
		return err
	}

	err = st.StBuyUnit.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.StSellUnit.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSZFYCom) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSZFYCom) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPrice:", st.FPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fChg:", st.FChg)
	ret = ret + ",  "
	ret = ret + "stBuyUnit:" + st.StBuyUnit.Display()
	ret = ret + ",  "
	ret = ret + "stSellUnit:" + st.StSellUnit.Display()

	ret = ret + " }"
	return ret
}

// HCPTMin struct implement
type HCPTMin struct {
	codec.JceStructBase
	UiTradeSeq  uint32 `json:"uiTradeSeq"`
	UiTradeDate uint32 `json:"uiTradeDate"`
	UiTradeTime uint32 `json:"uiTradeTime"`
}

func (st *HCPTMin) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCPTMin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint32(&st.UiTradeSeq, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiTradeDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiTradeTime, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCPTMin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCPTMin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCPTMin) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint32(st.UiTradeSeq, 1)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiTradeDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiTradeTime, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCPTMin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCPTMin) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("uiTradeSeq:", st.UiTradeSeq)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiTradeDate:", st.UiTradeDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiTradeTime:", st.UiTradeTime)

	ret = ret + " }"
	return ret
}

// HTradeTime struct implement
type HTradeTime struct {
	codec.JceStructBase
	ITradeDate int32 `json:"iTradeDate"`
	IBegTime   int32 `json:"iBegTime"`
	IEndTime   int32 `json:"iEndTime"`
	IFlag      int32 `json:"iFlag"`
}

func (st *HTradeTime) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IFlag = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HTradeTime) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ITradeDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IBegTime, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEndTime, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IFlag, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTradeTime) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTradeTime, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTradeTime) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ITradeDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IBegTime, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEndTime, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IFlag, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTradeTime) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTradeTime) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iTradeDate:", st.ITradeDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iBegTime:", st.IBegTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndTime:", st.IEndTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iFlag:", st.IFlag)

	ret = ret + " }"
	return ret
}

// HTradePeriodTime struct implement
type HTradePeriodTime struct {
	codec.JceStructBase
	VPeriod    []HTradeTime                     `json:"vPeriod"`
	MPeriod    map[int16][]HTradeTime           `json:"mPeriod"`
	MSubPeriod map[int16]map[int16][]HTradeTime `json:"mSubPeriod"`
}

func (st *HTradePeriodTime) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTradePeriodTime) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VPeriod = make([]HTradeTime, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VPeriod[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have = _is.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MPeriod = make(map[int16][]HTradeTime)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int16
			var v1 []HTradeTime

			err = _is.Read_int16(&k1, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v1 = make([]HTradeTime, length)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {

						err = v1[i2].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.MPeriod[k1] = v1
		}
	}

	err, have = _is.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MSubPeriod = make(map[int16]map[int16][]HTradeTime)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 int16
			var v3 map[int16][]HTradeTime

			err = _is.Read_int16(&k3, 0, false)
			if err != nil {
				return err
			}

			err, have = _is.SkipTo(codec.MAP, 1, false)
			if err != nil {
				return err
			}

			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return err
				}

				v3 = make(map[int16][]HTradeTime)
				for i4, e4 := int32(0), length; i4 < e4; i4++ {
					var k4 int16
					var v4 []HTradeTime

					err = _is.Read_int16(&k4, 0, false)
					if err != nil {
						return err
					}

					err, have, ty = _is.SkipToNoCheck(1, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return err
							}

							v4 = make([]HTradeTime, length)
							for i5, e5 := int32(0), length; i5 < e5; i5++ {

								err = v4[i5].ReadBlock(_is, 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SIMPLE_LIST {
							err = fmt.Errorf("not support simple_list type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}

					v3[k4] = v4
				}
			}

			st.MSubPeriod[k3] = v3
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTradePeriodTime) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTradePeriodTime, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTradePeriodTime) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VPeriod)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VPeriod {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MPeriod)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.MPeriod {

		err = _os.Write_int16(k6, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v6)), 0)
		if err != nil {
			return err
		}

		for _, v := range v6 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MSubPeriod)), 0)
	if err != nil {
		return err
	}

	for k7, v7 := range st.MSubPeriod {

		err = _os.Write_int16(k7, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v7)), 0)
		if err != nil {
			return err
		}

		for k8, v8 := range v7 {

			err = _os.Write_int16(k8, 0)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.LIST, 1)
			if err != nil {
				return err
			}

			err = _os.Write_int32(int32(len(v8)), 0)
			if err != nil {
				return err
			}

			for _, v := range v8 {

				err = v.WriteBlock(_os, 0)
				if err != nil {
					return err
				}

			}
		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTradePeriodTime) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTradePeriodTime) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vPeriod:", st.VPeriod)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mPeriod:", st.MPeriod)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mSubPeriod:", st.MSubPeriod)

	ret = ret + " }"
	return ret
}

// HFinData struct implement
type HFinData struct {
	codec.JceStructBase
	ShtSetCode        int16   `json:"shtSetCode"`
	SCode             string  `json:"sCode"`
	DFlowStock        float64 `json:"dFlowStock"`
	ShtAddr           int16   `json:"shtAddr"`
	ShtHy             int16   `json:"shtHy"`
	LNewDate          int64   `json:"lNewDate"`
	LStartDate        int64   `json:"lStartDate"`
	DTotalStock       float64 `json:"dTotalStock"`
	DNatinalStock     float64 `json:"dNatinalStock"`
	DFounderStock     float64 `json:"dFounderStock"`
	DBStock           float64 `json:"dBStock"`
	DHStock           float64 `json:"dHStock"`
	DWorkerStock      float64 `json:"dWorkerStock"`
	DTotalValue       float64 `json:"dTotalValue"`
	DFixedValue       float64 `json:"dFixedValue"`
	DFlowValue        float64 `json:"dFlowValue"`
	DWxValue          float64 `json:"dWxValue"`
	DLongValue        float64 `json:"dLongValue"`
	DFlowLoad         float64 `json:"dFlowLoad"`
	DLongLoad         float64 `json:"dLongLoad"`
	DCapitalValue     float64 `json:"dCapitalValue"`
	DRightValue       float64 `json:"dRightValue"`
	DMainValue        float64 `json:"dMainValue"`
	DMainInterest     float64 `json:"dMainInterest"`
	DOtherInterest    float64 `json:"dOtherInterest"`
	DBusInterest      float64 `json:"dBusInterest"`
	DInvestInterest   float64 `json:"dInvestInterest"`
	DBuTieValue       float64 `json:"dBuTieValue"`
	DOutValue         float64 `json:"dOutValue"`
	DLoseAdjust       float64 `json:"dLoseAdjust"`
	DProfitValue      float64 `json:"dProfitValue"`
	DAfterTaxValue    float64 `json:"dAfterTaxValue"`
	DNetValue         float64 `json:"dNetValue"`
	DUnDistibuteValue float64 `json:"dUnDistibuteValue"`
	DAdjustValue      float64 `json:"dAdjustValue"`
	DHalfYearFlag     float64 `json:"dHalfYearFlag"`
}

func (st *HFinData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFinData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFlowStock, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtAddr, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtHy, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LNewDate, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LStartDate, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTotalStock, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNatinalStock, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFounderStock, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBStock, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHStock, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DWorkerStock, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTotalValue, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFixedValue, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFlowValue, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DWxValue, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLongValue, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFlowLoad, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLongLoad, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCapitalValue, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRightValue, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMainValue, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMainInterest, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOtherInterest, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBusInterest, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DInvestInterest, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuTieValue, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOutValue, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLoseAdjust, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DProfitValue, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAfterTaxValue, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNetValue, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DUnDistibuteValue, 33, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAdjustValue, 34, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHalfYearFlag, 35, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFinData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFinData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFinData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFlowStock, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtAddr, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtHy, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LNewDate, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LStartDate, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTotalStock, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNatinalStock, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFounderStock, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBStock, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHStock, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DWorkerStock, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTotalValue, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFixedValue, 14)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFlowValue, 15)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DWxValue, 16)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLongValue, 17)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFlowLoad, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLongLoad, 19)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCapitalValue, 20)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRightValue, 21)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMainValue, 22)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMainInterest, 23)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOtherInterest, 24)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBusInterest, 25)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DInvestInterest, 26)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuTieValue, 27)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOutValue, 28)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLoseAdjust, 29)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DProfitValue, 30)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAfterTaxValue, 31)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNetValue, 32)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DUnDistibuteValue, 33)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAdjustValue, 34)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHalfYearFlag, 35)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFinData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFinData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetCode:", st.ShtSetCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFlowStock:", st.DFlowStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtAddr:", st.ShtAddr)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtHy:", st.ShtHy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lNewDate:", st.LNewDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lStartDate:", st.LStartDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTotalStock:", st.DTotalStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNatinalStock:", st.DNatinalStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFounderStock:", st.DFounderStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBStock:", st.DBStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHStock:", st.DHStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dWorkerStock:", st.DWorkerStock)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTotalValue:", st.DTotalValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFixedValue:", st.DFixedValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFlowValue:", st.DFlowValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dWxValue:", st.DWxValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLongValue:", st.DLongValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFlowLoad:", st.DFlowLoad)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLongLoad:", st.DLongLoad)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCapitalValue:", st.DCapitalValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRightValue:", st.DRightValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMainValue:", st.DMainValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMainInterest:", st.DMainInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOtherInterest:", st.DOtherInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBusInterest:", st.DBusInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dInvestInterest:", st.DInvestInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuTieValue:", st.DBuTieValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOutValue:", st.DOutValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLoseAdjust:", st.DLoseAdjust)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dProfitValue:", st.DProfitValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAfterTaxValue:", st.DAfterTaxValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNetValue:", st.DNetValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dUnDistibuteValue:", st.DUnDistibuteValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAdjustValue:", st.DAdjustValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHalfYearFlag:", st.DHalfYearFlag)

	ret = ret + " }"
	return ret
}

// HMarketInit struct implement
type HMarketInit struct {
	codec.JceStructBase
	ShtSetCode  int16  `json:"shtSetCode"`
	UiTradeSeq  uint32 `json:"uiTradeSeq"`
	UiTradeDate uint32 `json:"uiTradeDate"`
}

func (st *HMarketInit) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketInit) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiTradeSeq, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiTradeDate, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketInit) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketInit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketInit) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiTradeSeq, 2)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiTradeDate, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketInit) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketInit) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetCode:", st.ShtSetCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiTradeSeq:", st.UiTradeSeq)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiTradeDate:", st.UiTradeDate)

	ret = ret + " }"
	return ret
}

// HStockIndustry struct implement
type HStockIndustry struct {
	codec.JceStructBase
	ShtSetcode         int16   `json:"shtSetcode"`
	SCode              string  `json:"sCode"`
	SName              string  `json:"sName"`
	DNowPrice          float64 `json:"dNowPrice"`
	DChgValue          float64 `json:"dChgValue"`
	DChgRatio          float64 `json:"dChgRatio"`
	BTransactionStatus int8    `json:"bTransactionStatus"`
	SIndustryName      string  `json:"sIndustryName"`
	SIndustryCode      string  `json:"sIndustryCode"`
}

func (st *HStockIndustry) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockIndustry) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNowPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DChgValue, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DChgRatio, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BTransactionStatus, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SIndustryName, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SIndustryCode, 9, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockIndustry) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockIndustry, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockIndustry) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNowPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DChgValue, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DChgRatio, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BTransactionStatus, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SIndustryName, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SIndustryCode, 9)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockIndustry) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockIndustry) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNowPrice:", st.DNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dChgValue:", st.DChgValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dChgRatio:", st.DChgRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bTransactionStatus:", st.BTransactionStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sIndustryName:", st.SIndustryName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sIndustryCode:", st.SIndustryCode)

	ret = ret + " }"
	return ret
}

// HStockDictInfo struct implement
type HStockDictInfo struct {
	codec.JceStructBase
	Code        string  `json:"Code"`
	Unit        int16   `json:"Unit"`
	Name        string  `json:"Name"`
	VolBase     int32   `json:"VolBase"`
	Precise     int8    `json:"precise"`
	Close       float32 `json:"Close"`
	Market      int16   `json:"Market"`
	IType       int16   `json:"iType"`
	BDiffRight  bool    `json:"bDiffRight"`
	BCDR        bool    `json:"bCDR"`
	BGDR        bool    `json:"bGDR"`
	IUnit       int32   `json:"iUnit"`
	BDeficit    bool    `json:"bDeficit"`
	BProControl bool    `json:"bProControl"`
}

func (st *HStockDictInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BDiffRight = true
	st.BCDR = false
	st.BGDR = false
	st.IUnit = 0
	st.BDeficit = false
	st.BProControl = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDictInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Unit, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.VolBase, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.Precise, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.Close, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Market, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.IType, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDiffRight, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCDR, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BGDR, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUnit, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDeficit, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BProControl, 15, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDictInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDictInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDictInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.Code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Unit, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.VolBase, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.Precise, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.Close, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Market, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.IType, 9)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDiffRight, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCDR, 11)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BGDR, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUnit, 13)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDeficit, 14)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BProControl, 15)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDictInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDictInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("Code:", st.Code)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("Unit:", st.Unit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("Name:", st.Name)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("VolBase:", st.VolBase)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("precise:", st.Precise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("Close:", st.Close)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("Market:", st.Market)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iType:", st.IType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDiffRight:", st.BDiffRight)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCDR:", st.BCDR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bGDR:", st.BGDR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUnit:", st.IUnit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDeficit:", st.BDeficit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bProControl:", st.BProControl)

	ret = ret + " }"
	return ret
}

// HStockDictInfoSimple struct implement
type HStockDictInfoSimple struct {
	codec.JceStructBase
	Code string            `json:"code"`
	Name string            `json:"name"`
	Type int16             `json:"type"`
	M1   map[int32]float64 `json:"m1"`
	M2   map[int32]string  `json:"m2"`
}

func (st *HStockDictInfoSimple) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDictInfoSimple) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.Code, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.Type, 3, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 4, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M1 = make(map[int32]float64)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 float64

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_float64(&v0, 1, false)
			if err != nil {
				return err
			}

			st.M1[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 5, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.M2 = make(map[int32]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int32
			var v1 string

			err = _is.Read_int32(&k1, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v1, 1, false)
			if err != nil {
				return err
			}

			st.M2[k1] = v1
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDictInfoSimple) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDictInfoSimple, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDictInfoSimple) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.Code, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.Type, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M1)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.M1 {

		err = _os.Write_int32(k2, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(v2, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M2)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.M2 {

		err = _os.Write_int32(k3, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(v3, 1)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDictInfoSimple) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDictInfoSimple) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("code:", st.Code)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("name:", st.Name)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("type:", st.Type)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m1:", st.M1)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("m2:", st.M2)

	ret = ret + " }"
	return ret
}

// HOrderItem struct implement
type HOrderItem struct {
	codec.JceStructBase
	LVolume int64             `json:"lVolume"`
	EStatus E_ORDER_ITEM_TYPE `json:"eStatus"`
}

func (st *HOrderItem) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderItem) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LVolume, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStatus), 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderItem) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderItem, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderItem) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LVolume, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStatus), 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderItem) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderItem) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)

	ret = ret + " }"
	return ret
}

// HOrderQueue struct implement
type HOrderQueue struct {
	codec.JceStructBase
	LTime     int64        `json:"lTime"`
	DPrice    float64      `json:"dPrice"`
	LVolume   int64        `json:"lVolume"`
	BBuySell  int8         `json:"bBuySell"`
	LOrderNum int64        `json:"lOrderNum"`
	VOrder    []HOrderItem `json:"vOrder"`
}

func (st *HOrderQueue) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderQueue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LTime, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BBuySell, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LOrderNum, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VOrder = make([]HOrderItem, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VOrder[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderQueue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderQueue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderQueue) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LTime, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BBuySell, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LOrderNum, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VOrder)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VOrder {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderQueue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderQueue) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lTime:", st.LTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bBuySell:", st.BBuySell)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lOrderNum:", st.LOrderNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vOrder:", st.VOrder)

	ret = ret + " }"
	return ret
}

// HTransaction struct implement
type HTransaction struct {
	codec.JceStructBase
	LTime        int64   `json:"lTime"`
	LTradeNo     int64   `json:"lTradeNo"`
	BType        int8    `json:"bType"`
	DPrice       float64 `json:"dPrice"`
	LVolume      int64   `json:"lVolume"`
	LBuyNo       int64   `json:"lBuyNo"`
	LSellNo      int64   `json:"lSellNo"`
	LBargainNo   int64   `json:"lBargainNo"`
	ShtTradeType int16   `json:"shtTradeType"`
}

func (st *HTransaction) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTransaction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LTime, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTradeNo, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.BType, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyNo, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellNo, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBargainNo, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtTradeType, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTransaction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTransaction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTransaction) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LTime, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTradeNo, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.BType, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyNo, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellNo, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBargainNo, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtTradeType, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTransaction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTransaction) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lTime:", st.LTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTradeNo:", st.LTradeNo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bType:", st.BType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyNo:", st.LBuyNo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellNo:", st.LSellNo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBargainNo:", st.LBargainNo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtTradeType:", st.ShtTradeType)

	ret = ret + " }"
	return ret
}

// HOrderRec struct implement
type HOrderRec struct {
	codec.JceStructBase
	LTime      int64                `json:"lTime"`
	LTradeNo   int64                `json:"lTradeNo"`
	DPrice     float64              `json:"dPrice"`
	LVolume    int64                `json:"lVolume"`
	ETradeKind E_ORDER_TRADE_KINDE  `json:"eTradeKind"`
	EOPType    E_ORDER_OPERATE_TYPE `json:"eOPType"`
	LOrderNo   int64                `json:"lOrderNo"`
}

func (st *HOrderRec) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderRec) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LTime, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTradeNo, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ETradeKind), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EOPType), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LOrderNo, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderRec) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderRec, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderRec) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LTime, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTradeNo, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ETradeKind), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EOPType), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LOrderNo, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderRec) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderRec) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lTime:", st.LTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTradeNo:", st.LTradeNo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eTradeKind:", st.ETradeKind)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eOPType:", st.EOPType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lOrderNo:", st.LOrderNo)

	ret = ret + " }"
	return ret
}

// HPriceVolInfo struct implement
type HPriceVolInfo struct {
	codec.JceStructBase
	DPrice   float64 `json:"dPrice"`
	LVol     int64   `json:"lVol"`
	LBuyVol  int64   `json:"lBuyVol"`
	LSellVol int64   `json:"lSellVol"`
	LBuyNum  int64   `json:"lBuyNum"`
	LSellNum int64   `json:"lSellNum"`
}

func (st *HPriceVolInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.DPrice = 0.0
	st.LVol = 0
	st.LBuyVol = 0
	st.LSellVol = 0
	st.LBuyNum = 0
	st.LSellNum = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HPriceVolInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DPrice, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVol, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyVol, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellVol, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellNum, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPriceVolInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPriceVolInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPriceVolInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DPrice, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVol, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyVol, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellVol, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellNum, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPriceVolInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPriceVolInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVol:", st.LVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyVol:", st.LBuyVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellVol:", st.LSellVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyNum:", st.LBuyNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellNum:", st.LSellNum)

	ret = ret + " }"
	return ret
}

// HTransVolNum struct implement
type HTransVolNum struct {
	codec.JceStructBase
	EVolRange TRANS_VOL_RANGE `json:"eVolRange"`
	LBuyNum   int64           `json:"lBuyNum"`
	LSellNum  int64           `json:"lSellNum"`
}

func (st *HTransVolNum) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTransVolNum) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.EVolRange), 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyNum, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellNum, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTransVolNum) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTransVolNum, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTransVolNum) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.EVolRange), 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyNum, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellNum, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTransVolNum) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTransVolNum) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eVolRange:", st.EVolRange)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyNum:", st.LBuyNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellNum:", st.LSellNum)

	ret = ret + " }"
	return ret
}

// HOrderSumStat struct implement
type HOrderSumStat struct {
	codec.JceStructBase
	DBuyAvgPrice      float64       `json:"dBuyAvgPrice"`
	LBuyVol           int64         `json:"lBuyVol"`
	LBuyOrderCount    int64         `json:"lBuyOrderCount"`
	LBuyNum           int64         `json:"lBuyNum"`
	LBigBuyVol        int64         `json:"lBigBuyVol"`
	LAllBuyNum        int64         `json:"lAllBuyNum"`
	LBuyCancelNum     int64         `json:"lBuyCancelNum"`
	LBigBuyCancelNum  int64         `json:"lBigBuyCancelNum"`
	DSellAvgPrice     float64       `json:"dSellAvgPrice"`
	LSellVol          int64         `json:"lSellVol"`
	LSellOrderCount   int64         `json:"lSellOrderCount"`
	LSellNum          int64         `json:"lSellNum"`
	LBigSellVol       int64         `json:"lBigSellVol"`
	LAllSellNum       int64         `json:"lAllSellNum"`
	LSellCancelNum    int64         `json:"lSellCancelNum"`
	LBigSellCancelNum int64         `json:"lBigSellCancelNum"`
	Obstruction       HPriceVolInfo `json:"obstruction"`
	Support           HPriceVolInfo `json:"support"`
}

func (st *HOrderSumStat) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Obstruction.ResetDefault()
	st.Support.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderSumStat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DBuyAvgPrice, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyVol, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyOrderCount, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBigBuyVol, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LAllBuyNum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBuyCancelNum, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBigBuyCancelNum, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellAvgPrice, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellVol, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellOrderCount, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellNum, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBigSellVol, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LAllSellNum, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSellCancelNum, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBigSellCancelNum, 15, false)
	if err != nil {
		return err
	}

	err = st.Obstruction.ReadBlock(_is, 16, false)
	if err != nil {
		return err
	}

	err = st.Support.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderSumStat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderSumStat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderSumStat) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DBuyAvgPrice, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyVol, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyOrderCount, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBigBuyVol, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LAllBuyNum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBuyCancelNum, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBigBuyCancelNum, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellAvgPrice, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellVol, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellOrderCount, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellNum, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBigSellVol, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LAllSellNum, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSellCancelNum, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBigSellCancelNum, 15)
	if err != nil {
		return err
	}

	err = st.Obstruction.WriteBlock(_os, 16)
	if err != nil {
		return err
	}

	err = st.Support.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderSumStat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderSumStat) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dBuyAvgPrice:", st.DBuyAvgPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyVol:", st.LBuyVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyOrderCount:", st.LBuyOrderCount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyNum:", st.LBuyNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBigBuyVol:", st.LBigBuyVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lAllBuyNum:", st.LAllBuyNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBuyCancelNum:", st.LBuyCancelNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBigBuyCancelNum:", st.LBigBuyCancelNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellAvgPrice:", st.DSellAvgPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellVol:", st.LSellVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellOrderCount:", st.LSellOrderCount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellNum:", st.LSellNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBigSellVol:", st.LBigSellVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lAllSellNum:", st.LAllSellNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSellCancelNum:", st.LSellCancelNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBigSellCancelNum:", st.LBigSellCancelNum)
	ret = ret + ",  "
	ret = ret + "obstruction:" + st.Obstruction.Display()
	ret = ret + ",  "
	ret = ret + "support:" + st.Support.Display()

	ret = ret + " }"
	return ret
}

// HOrderQueuePrice struct implement
type HOrderQueuePrice struct {
	codec.JceStructBase
	DPrice      float64           `json:"dPrice"`
	LSumVol     int64             `json:"lSumVol"`
	LBigVol     int64             `json:"lBigVol"`
	LTotalOrder int64             `json:"lTotalOrder"`
	EStatus     E_ORDER_ITEM_TYPE `json:"eStatus"`
}

func (st *HOrderQueuePrice) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderQueuePrice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DPrice, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSumVol, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBigVol, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTotalOrder, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStatus), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderQueuePrice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderQueuePrice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderQueuePrice) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DPrice, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSumVol, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBigVol, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTotalOrder, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStatus), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderQueuePrice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderQueuePrice) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSumVol:", st.LSumVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBigVol:", st.LBigVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTotalOrder:", st.LTotalOrder)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)

	ret = ret + " }"
	return ret
}

// HPriceAmount struct implement
type HPriceAmount struct {
	codec.JceStructBase
	LOrderNo int64             `json:"lOrderNo"`
	LVolume  int64             `json:"lVolume"`
	EStatus  E_ORDER_ITEM_TYPE `json:"eStatus"`
}

func (st *HPriceAmount) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPriceAmount) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LOrderNo, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVolume, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStatus), 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPriceAmount) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPriceAmount, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPriceAmount) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LOrderNo, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVolume, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStatus), 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPriceAmount) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPriceAmount) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lOrderNo:", st.LOrderNo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVolume:", st.LVolume)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)

	ret = ret + " }"
	return ret
}

// HOrderBookItem struct implement
type HOrderBookItem struct {
	codec.JceStructBase
	Price float64 `json:"price"`
	Qty   int64   `json:"qty"`
	Num   int32   `json:"num"`
}

func (st *HOrderBookItem) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOrderBookItem) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.Price, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Qty, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Num, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOrderBookItem) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOrderBookItem, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOrderBookItem) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.Price, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Qty, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Num, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOrderBookItem) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOrderBookItem) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("price:", st.Price)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("qty:", st.Qty)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("num:", st.Num)

	ret = ret + " }"
	return ret
}

// HZHRankData struct implement
type HZHRankData struct {
	codec.JceStructBase
	ERankType  H_ZH_RANK_TYPE `json:"eRankType"`
	ShtSetcode int16          `json:"shtSetcode"`
	SCode      string         `json:"sCode"`
	DNowPrice  float64        `json:"dNowPrice"`
	DRankValue float64        `json:"dRankValue"`
	DPrevClose float64        `json:"dPrevClose"`
}

func (st *HZHRankData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HZHRankData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.ERankType), 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNowPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRankValue, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrevClose, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HZHRankData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HZHRankData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HZHRankData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.ERankType), 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNowPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRankValue, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrevClose, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HZHRankData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HZHRankData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eRankType:", st.ERankType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNowPrice:", st.DNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRankValue:", st.DRankValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrevClose:", st.DPrevClose)

	ret = ret + " }"
	return ret
}

// HStockRankData struct implement
type HStockRankData struct {
	codec.JceStructBase
	ShtSetCode int16   `json:"shtSetCode"`
	SCode      string  `json:"sCode"`
	DRankValue float64 `json:"dRankValue"`
}

func (st *HStockRankData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockRankData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRankValue, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockRankData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockRankData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockRankData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRankValue, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockRankData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockRankData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetCode:", st.ShtSetCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRankValue:", st.DRankValue)

	ret = ret + " }"
	return ret
}

// HBKLedData struct implement
type HBKLedData struct {
	codec.JceStructBase
	ShtSetCode int16            `json:"shtSetCode"`
	SCode      string           `json:"sCode"`
	DRankValue float64          `json:"dRankValue"`
	IUpNum     int32            `json:"iUpNum"`
	IEqualNum  int32            `json:"iEqualNum"`
	IDownNum   int32            `json:"iDownNum"`
	VStock     []HStockRankData `json:"vStock"`
}

func (st *HBKLedData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HBKLedData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DRankValue, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpNum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEqualNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDownNum, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]HStockRankData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBKLedData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBKLedData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBKLedData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DRankValue, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpNum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEqualNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDownNum, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBKLedData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBKLedData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetCode:", st.ShtSetCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dRankValue:", st.DRankValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpNum:", st.IUpNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEqualNum:", st.IEqualNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDownNum:", st.IDownNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// HDDZData struct implement
type HDDZData struct {
	codec.JceStructBase
	StMfAmt HTolMoneyFlow `json:"stMfAmt"`
	StMfVol HTolMoneyFlow `json:"stMfVol"`
	StMfNum HTolMoneyFlow `json:"stMfNum"`
	ITime   int32         `json:"iTime"`
	IDate   int32         `json:"iDate"`
}

func (st *HDDZData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StMfAmt.ResetDefault()
	st.StMfVol.ResetDefault()
	st.StMfNum.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HDDZData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StMfAmt.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.StMfVol.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.StMfNum.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITime, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HDDZData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HDDZData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HDDZData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StMfAmt.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.StMfVol.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.StMfNum.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITime, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HDDZData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HDDZData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stMfAmt:" + st.StMfAmt.Display()
	ret = ret + ",  "
	ret = ret + "stMfVol:" + st.StMfVol.Display()
	ret = ret + ",  "
	ret = ret + "stMfNum:" + st.StMfNum.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)

	ret = ret + " }"
	return ret
}

// HTypeStatusData struct implement
type HTypeStatusData struct {
	codec.JceStructBase
	EType   E_MARKET_TYPE `json:"eType"`
	IStatus int32         `json:"iStatus"`
}

func (st *HTypeStatusData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTypeStatusData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.EType), 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStatus, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTypeStatusData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTypeStatusData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTypeStatusData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.EType), 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStatus, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTypeStatusData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTypeStatusData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStatus:", st.IStatus)

	ret = ret + " }"
	return ret
}

// HMarketStatusData struct implement
type HMarketStatusData struct {
	codec.JceStructBase
	ShtMarket        int16                     `json:"shtMarket"`
	IStatus          int32                     `json:"iStatus"`
	MapTypeStaus     map[int16]int32           `json:"mapTypeStaus"`
	MapSubTypeStatus map[int16]map[int16]int32 `json:"mapSubTypeStatus"`
}

func (st *HMarketStatusData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IStatus = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketStatusData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStatus, 1, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapTypeStaus = make(map[int16]int32)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 int32

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MapTypeStaus[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapSubTypeStatus = make(map[int16]map[int16]int32)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int16
			var v1 map[int16]int32

			err = _is.Read_int16(&k1, 0, false)
			if err != nil {
				return err
			}

			err, have = _is.SkipTo(codec.MAP, 1, false)
			if err != nil {
				return err
			}

			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return err
				}

				v1 = make(map[int16]int32)
				for i2, e2 := int32(0), length; i2 < e2; i2++ {
					var k2 int16
					var v2 int32

					err = _is.Read_int16(&k2, 0, false)
					if err != nil {
						return err
					}

					err = _is.Read_int32(&v2, 1, false)
					if err != nil {
						return err
					}

					v1[k2] = v2
				}
			}

			st.MapSubTypeStatus[k1] = v1
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketStatusData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketStatusData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketStatusData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStatus, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapTypeStaus)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.MapTypeStaus {

		err = _os.Write_int16(k3, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(v3, 1)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapSubTypeStatus)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.MapSubTypeStatus {

		err = _os.Write_int16(k4, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v4)), 0)
		if err != nil {
			return err
		}

		for k5, v5 := range v4 {

			err = _os.Write_int16(k5, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v5, 1)
			if err != nil {
				return err
			}

		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketStatusData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketStatusData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStatus:", st.IStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapTypeStaus:", st.MapTypeStaus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mapSubTypeStatus:", st.MapSubTypeStatus)

	ret = ret + " }"
	return ret
}

// HFileInfo struct implement
type HFileInfo struct {
	codec.JceStructBase
	SFileName string `json:"sFileName"`
	IPos      int32  `json:"iPos"`
	SCheckSum string `json:"sCheckSum"`
	ILen      int32  `json:"iLen"`
	BCompress bool   `json:"bCompress"`
}

func (st *HFileInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HFileInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SFileName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IPos, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCheckSum, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ILen, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCompress, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFileInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFileInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFileInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SFileName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IPos, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCheckSum, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ILen, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCompress, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFileInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFileInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sFileName:", st.SFileName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iPos:", st.IPos)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iLen:", st.ILen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCompress:", st.BCompress)

	ret = ret + " }"
	return ret
}

// HFileData struct implement
type HFileData struct {
	codec.JceStructBase
	SFileName string `json:"sFileName"`
	BCompress bool   `json:"bCompress"`
	BChg      bool   `json:"bChg"`
	VBuf      []int8 `json:"vBuf"`
	BRemain   bool   `json:"bRemain"`
	SCheckSum string `json:"sCheckSum"`
}

func (st *HFileData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BChg = false
	st.BRemain = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HFileData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SFileName, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCompress, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BChg, 3, true)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VBuf = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VBuf[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VBuf, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.BRemain, 5, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCheckSum, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFileData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFileData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFileData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SFileName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCompress, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BChg, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VBuf)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VBuf)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BRemain, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCheckSum, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFileData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFileData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sFileName:", st.SFileName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCompress:", st.BCompress)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bChg:", st.BChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vBuf:", st.VBuf)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bRemain:", st.BRemain)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)

	ret = ret + " }"
	return ret
}

// HRigthUnit struct implement
type HRigthUnit struct {
	codec.JceStructBase
	SRightId   string `json:"sRightId"`
	SBeginDate string `json:"sBeginDate"`
	SEndDate   string `json:"sEndDate"`
}

func (st *HRigthUnit) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRigthUnit) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SRightId, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SBeginDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SEndDate, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRigthUnit) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRigthUnit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRigthUnit) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SRightId, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SBeginDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SEndDate, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRigthUnit) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRigthUnit) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sRightId:", st.SRightId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sBeginDate:", st.SBeginDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sEndDate:", st.SEndDate)

	ret = ret + " }"
	return ret
}

// HUserRight struct implement
type HUserRight struct {
	codec.JceStructBase
	SUserId           string       `json:"sUserId"`
	VRight            []HRigthUnit `json:"vRight"`
	SRd               string       `json:"sRd"`
	SSsoDate          string       `json:"sSsoDate"`
	BAllowRepeatLogin bool         `json:"bAllowRepeatLogin"`
}

func (st *HUserRight) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BAllowRepeatLogin = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HUserRight) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SUserId, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRight = make([]HRigthUnit, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRight[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.SRd, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSsoDate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BAllowRepeatLogin, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HUserRight) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HUserRight, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HUserRight) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SUserId, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRight)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRight {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.SRd, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSsoDate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BAllowRepeatLogin, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HUserRight) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HUserRight) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sUserId:", st.SUserId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vRight:", st.VRight)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sRd:", st.SRd)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSsoDate:", st.SSsoDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bAllowRepeatLogin:", st.BAllowRepeatLogin)

	ret = ret + " }"
	return ret
}

// HLoginInfo struct implement
type HLoginInfo struct {
	codec.JceStructBase
	SUserId         string              `json:"sUserId"`
	SRd             string              `json:"sRd"`
	SPermission     string              `json:"sPermission"`
	SSsoTime        string              `json:"sSsoTime"`
	SCltTime        string              `json:"sCltTime"`
	LCltConId       int64               `json:"lCltConId"`
	ECltType        E_LOGIN_CLIENT_TYPE `json:"eCltType"`
	ShtDelFlag      int16               `json:"shtDelFlag"`
	StUserRight     HUserRight          `json:"stUserRight"`
	EAuthType       E_LOGIN_AUTH_TYPE   `json:"eAuthType"`
	SSvrId          string              `json:"sSvrId"`
	SGuid           string              `json:"sGuid"`
	BKickoutDiffClt bool                `json:"bKickoutDiffClt"`
}

func (st *HLoginInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StUserRight.ResetDefault()
	st.EAuthType = E_LOGIN_AUTH_TYPE_E_LOGIN_AUTH_SZ_SH
	st.BKickoutDiffClt = true
}

//ReadFrom reads  from _is and put into struct.
func (st *HLoginInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SUserId, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SRd, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SPermission, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSsoTime, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCltTime, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LCltConId, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.ECltType), 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDelFlag, 8, false)
	if err != nil {
		return err
	}

	err = st.StUserRight.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EAuthType), 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSvrId, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SGuid, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BKickoutDiffClt, 13, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HLoginInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HLoginInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HLoginInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SUserId, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SRd, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SPermission, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSsoTime, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCltTime, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LCltConId, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.ECltType), 7)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDelFlag, 8)
	if err != nil {
		return err
	}

	err = st.StUserRight.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EAuthType), 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSvrId, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SGuid, 12)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BKickoutDiffClt, 13)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HLoginInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HLoginInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sUserId:", st.SUserId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sRd:", st.SRd)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sPermission:", st.SPermission)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSsoTime:", st.SSsoTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCltTime:", st.SCltTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lCltConId:", st.LCltConId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eCltType:", st.ECltType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDelFlag:", st.ShtDelFlag)
	ret = ret + ",  "
	ret = ret + "stUserRight:" + st.StUserRight.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eAuthType:", st.EAuthType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSvrId:", st.SSvrId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sGuid:", st.SGuid)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bKickoutDiffClt:", st.BKickoutDiffClt)

	ret = ret + " }"
	return ret
}

// HKickOutInfo struct implement
type HKickOutInfo struct {
	codec.JceStructBase
	StInfo  HLoginInfo        `json:"stInfo"`
	SSvrId  string            `json:"sSvrId"`
	EStatus E_KICK_OUT_STATUS `json:"eStatus"`
	EReason E_KICK_OUT_REASON `json:"eReason"`
}

func (st *HKickOutInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HKickOutInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StInfo.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSvrId, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStatus), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EReason), 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKickOutInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKickOutInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKickOutInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StInfo.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSvrId, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStatus), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EReason), 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKickOutInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKickOutInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stInfo:" + st.StInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSvrId:", st.SSvrId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eReason:", st.EReason)

	ret = ret + " }"
	return ret
}

// HAuthServerInfo struct implement
type HAuthServerInfo struct {
	codec.JceStructBase
	SSvrId string `json:"sSvrId"`
}

func (st *HAuthServerInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HAuthServerInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SSvrId, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HAuthServerInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HAuthServerInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HAuthServerInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SSvrId, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HAuthServerInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HAuthServerInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sSvrId:", st.SSvrId)

	ret = ret + " }"
	return ret
}

// HHeartBeatReq struct implement
type HHeartBeatReq struct {
	codec.JceStructBase
	SSvrId string `json:"sSvrId"`
}

func (st *HHeartBeatReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HHeartBeatReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SSvrId, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHeartBeatReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHeartBeatReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHeartBeatReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SSvrId, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHeartBeatReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHeartBeatReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sSvrId:", st.SSvrId)

	ret = ret + " }"
	return ret
}

// HHeartBeatRsp struct implement
type HHeartBeatRsp struct {
	codec.JceStructBase
	BNeedReg bool   `json:"bNeedReg"`
	SMdsId   string `json:"sMdsId"`
}

func (st *HHeartBeatRsp) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BNeedReg = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HHeartBeatRsp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_bool(&st.BNeedReg, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SMdsId, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HHeartBeatRsp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HHeartBeatRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HHeartBeatRsp) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_bool(st.BNeedReg, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SMdsId, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HHeartBeatRsp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HHeartBeatRsp) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("bNeedReg:", st.BNeedReg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sMdsId:", st.SMdsId)

	ret = ret + " }"
	return ret
}

// HOEMAuthResult struct implement
type HOEMAuthResult struct {
	codec.JceStructBase
	IRet      int32  `json:"iRet"`
	SMsg      string `json:"sMsg"`
	BHSL2     bool   `json:"bHSL2"`
	BHKL2     bool   `json:"bHKL2"`
	BUSL2     bool   `json:"bUSL2"`
	SSerialNo string `json:"sSerialNo"`
}

func (st *HOEMAuthResult) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IRet = 0
	st.BHSL2 = false
	st.BHKL2 = false
	st.BUSL2 = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HOEMAuthResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IRet, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SMsg, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BHSL2, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BHKL2, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BUSL2, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSerialNo, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOEMAuthResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOEMAuthResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOEMAuthResult) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IRet, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SMsg, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BHSL2, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BHKL2, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BUSL2, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSerialNo, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOEMAuthResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOEMAuthResult) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iRet:", st.IRet)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sMsg:", st.SMsg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bHSL2:", st.BHSL2)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bHKL2:", st.BHKL2)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bUSL2:", st.BUSL2)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSerialNo:", st.SSerialNo)

	ret = ret + " }"
	return ret
}

// HAuthServerPacket struct implement
type HAuthServerPacket struct {
	codec.JceStructBase
	EAuthType     E_AUTH_TYPE  `json:"eAuthType"`
	VGuid         []int8       `json:"vGuid"`
	SXua          string       `json:"sXua"`
	SToken        string       `json:"sToken"`
	SSvrId        string       `json:"sSvrId"`
	SAuthAddr     string       `json:"sAuthAddr"`
	ShtClearFlag  int16        `json:"shtClearFlag"`
	VInfo         []HLoginInfo `json:"vInfo"`
	StInfo        HLoginInfo   `json:"stInfo"`
	SSerialNo     string       `json:"sSerialNo"`
	StKickOutInfo HKickOutInfo `json:"stKickOutInfo"`
}

func (st *HAuthServerPacket) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StInfo.ResetDefault()
	st.StKickOutInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HAuthServerPacket) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32((*int32)(&st.EAuthType), 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VGuid = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int8(&st.VGuid[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_int8(&st.VGuid, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.SXua, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SToken, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSvrId, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SAuthAddr, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtClearFlag, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HLoginInfo, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VInfo[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.StInfo.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSerialNo, 10, false)
	if err != nil {
		return err
	}

	err = st.StKickOutInfo.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HAuthServerPacket) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HAuthServerPacket, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HAuthServerPacket) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(int32(st.EAuthType), 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VGuid)), 0)
	if err != nil {
		return err
	}

	err = _os.Write_slice_int8(st.VGuid)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SXua, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SToken, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSvrId, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SAuthAddr, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtClearFlag, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.StInfo.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSerialNo, 10)
	if err != nil {
		return err
	}

	err = st.StKickOutInfo.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HAuthServerPacket) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HAuthServerPacket) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("eAuthType:", st.EAuthType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vGuid:", st.VGuid)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sXua:", st.SXua)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sToken:", st.SToken)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSvrId:", st.SSvrId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sAuthAddr:", st.SAuthAddr)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtClearFlag:", st.ShtClearFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)
	ret = ret + ",  "
	ret = ret + "stInfo:" + st.StInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSerialNo:", st.SSerialNo)
	ret = ret + ",  "
	ret = ret + "stKickOutInfo:" + st.StKickOutInfo.Display()

	ret = ret + " }"
	return ret
}

// HNewStockPerform struct implement
type HNewStockPerform struct {
	codec.JceStructBase
	StStock     HStock  `json:"stStock"`
	DSignProfit float64 `json:"dSignProfit"`
	IZtNDay     int32   `json:"iZtNDay"`
	BBreakPlate bool    `json:"bBreakPlate"`
	SListDate   string  `json:"sListDate"`
}

func (st *HNewStockPerform) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StStock.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HNewStockPerform) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StStock.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSignProfit, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZtNDay, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BBreakPlate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SListDate, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HNewStockPerform) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HNewStockPerform, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HNewStockPerform) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StStock.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSignProfit, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZtNDay, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BBreakPlate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SListDate, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HNewStockPerform) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HNewStockPerform) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stStock:" + st.StStock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSignProfit:", st.DSignProfit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZtNDay:", st.IZtNDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bBreakPlate:", st.BBreakPlate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sListDate:", st.SListDate)

	ret = ret + " }"
	return ret
}

// HRadarQt struct implement
type HRadarQt struct {
	codec.JceStructBase
	IMarket int32             `json:"iMarket"`
	SCode   string            `json:"sCode"`
	StQt    RadarData.RadarQt `json:"stQt"`
}

func (st *HRadarQt) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StQt.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRadarQt) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = st.StQt.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRadarQt) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRadarQt, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRadarQt) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = st.StQt.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRadarQt) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRadarQt) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iMarket:", st.IMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + "stQt:" + st.StQt.Display()

	ret = ret + " }"
	return ret
}

// HRadarChg struct implement
type HRadarChg struct {
	codec.JceStructBase
	IMarket int32              `json:"iMarket"`
	SCode   string             `json:"sCode"`
	StChg   RadarData.RadarChg `json:"stChg"`
}

func (st *HRadarChg) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StChg.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HRadarChg) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = st.StChg.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HRadarChg) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HRadarChg, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HRadarChg) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = st.StChg.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HRadarChg) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HRadarChg) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iMarket:", st.IMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + "stChg:" + st.StChg.Display()

	ret = ret + " }"
	return ret
}

// HSyntInfo struct implement
type HSyntInfo struct {
	codec.JceStructBase
	IMarket          int32   `json:"iMarket"`
	SCode            string  `json:"sCode"`
	DPrice           float64 `json:"dPrice"`
	DZdf             float64 `json:"dZdf"`
	Dltsz            float64 `json:"dltsz"`
	DMainBuy         float64 `json:"dMainBuy"`
	FMainBuyRatio    float32 `json:"fMainBuyRatio"`
	FMainSellRatio   float32 `json:"fMainSellRatio"`
	FDDX             float32 `json:"fDDX"`
	FDDY             float32 `json:"fDDY"`
	FDDZ             float32 `json:"fDDZ"`
	IntVol500        int32   `json:"intVol500"`
	IntVol1000       int32   `json:"intVol1000"`
	IntVol5000       int32   `json:"intVol5000"`
	IntVol9999       int32   `json:"intVol9999"`
	IntAmt100        int32   `json:"intAmt100"`
	IntAmt200        int32   `json:"intAmt200"`
	IntAmt500        int32   `json:"intAmt500"`
	DMainBuy3        float64 `json:"dMainBuy3"`
	DMainBuy5        float64 `json:"dMainBuy5"`
	DMainBuy10       float64 `json:"dMainBuy10"`
	IMainBuyRedDay   int32   `json:"iMainBuyRedDay"`
	IMainBuyRedDay5  int32   `json:"iMainBuyRedDay5"`
	IMainBuyRedDay10 int32   `json:"iMainBuyRedDay10"`
	FDDX3            float32 `json:"fDDX3"`
	FDDX5            float32 `json:"fDDX5"`
	FDDX10           float32 `json:"fDDX10"`
	IDDXRedDay       int32   `json:"iDDXRedDay"`
	IDDXRedDay5      int32   `json:"iDDXRedDay5"`
	IDDXRedDay10     int32   `json:"iDDXRedDay10"`
	FMainFlowTrend   float32 `json:"fMainFlowTrend"`
}

func (st *HSyntInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSyntInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZdf, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Dltsz, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMainBuy, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FMainBuyRatio, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FMainSellRatio, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FDDX, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FDDY, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FDDZ, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IntVol500, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IntVol1000, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IntVol5000, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IntVol9999, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IntAmt100, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IntAmt200, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IntAmt500, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMainBuy3, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMainBuy5, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMainBuy10, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IMainBuyRedDay, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IMainBuyRedDay5, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IMainBuyRedDay10, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FDDX3, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FDDX5, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FDDX10, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDDXRedDay, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDDXRedDay5, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDDXRedDay10, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FMainFlowTrend, 31, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSyntInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSyntInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSyntInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZdf, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Dltsz, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMainBuy, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FMainBuyRatio, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FMainSellRatio, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FDDX, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FDDY, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FDDZ, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IntVol500, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IntVol1000, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IntVol5000, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IntVol9999, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IntAmt100, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IntAmt200, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IntAmt500, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMainBuy3, 19)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMainBuy5, 20)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMainBuy10, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IMainBuyRedDay, 22)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IMainBuyRedDay5, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IMainBuyRedDay10, 24)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FDDX3, 25)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FDDX5, 26)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FDDX10, 27)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDDXRedDay, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDDXRedDay5, 29)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDDXRedDay10, 30)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FMainFlowTrend, 31)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSyntInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSyntInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iMarket:", st.IMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZdf:", st.DZdf)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dltsz:", st.Dltsz)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMainBuy:", st.DMainBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMainBuyRatio:", st.FMainBuyRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMainSellRatio:", st.FMainSellRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX:", st.FDDX)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDY:", st.FDDY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDZ:", st.FDDZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("intVol500:", st.IntVol500)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("intVol1000:", st.IntVol1000)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("intVol5000:", st.IntVol5000)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("intVol9999:", st.IntVol9999)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("intAmt100:", st.IntAmt100)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("intAmt200:", st.IntAmt200)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("intAmt500:", st.IntAmt500)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMainBuy3:", st.DMainBuy3)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMainBuy5:", st.DMainBuy5)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMainBuy10:", st.DMainBuy10)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iMainBuyRedDay:", st.IMainBuyRedDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iMainBuyRedDay5:", st.IMainBuyRedDay5)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iMainBuyRedDay10:", st.IMainBuyRedDay10)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX3:", st.FDDX3)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX5:", st.FDDX5)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fDDX10:", st.FDDX10)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDDXRedDay:", st.IDDXRedDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDDXRedDay5:", st.IDDXRedDay5)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDDXRedDay10:", st.IDDXRedDay10)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMainFlowTrend:", st.FMainFlowTrend)

	ret = ret + " }"
	return ret
}

// HPankouRadio struct implement
type HPankouRadio struct {
	codec.JceStructBase
	IOrderLevel int32   `json:"iOrderLevel"`
	DPrice      float64 `json:"dPrice"`
	DVolume     float64 `json:"dVolume"`
}

func (st *HPankouRadio) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPankouRadio) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IOrderLevel, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DVolume, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPankouRadio) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPankouRadio, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPankouRadio) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IOrderLevel, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DVolume, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPankouRadio) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPankouRadio) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iOrderLevel:", st.IOrderLevel)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dVolume:", st.DVolume)

	ret = ret + " }"
	return ret
}

// HWarrantData struct implement
type HWarrantData struct {
	codec.JceStructBase
	ShtMarket     int16   `json:"shtMarket"`
	SCode         string  `json:"sCode"`
	SName         string  `json:"sName"`
	DNowPrice     float64 `json:"dNowPrice"`
	DAmount       float64 `json:"dAmount"`
	DChg          float64 `json:"dChg"`
	IMaturityDate int32   `json:"iMaturityDate"`
	CPrecise      int8    `json:"cPrecise"`
}

func (st *HWarrantData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HWarrantData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNowPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAmount, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DChg, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IMaturityDate, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CPrecise, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HWarrantData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HWarrantData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HWarrantData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNowPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAmount, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DChg, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IMaturityDate, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CPrecise, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HWarrantData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HWarrantData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNowPrice:", st.DNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAmount:", st.DAmount)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dChg:", st.DChg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iMaturityDate:", st.IMaturityDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cPrecise:", st.CPrecise)

	ret = ret + " }"
	return ret
}

// HWarrantHkData struct implement
type HWarrantHkData struct {
	codec.JceStructBase
	ShtMarket int16   `json:"shtMarket"`
	SCode     string  `json:"sCode"`
	SName     string  `json:"sName"`
	DNowPrice float64 `json:"dNowPrice"`
	DChgValue float64 `json:"dChgValue"`
	DChg      float64 `json:"dChg"`
}

func (st *HWarrantHkData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HWarrantHkData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNowPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DChgValue, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DChg, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HWarrantHkData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HWarrantHkData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HWarrantHkData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNowPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DChgValue, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DChg, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HWarrantHkData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HWarrantHkData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNowPrice:", st.DNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dChgValue:", st.DChgValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dChg:", st.DChg)

	ret = ret + " }"
	return ret
}

// HOptionBaseInfo struct implement
type HOptionBaseInfo struct {
	codec.JceStructBase
	Market                 int16   `json:"market"`
	SCode                  string  `json:"sCode"`
	SName                  string  `json:"sName"`
	SUnderlyingCode        string  `json:"sUnderlyingCode"`
	SUnerlyingName         string  `json:"sUnerlyingName"`
	COptionType            int8    `json:"cOptionType"`
	CCallOrPut             int8    `json:"cCallOrPut"`
	IContractMutiplierUnit int32   `json:"iContractMutiplierUnit"`
	DExercisePrice         float64 `json:"dExercisePrice"`
	IEndDate               int32   `json:"iEndDate"`
	IExerciseDate          int32   `json:"iExerciseDate"`
	DPreClose              float64 `json:"dPreClose"`
	DPreSettlPrice         float64 `json:"dPreSettlPrice"`
	DUpLimit               float64 `json:"dUpLimit"`
	DDownLimit             float64 `json:"dDownLimit"`
	IRoundLot              int32   `json:"iRoundLot"`
	FTickSize              float32 `json:"fTickSize"`
	CTradeFlag             int8    `json:"cTradeFlag"`
	CTradePhase            int8    `json:"cTradePhase"`
	CExpireStatus          int8    `json:"cExpireStatus"`
	CChangeStatus          int8    `json:"cChangeStatus"`
	IDaysLeft              int32   `json:"iDaysLeft"`
	SContractType          string  `json:"sContractType"`
	UsUnderlyingMarket     uint16  `json:"usUnderlyingMarket"`
}

func (st *HOptionBaseInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionBaseInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.Market, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SUnderlyingCode, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SUnerlyingName, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.COptionType, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CCallOrPut, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IContractMutiplierUnit, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DExercisePrice, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEndDate, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IExerciseDate, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreClose, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreSettlPrice, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DUpLimit, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDownLimit, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IRoundLot, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FTickSize, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CTradeFlag, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CTradePhase, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CExpireStatus, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CChangeStatus, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDaysLeft, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SContractType, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint16(&st.UsUnderlyingMarket, 23, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionBaseInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionBaseInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionBaseInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.Market, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SUnderlyingCode, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SUnerlyingName, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.COptionType, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CCallOrPut, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IContractMutiplierUnit, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DExercisePrice, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEndDate, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IExerciseDate, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreClose, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreSettlPrice, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DUpLimit, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDownLimit, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IRoundLot, 15)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FTickSize, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CTradeFlag, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CTradePhase, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CExpireStatus, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CChangeStatus, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDaysLeft, 21)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SContractType, 22)
	if err != nil {
		return err
	}

	err = _os.Write_uint16(st.UsUnderlyingMarket, 23)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionBaseInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionBaseInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("market:", st.Market)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sUnderlyingCode:", st.SUnderlyingCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sUnerlyingName:", st.SUnerlyingName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cOptionType:", st.COptionType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cCallOrPut:", st.CCallOrPut)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iContractMutiplierUnit:", st.IContractMutiplierUnit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dExercisePrice:", st.DExercisePrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDate:", st.IEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iExerciseDate:", st.IExerciseDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreClose:", st.DPreClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreSettlPrice:", st.DPreSettlPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dUpLimit:", st.DUpLimit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDownLimit:", st.DDownLimit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iRoundLot:", st.IRoundLot)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTickSize:", st.FTickSize)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cTradeFlag:", st.CTradeFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cTradePhase:", st.CTradePhase)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cExpireStatus:", st.CExpireStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cChangeStatus:", st.CChangeStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDaysLeft:", st.IDaysLeft)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sContractType:", st.SContractType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("usUnderlyingMarket:", st.UsUnderlyingMarket)

	ret = ret + " }"
	return ret
}

// HGGTMarketRate struct implement
type HGGTMarketRate struct {
	codec.JceStructBase
	DSettlementBuy  float64 `json:"dSettlementBuy"`
	DSettlementSell float64 `json:"dSettlementSell"`
	DReferenceBuy   float64 `json:"dReferenceBuy"`
	DReferenceSell  float64 `json:"dReferenceSell"`
}

func (st *HGGTMarketRate) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTMarketRate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DSettlementBuy, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSettlementSell, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DReferenceBuy, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DReferenceSell, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTMarketRate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTMarketRate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTMarketRate) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DSettlementBuy, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSettlementSell, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DReferenceBuy, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DReferenceSell, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTMarketRate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTMarketRate) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dSettlementBuy:", st.DSettlementBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSettlementSell:", st.DSettlementSell)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dReferenceBuy:", st.DReferenceBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dReferenceSell:", st.DReferenceSell)

	ret = ret + " }"
	return ret
}

// HGGTRate struct implement
type HGGTRate struct {
	codec.JceStructBase
	ShRate HGGTMarketRate `json:"shRate"`
	SzRate HGGTMarketRate `json:"szRate"`
}

func (st *HGGTRate) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShRate.ResetDefault()
	st.SzRate.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTRate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.ShRate.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.SzRate.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTRate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTRate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTRate) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.ShRate.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.SzRate.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTRate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTRate) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "shRate:" + st.ShRate.Display()
	ret = ret + ",  "
	ret = ret + "szRate:" + st.SzRate.Display()

	ret = ret + " }"
	return ret
}

// HGGTDividendShare struct implement
type HGGTDividendShare struct {
	codec.JceStructBase
	NRecordDate   int32   `json:"nRecordDate"`
	DDivPs_HK     float64 `json:"dDivPs_HK"`
	DSpeDivPer_HK float64 `json:"dSpeDivPer_HK"`
	DSwapRate     float64 `json:"dSwapRate"`
	DBonusSHR_X   float64 `json:"dBonusSHR_X"`
	DBonusSHR_Y   float64 `json:"dBonusSHR_Y"`
	DTurnAdd_X    float64 `json:"dTurnAdd_X"`
	DTurnAdd_Y    float64 `json:"dTurnAdd_Y"`
}

func (st *HGGTDividendShare) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTDividendShare) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.NRecordDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivPs_HK, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSpeDivPer_HK, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSwapRate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBonusSHR_X, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBonusSHR_Y, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTurnAdd_X, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTurnAdd_Y, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTDividendShare) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTDividendShare, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTDividendShare) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.NRecordDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivPs_HK, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSpeDivPer_HK, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSwapRate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBonusSHR_X, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBonusSHR_Y, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTurnAdd_X, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTurnAdd_Y, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTDividendShare) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTDividendShare) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("nRecordDate:", st.NRecordDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivPs_HK:", st.DDivPs_HK)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSpeDivPer_HK:", st.DSpeDivPer_HK)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSwapRate:", st.DSwapRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBonusSHR_X:", st.DBonusSHR_X)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBonusSHR_Y:", st.DBonusSHR_Y)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTurnAdd_X:", st.DTurnAdd_X)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTurnAdd_Y:", st.DTurnAdd_Y)

	ret = ret + " }"
	return ret
}

// HGGTSpinOffMerger struct implement
type HGGTSpinOffMerger struct {
	codec.JceStructBase
	DCOMB_X float64 `json:"dCOMB_X"`
	DCOMB_Y float64 `json:"dCOMB_Y"`
	DSPLI_X float64 `json:"dSPLI_X"`
	DSPLI_Y float64 `json:"dSPLI_Y"`
}

func (st *HGGTSpinOffMerger) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTSpinOffMerger) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DCOMB_X, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCOMB_Y, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSPLI_X, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSPLI_Y, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTSpinOffMerger) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTSpinOffMerger, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTSpinOffMerger) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DCOMB_X, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCOMB_Y, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSPLI_X, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSPLI_Y, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTSpinOffMerger) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTSpinOffMerger) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dCOMB_X:", st.DCOMB_X)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCOMB_Y:", st.DCOMB_Y)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSPLI_X:", st.DSPLI_X)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSPLI_Y:", st.DSPLI_Y)

	ret = ret + " }"
	return ret
}

// HGGTQXInfo struct implement
type HGGTQXInfo struct {
	codec.JceStructBase
	StShare        HGGTDividendShare `json:"stShare"`
	StSpinOffMerge HGGTSpinOffMerger `json:"stSpinOffMerge"`
}

func (st *HGGTQXInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StShare.ResetDefault()
	st.StSpinOffMerge.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTQXInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StShare.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.StSpinOffMerge.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTQXInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTQXInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTQXInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StShare.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.StSpinOffMerge.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTQXInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTQXInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stShare:" + st.StShare.Display()
	ret = ret + ",  "
	ret = ret + "stSpinOffMerge:" + st.StSpinOffMerge.Display()

	ret = ret + " }"
	return ret
}

// HGGTStockQXInfo struct implement
type HGGTStockQXInfo struct {
	codec.JceStructBase
	Stock  HStockUnique `json:"stock"`
	QxData HGGTQXInfo   `json:"qxData"`
}

func (st *HGGTStockQXInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Stock.ResetDefault()
	st.QxData.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HGGTStockQXInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Stock.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.QxData.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HGGTStockQXInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HGGTStockQXInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HGGTStockQXInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Stock.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.QxData.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HGGTStockQXInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HGGTStockQXInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stock:" + st.Stock.Display()
	ret = ret + ",  "
	ret = ret + "qxData:" + st.QxData.Display()

	ret = ret + " }"
	return ret
}

// HCheckData struct implement
type HCheckData struct {
	codec.JceStructBase
	IDate     int32 `json:"iDate"`
	CCheckVal int8  `json:"cCheckVal"`
	ITime     int32 `json:"iTime"`
}

func (st *HCheckData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCheckData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CCheckVal, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITime, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCheckData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCheckData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCheckData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CCheckVal, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITime, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCheckData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCheckData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cCheckVal:", st.CCheckVal)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTime:", st.ITime)

	ret = ret + " }"
	return ret
}

// HSectionCheckData struct implement
type HSectionCheckData struct {
	codec.JceStructBase
	LBeginDate int64  `json:"lBeginDate"`
	LEndDate   int64  `json:"lEndDate"`
	SMD5       string `json:"sMD5"`
}

func (st *HSectionCheckData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSectionCheckData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LBeginDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LEndDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SMD5, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSectionCheckData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSectionCheckData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSectionCheckData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LBeginDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LEndDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SMD5, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSectionCheckData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSectionCheckData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lBeginDate:", st.LBeginDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lEndDate:", st.LEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sMD5:", st.SMD5)

	ret = ret + " }"
	return ret
}

// HEtfComponentInfo struct implement
type HEtfComponentInfo struct {
	codec.JceStructBase
	ShtMarket      int16   `json:"shtMarket"`
	SCode          string  `json:"sCode"`
	SName          string  `json:"sName"`
	Qty            int32   `json:"qty"`
	SubFlag        int8    `json:"subFlag"`
	PreminumRatio  float32 `json:"preminumRatio"`
	DSubCashAmount float64 `json:"dSubCashAmount"`
}

func (st *HEtfComponentInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HEtfComponentInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Qty, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.SubFlag, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.PreminumRatio, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSubCashAmount, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HEtfComponentInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HEtfComponentInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HEtfComponentInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Qty, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.SubFlag, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.PreminumRatio, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSubCashAmount, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HEtfComponentInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HEtfComponentInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("qty:", st.Qty)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("subFlag:", st.SubFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("preminumRatio:", st.PreminumRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSubCashAmount:", st.DSubCashAmount)

	ret = ret + " }"
	return ret
}

// HEtfBasicInfo struct implement
type HEtfBasicInfo struct {
	codec.JceStructBase
	ITradingDay             int32   `json:"iTradingDay"`
	IPreTradingDay          int32   `json:"iPreTradingDay"`
	DEstimateCashComponent  float64 `json:"dEstimateCashComponent"`
	FMaxCashRatio           float32 `json:"fMaxCashRatio"`
	BPublish                bool    `json:"bPublish"`
	ICreationRedemptionUnit int32   `json:"iCreationRedemptionUnit"`
	ITotalRecordNum         int32   `json:"iTotalRecordNum"`
	BCreation               bool    `json:"bCreation"`
	BRedemption             bool    `json:"bRedemption"`
	DCashComponent          float64 `json:"dCashComponent"`
	DNAVPreCU               float64 `json:"dNAVPreCU"`
	DNAV                    float64 `json:"dNAV"`
}

func (st *HEtfBasicInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BPublish = false
	st.BCreation = false
	st.BRedemption = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HEtfBasicInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ITradingDay, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IPreTradingDay, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DEstimateCashComponent, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FMaxCashRatio, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BPublish, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ICreationRedemptionUnit, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITotalRecordNum, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCreation, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BRedemption, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCashComponent, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNAVPreCU, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNAV, 12, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HEtfBasicInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HEtfBasicInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HEtfBasicInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ITradingDay, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IPreTradingDay, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DEstimateCashComponent, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FMaxCashRatio, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BPublish, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ICreationRedemptionUnit, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITotalRecordNum, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCreation, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BRedemption, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCashComponent, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNAVPreCU, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNAV, 12)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HEtfBasicInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HEtfBasicInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iTradingDay:", st.ITradingDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iPreTradingDay:", st.IPreTradingDay)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dEstimateCashComponent:", st.DEstimateCashComponent)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fMaxCashRatio:", st.FMaxCashRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bPublish:", st.BPublish)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iCreationRedemptionUnit:", st.ICreationRedemptionUnit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTotalRecordNum:", st.ITotalRecordNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCreation:", st.BCreation)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bRedemption:", st.BRedemption)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCashComponent:", st.DCashComponent)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNAVPreCU:", st.DNAVPreCU)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNAV:", st.DNAV)

	ret = ret + " }"
	return ret
}

// HEtfDescInfo struct implement
type HEtfDescInfo struct {
	codec.JceStructBase
	ShtMarket       int16               `json:"shtMarket"`
	SCode           string              `json:"sCode"`
	SName           string              `json:"sName"`
	SFundId1        string              `json:"sFundId1"`
	SUnderlyingCode string              `json:"sUnderlyingCode"`
	StBaseInfo      HEtfBasicInfo       `json:"stBaseInfo"`
	VComponents     []HEtfComponentInfo `json:"vComponents"`
}

func (st *HEtfDescInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StBaseInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HEtfDescInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SFundId1, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SUnderlyingCode, 4, false)
	if err != nil {
		return err
	}

	err = st.StBaseInfo.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VComponents = make([]HEtfComponentInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VComponents[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HEtfDescInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HEtfDescInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HEtfDescInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SFundId1, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SUnderlyingCode, 4)
	if err != nil {
		return err
	}

	err = st.StBaseInfo.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VComponents)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VComponents {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HEtfDescInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HEtfDescInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sFundId1:", st.SFundId1)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sUnderlyingCode:", st.SUnderlyingCode)
	ret = ret + ",  "
	ret = ret + "stBaseInfo:" + st.StBaseInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vComponents:", st.VComponents)

	ret = ret + " }"
	return ret
}

// HTypeSubType struct implement
type HTypeSubType struct {
	codec.JceStructBase
	ShtType    int16   `json:"shtType"`
	VecSubType []int16 `json:"vecSubType"`
}

func (st *HTypeSubType) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTypeSubType) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtType, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecSubType = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VecSubType[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTypeSubType) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTypeSubType, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTypeSubType) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtType, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecSubType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecSubType {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTypeSubType) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTypeSubType) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecSubType:", st.VecSubType)

	ret = ret + " }"
	return ret
}

// H5AverageVolData struct implement
type H5AverageVolData struct {
	codec.JceStructBase
	D5AveVol   float64 `json:"d5AveVol"`
	ShtSetcode int16   `json:"shtSetcode"`
	SCode      string  `json:"sCode"`
}

func (st *H5AverageVolData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *H5AverageVolData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.D5AveVol, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *H5AverageVolData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require H5AverageVolData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *H5AverageVolData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.D5AveVol, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *H5AverageVolData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *H5AverageVolData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("d5AveVol:", st.D5AveVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)

	ret = ret + " }"
	return ret
}

// HStockAuction struct implement
type HStockAuction struct {
	codec.JceStructBase
	ShtMarket    int16   `json:"shtMarket"`
	SCode        string  `json:"sCode"`
	UiDate       uint32  `json:"uiDate"`
	UiTime       uint32  `json:"uiTime"`
	FPreClose    float32 `json:"fPreClose"`
	FOpen        float32 `json:"fOpen"`
	FNow         float32 `json:"fNow"`
	UiVol        uint32  `json:"uiVol"`
	UiUnmatchVol uint32  `json:"uiUnmatchVol"`
	FUmatchValue float32 `json:"fUmatchValue"`
	ShtDirection int16   `json:"shtDirection"`
}

func (st *HStockAuction) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockAuction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiTime, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FPreClose, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FOpen, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FNow, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiVol, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiUnmatchVol, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FUmatchValue, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDirection, 10, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockAuction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockAuction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockAuction) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiTime, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FPreClose, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FOpen, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FNow, 6)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiVol, 7)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiUnmatchVol, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FUmatchValue, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDirection, 10)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockAuction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockAuction) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiDate:", st.UiDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiTime:", st.UiTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fPreClose:", st.FPreClose)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fOpen:", st.FOpen)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fNow:", st.FNow)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiVol:", st.UiVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiUnmatchVol:", st.UiUnmatchVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fUmatchValue:", st.FUmatchValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDirection:", st.ShtDirection)

	ret = ret + " }"
	return ret
}

// HSNFundsData struct implement
type HSNFundsData struct {
	codec.JceStructBase
	FNet     float32 `json:"fNet"`
	FBalance float32 `json:"fBalance"`
	FTotal   float32 `json:"fTotal"`
	ShtType  int16   `json:"shtType"`
}

func (st *HSNFundsData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSNFundsData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float32(&st.FNet, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FBalance, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FTotal, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSNFundsData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSNFundsData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSNFundsData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float32(st.FNet, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FBalance, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FTotal, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSNFundsData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSNFundsData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fNet:", st.FNet)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fBalance:", st.FBalance)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTotal:", st.FTotal)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)

	ret = ret + " }"
	return ret
}

// HSNNetData struct implement
type HSNNetData struct {
	codec.JceStructBase
	ITime  int32   `json:"iTime"`
	DSZNet float64 `json:"dSZNet"`
	DSHNet float64 `json:"dSHNet"`
}

func (st *HSNNetData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HSNNetData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.ITime, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSZNet, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSHNet, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HSNNetData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HSNNetData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HSNNetData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.ITime, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSZNet, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSHNet, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HSNNetData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HSNNetData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSZNet:", st.DSZNet)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSHNet:", st.DSHNet)

	ret = ret + " }"
	return ret
}

// HTypeFilt struct implement
type HTypeFilt struct {
	codec.JceStructBase
	ShtType    int16   `json:"shtType"`
	VecSubType []int16 `json:"vecSubType"`
}

func (st *HTypeFilt) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTypeFilt) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtType, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecSubType = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VecSubType[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTypeFilt) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTypeFilt, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTypeFilt) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtType, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecSubType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecSubType {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTypeFilt) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTypeFilt) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecSubType:", st.VecSubType)

	ret = ret + " }"
	return ret
}

// HMarketTypeFilt struct implement
type HMarketTypeFilt struct {
	codec.JceStructBase
	ShtMarket int16   `json:"shtMarket"`
	VecType   []int16 `json:"vecType"`
}

func (st *HMarketTypeFilt) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketTypeFilt) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecType = make([]int16, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int16(&st.VecType[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketTypeFilt) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketTypeFilt, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketTypeFilt) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecType)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecType {

		err = _os.Write_int16(v, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketTypeFilt) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketTypeFilt) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecType:", st.VecType)

	ret = ret + " }"
	return ret
}

// HJPJLStock struct implement
type HJPJLStock struct {
	codec.JceStructBase
	ShtMarket  int16               `json:"shtMarket"`
	SCode      string              `json:"sCode"`
	SName      string              `json:"sName"`
	SCodeEx    string              `json:"sCodeEx"`
	EMatchType E_JPJL_MATCH_TYPE   `json:"eMatchType"`
	EStatus    E_STOCK_STATUS_TYPE `json:"eStatus"`
	SthType    int16               `json:"sthType"`
	ShtSubType int16               `json:"shtSubType"`
}

func (st *HJPJLStock) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HJPJLStock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCodeEx, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EMatchType), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStatus), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.SthType, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSubType, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HJPJLStock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HJPJLStock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HJPJLStock) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCodeEx, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EMatchType), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStatus), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.SthType, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSubType, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HJPJLStock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HJPJLStock) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCodeEx:", st.SCodeEx)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eMatchType:", st.EMatchType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStatus:", st.EStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sthType:", st.SthType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSubType:", st.ShtSubType)

	ret = ret + " }"
	return ret
}

// HZDFenBuInfo struct implement
type HZDFenBuInfo struct {
	codec.JceStructBase
	MapFenbu    map[int16]int32 `json:"mapFenbu"`
	ITradeDate  int32           `json:"iTradeDate"`
	IZChg5Num   int32           `json:"iZChg5Num"`
	IDChg5Num   int32           `json:"iDChg5Num"`
	IZTNum      int32           `json:"iZTNum"`
	IDTNum      int32           `json:"iDTNum"`
	ISuspendNum int32           `json:"iSuspendNum"`
	IRiseNum    int32           `json:"iRiseNum"`
	IFallNum    int32           `json:"iFallNum"`
	IFlatNum    int32           `json:"iFlatNum"`
}

func (st *HZDFenBuInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HZDFenBuInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have = _is.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.MapFenbu = make(map[int16]int32)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int16
			var v0 int32

			err = _is.Read_int16(&k0, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&v0, 1, false)
			if err != nil {
				return err
			}

			st.MapFenbu[k0] = v0
		}
	}

	err = _is.Read_int32(&st.ITradeDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZChg5Num, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDChg5Num, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IZTNum, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDTNum, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ISuspendNum, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IRiseNum, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IFallNum, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IFlatNum, 9, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HZDFenBuInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HZDFenBuInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HZDFenBuInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MapFenbu)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MapFenbu {

		err = _os.Write_int16(k1, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(v1, 1)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.ITradeDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZChg5Num, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDChg5Num, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IZTNum, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDTNum, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ISuspendNum, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IRiseNum, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IFallNum, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IFlatNum, 9)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HZDFenBuInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HZDFenBuInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("mapFenbu:", st.MapFenbu)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTradeDate:", st.ITradeDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZChg5Num:", st.IZChg5Num)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDChg5Num:", st.IDChg5Num)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iZTNum:", st.IZTNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDTNum:", st.IDTNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSuspendNum:", st.ISuspendNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iRiseNum:", st.IRiseNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iFallNum:", st.IFallNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iFlatNum:", st.IFlatNum)

	ret = ret + " }"
	return ret
}

// HCurrencyInfo struct implement
type HCurrencyInfo struct {
	codec.JceStructBase
	SCode string `json:"sCode"`
	SName string `json:"sName"`
}

func (st *HCurrencyInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCurrencyInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCurrencyInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCurrencyInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCurrencyInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCurrencyInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCurrencyInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)

	ret = ret + " }"
	return ret
}
