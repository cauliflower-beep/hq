// Package HQSys comment
// This file was generated by jce2go 2.0.0
// Generated from CommonData.jce
package HQSys

import (
	"fmt"

	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type E_STOCK_TYPE int32

const (
	E_STOCK_TYPE_E_STOCK_TYPE_INVALID           = 0
	E_STOCK_TYPE_E_STOCK_TYPE_A                 = 1
	E_STOCK_TYPE_E_STOCK_TYPE_B                 = 2
	E_STOCK_TYPE_E_STOCK_TYPE_CONVERTTIBLE_BOND = 206
	E_STOCK_TYPE_E_STOCK_TYPE_REITS_FUND        = 1001
)

type E_DATACENTER_BLOCK_TYPE int32

const (
	E_DATACENTER_BLOCK_TYPE_E_DATACENTER_BLOCK_TYPE_ZB      = 1
	E_DATACENTER_BLOCK_TYPE_E_DATACENTER_BLOCK_TYPE_ZXB     = 2
	E_DATACENTER_BLOCK_TYPE_E_DATACENTER_BLOCK_TYPE_CYB     = 3
	E_DATACENTER_BLOCK_TYPE_E_DATACENTER_BLOCK_TYPE_XSB     = 4
	E_DATACENTER_BLOCK_TYPE_E_DATACENTER_BLOCK_TYPE_LSB     = 7
	E_DATACENTER_BLOCK_TYPE_E_DATACENTER_BLOCK_TYPE_KCB     = 8
	E_DATACENTER_BLOCK_TYPE_E_DATACENTER_BLOCK_TYPE_UNKNOWN = 999
)

type E_SHT_NAME_CHG_TYPE int32

const (
	E_SHT_NAME_CHG_TYPE_E_OTHER_CHG            = 0
	E_SHT_NAME_CHG_TYPE_E_XGFX_CHG             = 1
	E_SHT_NAME_CHG_TYPE_E_XGSR_CHG             = 2
	E_SHT_NAME_CHG_TYPE_E_ST_CHG               = 3
	E_SHT_NAME_CHG_TYPE_E_CXST_CHG             = 4
	E_SHT_NAME_CHG_TYPE_E_PT_CHG               = 5
	E_SHT_NAME_CHG_TYPE_E_CXPT_CHG             = 6
	E_SHT_NAME_CHG_TYPE_E_XST_CHG              = 7
	E_SHT_NAME_CHG_TYPE_E_CXXST_CHG            = 8
	E_SHT_NAME_CHG_TYPE_E_CXXSTBST_CHG         = 9
	E_SHT_NAME_CHG_TYPE_E_WCGGJCJG_CHG         = 10
	E_SHT_NAME_CHG_TYPE_E_QDGGWCBZG_CHG        = 11
	E_SHT_NAME_CHG_TYPE_E_JSGGWWCBZS_CHG       = 12
	E_SHT_NAME_CHG_TYPE_E_WCGGJCQDS_CHG        = 13
	E_SHT_NAME_CHG_TYPE_E_WCGGQDSTCXXSTBST_CHG = 15
	E_SHT_NAME_CHG_TYPE_E_GSMCHJYFWBG_CHG      = 16
	E_SHT_NAME_CHG_TYPE_E_HFSSSR_CHG           = 17
	E_SHT_NAME_CHG_TYPE_E_HFSSCR_CHG           = 18
)

type E_CONNE_TYPE int32

const (
	E_CONNE_TYPE_E_UNKONWN  = 0
	E_CONNE_TYPE_E_CONNECT  = 1
	E_CONNE_TYPE_E_DISCONNE = 2
	E_CONNE_TYPE_E_DELETE   = 3
)

type E_CONNEINFO_TYPE int32

const (
	E_CONNEINFO_TYPE_E_LOCATE = 1
	E_CONNEINFO_TYPE_E_TIME   = 2
)

type E_LOG_LEVEL int32

const (
	E_LOG_LEVEL_E_LOG_DEBUG = 0
	E_LOG_LEVEL_E_LOG_INFO  = 1
	E_LOG_LEVEL_E_LOG_WARN  = 2
	E_LOG_LEVEL_E_LOG_ERROR = 3
)

type EQXChgType int32

const (
	EQXChgType_E_PX    = 1
	EQXChgType_E_SG    = 2
	EQXChgType_E_ZZ    = 3
	EQXChgType_E_PG    = 4
	EQXChgType_E_GKZF  = 5
	EQXChgType_E_FGKZF = 6
)

// HStockUnique struct implement
type HStockUnique struct {
	codec.JceStructBase
	ShtSetcode int16  `json:"shtSetcode"`
	SCode      string `json:"sCode"`
}

func (st *HStockUnique) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockUnique) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockUnique) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockUnique, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockUnique) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockUnique) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockUnique) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)

	ret = ret + " }"
	return ret
}

// HCWVerData struct implement
type HCWVerData struct {
	codec.JceStructBase
	ShtSetCode     int16  `json:"shtSetCode"`
	SCode          string `json:"sCode"`
	LCWVersion     int64  `json:"lCWVersion"`
	LQXVersion     int64  `json:"lQXVersion"`
	LLTGChgVersion int64  `json:"lLTGChgVersion"`
}

func (st *HCWVerData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HCWVerData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LCWVersion, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LQXVersion, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LLTGChgVersion, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HCWVerData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HCWVerData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HCWVerData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LCWVersion, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LQXVersion, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LLTGChgVersion, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HCWVerData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HCWVerData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetCode:", st.ShtSetCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lCWVersion:", st.LCWVersion)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lQXVersion:", st.LQXVersion)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lLTGChgVersion:", st.LLTGChgVersion)

	ret = ret + " }"
	return ret
}

// HNameChgData struct implement
type HNameChgData struct {
	codec.JceStructBase
	ShtMarket int16               `json:"shtMarket"`
	SCode     string              `json:"sCode"`
	LChgDate  int64               `json:"lChgDate"`
	SOldName  string              `json:"sOldName"`
	SNewName  string              `json:"sNewName"`
	EType     E_SHT_NAME_CHG_TYPE `json:"eType"`
}

func (st *HNameChgData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HNameChgData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LChgDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SOldName, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SNewName, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HNameChgData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HNameChgData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HNameChgData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LChgDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SOldName, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SNewName, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HNameChgData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HNameChgData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lChgDate:", st.LChgDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sOldName:", st.SOldName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sNewName:", st.SNewName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)

	ret = ret + " }"
	return ret
}

// HNameUsedBefore struct implement
type HNameUsedBefore struct {
	codec.JceStructBase
	LChgDate int64               `json:"lChgDate"`
	SOldName string              `json:"sOldName"`
	EType    E_SHT_NAME_CHG_TYPE `json:"eType"`
}

func (st *HNameUsedBefore) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HNameUsedBefore) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LChgDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SOldName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HNameUsedBefore) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HNameUsedBefore, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HNameUsedBefore) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LChgDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SOldName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HNameUsedBefore) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HNameUsedBefore) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lChgDate:", st.LChgDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sOldName:", st.SOldName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)

	ret = ret + " }"
	return ret
}

// HStockUpInfo struct implement
type HStockUpInfo struct {
	codec.JceStructBase
	SCode       string            `json:"sCode"`
	ShtUnit     int16             `json:"shtUnit"`
	SName       string            `json:"sName"`
	IVolBase    int32             `json:"iVolBase"`
	CPrecise    int8              `json:"cPrecise"`
	ShtType     int16             `json:"shtType"`
	VChgData    []HNameUsedBefore `json:"vChgData"`
	BDiffRight  bool              `json:"bDiffRight"`
	BCDR        bool              `json:"bCDR"`
	BGDR        bool              `json:"bGDR"`
	IUnit       int32             `json:"iUnit"`
	SNameEx     string            `json:"sNameEx"`
	BDeficit    bool              `json:"bDeficit"`
	BProControl bool              `json:"bProControl"`
	ShtSubType  int16             `json:"shtSubType"`
}

func (st *HStockUpInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BDiffRight = true
	st.BCDR = false
	st.BGDR = false
	st.IUnit = 0
	st.BDeficit = false
	st.BProControl = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockUpInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtUnit, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IVolBase, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CPrecise, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 6, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VChgData = make([]HNameUsedBefore, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VChgData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.BDiffRight, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCDR, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BGDR, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUnit, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SNameEx, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDeficit, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BProControl, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSubType, 17, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockUpInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockUpInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockUpInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtUnit, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IVolBase, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CPrecise, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 6)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VChgData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VChgData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.BDiffRight, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCDR, 11)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BGDR, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUnit, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SNameEx, 14)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDeficit, 15)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BProControl, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSubType, 17)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockUpInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockUpInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtUnit:", st.ShtUnit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iVolBase:", st.IVolBase)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cPrecise:", st.CPrecise)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vChgData:", st.VChgData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDiffRight:", st.BDiffRight)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCDR:", st.BCDR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bGDR:", st.BGDR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUnit:", st.IUnit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sNameEx:", st.SNameEx)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDeficit:", st.BDeficit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bProControl:", st.BProControl)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSubType:", st.ShtSubType)

	ret = ret + " }"
	return ret
}

// HStockDelistInfo struct implement
type HStockDelistInfo struct {
	codec.JceStructBase
	StInfo  HStockUpInfo `json:"stInfo"`
	LTsDate int64        `json:"lTsDate"`
}

func (st *HStockDelistInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockDelistInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StInfo.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTsDate, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockDelistInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockDelistInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockDelistInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StInfo.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTsDate, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockDelistInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockDelistInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stInfo:" + st.StInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTsDate:", st.LTsDate)

	ret = ret + " }"
	return ret
}

// HStockSuspendInfo struct implement
type HStockSuspendInfo struct {
	codec.JceStructBase
	StInfo       HStockUpInfo `json:"stInfo"`
	LSuspendDate int64        `json:"lSuspendDate"`
}

func (st *HStockSuspendInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockSuspendInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StInfo.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LSuspendDate, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockSuspendInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockSuspendInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockSuspendInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StInfo.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LSuspendDate, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockSuspendInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockSuspendInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stInfo:" + st.StInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lSuspendDate:", st.LSuspendDate)

	ret = ret + " }"
	return ret
}

// HStockUpcomingInfo struct implement
type HStockUpcomingInfo struct {
	codec.JceStructBase
	StInfo        HStockUpInfo `json:"stInfo"`
	LUpcomingDate int64        `json:"lUpcomingDate"`
	DPrice        float64      `json:"dPrice"`
}

func (st *HStockUpcomingInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.StInfo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockUpcomingInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.StInfo.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LUpcomingDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 3, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockUpcomingInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockUpcomingInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockUpcomingInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.StInfo.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LUpcomingDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 3)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockUpcomingInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockUpcomingInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stInfo:" + st.StInfo.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lUpcomingDate:", st.LUpcomingDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)

	ret = ret + " }"
	return ret
}

// HMarketCodes struct implement
type HMarketCodes struct {
	codec.JceStructBase
	ShtSetCode int16                `json:"shtSetCode"`
	ShtFlag    int16                `json:"shtFlag"`
	SCheckSum  string               `json:"sCheckSum"`
	VInfo      []HStockUpInfo       `json:"vInfo"`
	VDelist    []HStockDelistInfo   `json:"vDelist"`
	VUpcoming  []HStockUpcomingInfo `json:"vUpcoming"`
	VSuspend   []HStockSuspendInfo  `json:"vSuspend"`
}

func (st *HMarketCodes) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketCodes) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtFlag, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCheckSum, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VInfo = make([]HStockUpInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VDelist = make([]HStockDelistInfo, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VDelist[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VUpcoming = make([]HStockUpcomingInfo, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.VUpcoming[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VSuspend = make([]HStockSuspendInfo, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.VSuspend[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketCodes) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketCodes, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketCodes) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtFlag, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCheckSum, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VDelist)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VDelist {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VUpcoming)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VUpcoming {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VSuspend)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VSuspend {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketCodes) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketCodes) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetCode:", st.ShtSetCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtFlag:", st.ShtFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vInfo:", st.VInfo)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vDelist:", st.VDelist)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vUpcoming:", st.VUpcoming)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vSuspend:", st.VSuspend)

	ret = ret + " }"
	return ret
}

// SCWData struct implement
type SCWData struct {
	codec.JceStructBase
	ShtMarket        int16   `json:"shtMarket"`
	SCode            string  `json:"sCode"`
	IUpdateDate      int32   `json:"iUpdateDate"`
	IIPODate         int32   `json:"iIPODate"`
	DZGB             float64 `json:"dZGB"`
	DLTGB            float64 `json:"dLTGB"`
	DBShare          float64 `json:"dBShare"`
	DHShare          float64 `json:"dHShare"`
	DPerCapitaHold   float64 `json:"dPerCapitaHold"`
	DMGSY            float64 `json:"dMGSY"`
	DMGJZC           float64 `json:"dMGJZC"`
	DTZMGJZC         float64 `json:"dTZMGJZC"`
	DMGGJJ           float64 `json:"dMGGJJ"`
	DMGWFPLR         float64 `json:"dMGWFPLR"`
	DYYSRTB          float64 `json:"dYYSRTB"`
	DJLRTB           float64 `json:"dJLRTB"`
	DJZCSYL          float64 `json:"dJZCSYL"`
	DJLL             float64 `json:"dJLL"`
	DYYLRL           float64 `json:"dYYLRL"`
	DXSMLL           float64 `json:"dXSMLL"`
	DLDBL            float64 `json:"dLDBL"`
	DZCFZBL          float64 `json:"dZCFZBL"`
	DGDQYB           float64 `json:"dGDQYB"`
	DYYSR            float64 `json:"dYYSR"`
	DYYCB            float64 `json:"dYYCB"`
	DTZSY            float64 `json:"dTZSY"`
	DYYLR            float64 `json:"dYYLR"`
	DYYWSZ           float64 `json:"dYYWSZ"`
	DLRZE            float64 `json:"dLRZE"`
	DJLR             float64 `json:"dJLR"`
	DZZC             float64 `json:"dZZC"`
	DLDZC            float64 `json:"dLDZC"`
	DGDZC            float64 `json:"dGDZC"`
	DWXZC            float64 `json:"dWXZC"`
	DCQGQTZ          float64 `json:"dCQGQTZ"`
	DZFZ             float64 `json:"dZFZ"`
	DLDFZ            float64 `json:"dLDFZ"`
	DCQFZ            float64 `json:"dCQFZ"`
	DJZC             float64 `json:"dJZC"`
	DZBGJJ           float64 `json:"dZBGJJ"`
	DWFPLR           float64 `json:"dWFPLR"`
	LBGQ             int64   `json:"lBGQ"`
	SSSHY            string  `json:"sSSHY"`
	DFXJ             float64 `json:"dFXJ"`
	LVer             int64   `json:"lVer"`
	DMGSYDT          float64 `json:"dMGSYDT"`
	DMGJZCDT         float64 `json:"dMGJZCDT"`
	DYYSRZZL         float64 `json:"dYYSRZZL"`
	DJLRZZL          float64 `json:"dJLRZZL"`
	SSSHYCode        string  `json:"sSSHYCode"`
	DZCZB            float64 `json:"dZCZB"`
	DCASH_DVD_TTM    float64 `json:"dCASH_DVD_TTM"`
	DCASH_DVD_LFY    float64 `json:"dCASH_DVD_LFY"`
	DJTMGSY          float64 `json:"dJTMGSY"`
	DTTMMGSY         float64 `json:"dTTMMGSY"`
	DFXGB            float64 `json:"dFXGB"`
	DSecurityZGB     float64 `json:"dSecurityZGB"`
	DExchangeRMBRate float64 `json:"dExchangeRMBRate"`
}

func (st *SCWData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.DZCZB = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *SCWData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpdateDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IIPODate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZGB, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLTGB, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBShare, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHShare, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPerCapitaHold, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGSY, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGJZC, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTZMGJZC, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGGJJ, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGWFPLR, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYYSRTB, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJLRTB, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJZCSYL, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJLL, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYYLRL, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DXSMLL, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLDBL, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZCFZBL, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DGDQYB, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYYSR, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYYCB, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTZSY, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYYLR, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYYWSZ, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLRZE, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJLR, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZZC, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLDZC, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DGDZC, 33, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DWXZC, 34, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCQGQTZ, 35, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZFZ, 36, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLDFZ, 37, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCQFZ, 38, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJZC, 39, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZBGJJ, 40, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DWFPLR, 41, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBGQ, 42, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSSHY, 43, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFXJ, 44, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVer, 45, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGSYDT, 46, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGJZCDT, 47, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYYSRZZL, 48, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJLRZZL, 49, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SSSHYCode, 50, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZCZB, 51, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCASH_DVD_TTM, 53, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCASH_DVD_LFY, 54, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJTMGSY, 55, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTTMMGSY, 56, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFXGB, 57, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSecurityZGB, 58, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DExchangeRMBRate, 59, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SCWData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SCWData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SCWData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpdateDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IIPODate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZGB, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLTGB, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBShare, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHShare, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPerCapitaHold, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGSY, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGJZC, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTZMGJZC, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGGJJ, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGWFPLR, 14)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYYSRTB, 15)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJLRTB, 16)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJZCSYL, 17)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJLL, 18)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYYLRL, 19)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DXSMLL, 20)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLDBL, 21)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZCFZBL, 22)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DGDQYB, 23)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYYSR, 24)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYYCB, 25)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTZSY, 26)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYYLR, 27)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYYWSZ, 28)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLRZE, 29)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJLR, 30)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZZC, 31)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLDZC, 32)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DGDZC, 33)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DWXZC, 34)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCQGQTZ, 35)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZFZ, 36)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLDFZ, 37)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCQFZ, 38)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJZC, 39)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZBGJJ, 40)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DWFPLR, 41)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBGQ, 42)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSSHY, 43)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFXJ, 44)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVer, 45)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGSYDT, 46)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGJZCDT, 47)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYYSRZZL, 48)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJLRZZL, 49)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SSSHYCode, 50)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZCZB, 51)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCASH_DVD_TTM, 53)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCASH_DVD_LFY, 54)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJTMGSY, 55)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTTMMGSY, 56)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFXGB, 57)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSecurityZGB, 58)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DExchangeRMBRate, 59)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SCWData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SCWData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpdateDate:", st.IUpdateDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iIPODate:", st.IIPODate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZGB:", st.DZGB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLTGB:", st.DLTGB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBShare:", st.DBShare)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHShare:", st.DHShare)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPerCapitaHold:", st.DPerCapitaHold)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGSY:", st.DMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGJZC:", st.DMGJZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTZMGJZC:", st.DTZMGJZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGGJJ:", st.DMGGJJ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGWFPLR:", st.DMGWFPLR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYYSRTB:", st.DYYSRTB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJLRTB:", st.DJLRTB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJZCSYL:", st.DJZCSYL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJLL:", st.DJLL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYYLRL:", st.DYYLRL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dXSMLL:", st.DXSMLL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLDBL:", st.DLDBL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZCFZBL:", st.DZCFZBL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dGDQYB:", st.DGDQYB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYYSR:", st.DYYSR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYYCB:", st.DYYCB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTZSY:", st.DTZSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYYLR:", st.DYYLR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYYWSZ:", st.DYYWSZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLRZE:", st.DLRZE)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJLR:", st.DJLR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZZC:", st.DZZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLDZC:", st.DLDZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dGDZC:", st.DGDZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dWXZC:", st.DWXZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCQGQTZ:", st.DCQGQTZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZFZ:", st.DZFZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLDFZ:", st.DLDFZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCQFZ:", st.DCQFZ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJZC:", st.DJZC)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZBGJJ:", st.DZBGJJ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dWFPLR:", st.DWFPLR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBGQ:", st.LBGQ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSSHY:", st.SSSHY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFXJ:", st.DFXJ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVer:", st.LVer)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGSYDT:", st.DMGSYDT)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGJZCDT:", st.DMGJZCDT)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYYSRZZL:", st.DYYSRZZL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJLRZZL:", st.DJLRZZL)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sSSHYCode:", st.SSSHYCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZCZB:", st.DZCZB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCASH_DVD_TTM:", st.DCASH_DVD_TTM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCASH_DVD_LFY:", st.DCASH_DVD_LFY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJTMGSY:", st.DJTMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTTMMGSY:", st.DTTMMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFXGB:", st.DFXGB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSecurityZGB:", st.DSecurityZGB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dExchangeRMBRate:", st.DExchangeRMBRate)

	ret = ret + " }"
	return ret
}

// SCWData_Extra struct implement
type SCWData_Extra struct {
	codec.JceStructBase
	ShtMarket        int16   `json:"shtMarket"`
	SCode            string  `json:"sCode"`
	IUpdateDate      int32   `json:"iUpdateDate"`
	DPE_Static       float64 `json:"dPE_Static"`
	DPE_TTM          float64 `json:"dPE_TTM"`
	DDivide_TTM      float64 `json:"dDivide_TTM"`
	DDivide_LFY      float64 `json:"dDivide_LFY"`
	DDivideRate_TTM  float64 `json:"dDivideRate_TTM"`
	DDivideRate_LFY  float64 `json:"dDivideRate_LFY"`
	DFXGB            float64 `json:"dFXGB"`
	DJTMGSY          float64 `json:"dJTMGSY"`
	DDTMGSY          float64 `json:"dDTMGSY"`
	DTTMMGSY         float64 `json:"dTTMMGSY"`
	FExchangeRateJT  float32 `json:"fExchangeRateJT"`
	FExchangeRateDT  float32 `json:"fExchangeRateDT"`
	FExchangeRateTTM float32 `json:"fExchangeRateTTM"`
}

func (st *SCWData_Extra) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *SCWData_Extra) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, true)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpdateDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPE_Static, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPE_TTM, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivide_TTM, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivide_LFY, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivideRate_TTM, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDivideRate_LFY, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFXGB, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJTMGSY, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDTMGSY, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTTMMGSY, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FExchangeRateJT, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FExchangeRateDT, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FExchangeRateTTM, 16, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SCWData_Extra) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SCWData_Extra, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SCWData_Extra) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpdateDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPE_Static, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPE_TTM, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivide_TTM, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivide_LFY, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivideRate_TTM, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDivideRate_LFY, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFXGB, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJTMGSY, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDTMGSY, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTTMMGSY, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FExchangeRateJT, 14)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FExchangeRateDT, 15)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FExchangeRateTTM, 16)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SCWData_Extra) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SCWData_Extra) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpdateDate:", st.IUpdateDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPE_Static:", st.DPE_Static)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPE_TTM:", st.DPE_TTM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivide_TTM:", st.DDivide_TTM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivide_LFY:", st.DDivide_LFY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivideRate_TTM:", st.DDivideRate_TTM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDivideRate_LFY:", st.DDivideRate_LFY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFXGB:", st.DFXGB)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJTMGSY:", st.DJTMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDTMGSY:", st.DDTMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTTMMGSY:", st.DTTMMGSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fExchangeRateJT:", st.FExchangeRateJT)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fExchangeRateDT:", st.FExchangeRateDT)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fExchangeRateTTM:", st.FExchangeRateTTM)

	ret = ret + " }"
	return ret
}

// SQXChgData struct implement
type SQXChgData struct {
	codec.JceStructBase
	LChanDate    int64      `json:"lChanDate"`
	DCashBt      float64    `json:"dCashBt"`
	DBonusShr    float64    `json:"dBonusShr"`
	DCapShr      float64    `json:"dCapShr"`
	DAllotPct    float64    `json:"dAllotPct"`
	DAllotPrice  float64    `json:"dAllotPrice"`
	DIssPri      float64    `json:"dIssPri"`
	DIssShareNum float64    `json:"dIssShareNum"`
	EType        EQXChgType `json:"eType"`
}

func (st *SQXChgData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *SQXChgData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LChanDate, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCashBt, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBonusShr, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCapShr, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAllotPct, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAllotPrice, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DIssPri, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DIssShareNum, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 9, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SQXChgData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SQXChgData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SQXChgData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LChanDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCashBt, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBonusShr, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCapShr, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAllotPct, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAllotPrice, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DIssPri, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DIssShareNum, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 9)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SQXChgData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SQXChgData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lChanDate:", st.LChanDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCashBt:", st.DCashBt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBonusShr:", st.DBonusShr)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCapShr:", st.DCapShr)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAllotPct:", st.DAllotPct)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAllotPrice:", st.DAllotPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dIssPri:", st.DIssPri)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dIssShareNum:", st.DIssShareNum)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)

	ret = ret + " }"
	return ret
}

// SAFundQX struct implement
type SAFundQX struct {
	codec.JceStructBase
	IExDate     int32   `json:"iExDate"`
	IOutExDate  int32   `json:"iOutExDate"`
	DCashBt     float64 `json:"dCashBt"`
	DSplitRatio float64 `json:"dSplitRatio"`
}

func (st *SAFundQX) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *SAFundQX) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IExDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IOutExDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCashBt, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSplitRatio, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SAFundQX) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SAFundQX, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SAFundQX) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IExDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IOutExDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCashBt, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSplitRatio, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SAFundQX) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SAFundQX) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iExDate:", st.IExDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iOutExDate:", st.IOutExDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCashBt:", st.DCashBt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSplitRatio:", st.DSplitRatio)

	ret = ret + " }"
	return ret
}

// SHKStkQx struct implement
type SHKStkQx struct {
	codec.JceStructBase
	IExDate     int32   `json:"iExDate"`
	DBonus      float64 `json:"dBonus"`
	DTurn       float64 `json:"dTurn"`
	DAllotPct   float64 `json:"dAllotPct"`
	DAllotPrice float64 `json:"dAllotPrice"`
	DDiv        float64 `json:"dDiv"`
	DSpeDiv     float64 `json:"dSpeDiv"`
	DComb       float64 `json:"dComb"`
	DSplit      float64 `json:"dSplit"`
	SDesc       string  `json:"sDesc"`
}

func (st *SHKStkQx) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *SHKStkQx) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IExDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBonus, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DTurn, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAllotPct, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAllotPrice, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDiv, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSpeDiv, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DComb, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSplit, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SDesc, 10, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SHKStkQx) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SHKStkQx, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SHKStkQx) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IExDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBonus, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DTurn, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAllotPct, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAllotPrice, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDiv, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSpeDiv, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DComb, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSplit, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SDesc, 10)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SHKStkQx) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SHKStkQx) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iExDate:", st.IExDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBonus:", st.DBonus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dTurn:", st.DTurn)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAllotPct:", st.DAllotPct)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAllotPrice:", st.DAllotPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDiv:", st.DDiv)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSpeDiv:", st.DSpeDiv)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dComb:", st.DComb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSplit:", st.DSplit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sDesc:", st.SDesc)

	ret = ret + " }"
	return ret
}

// SQXData struct implement
type SQXData struct {
	codec.JceStructBase
	ShtMarket  int16        `json:"shtMarket"`
	SCode      string       `json:"sCode"`
	MChgData   []SQXChgData `json:"mChgData"`
	LVer       int64        `json:"lVer"`
	IStkType   int32        `json:"iStkType"`
	VecAFundQx []SAFundQX   `json:"vecAFundQx"`
	VecHKStkQx []SHKStkQx   `json:"vecHKStkQx"`
}

func (st *SQXData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *SQXData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, true)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, true)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.MChgData = make([]SQXChgData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.MChgData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.LVer, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStkType, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecAFundQx = make([]SAFundQX, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VecAFundQx[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecHKStkQx = make([]SHKStkQx, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.VecHKStkQx[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SQXData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SQXData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SQXData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.MChgData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.MChgData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.LVer, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStkType, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecAFundQx)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecAFundQx {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecHKStkQx)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecHKStkQx {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SQXData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SQXData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("mChgData:", st.MChgData)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVer:", st.LVer)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStkType:", st.IStkType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecAFundQx:", st.VecAFundQx)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecHKStkQx:", st.VecHKStkQx)

	ret = ret + " }"
	return ret
}

// SXrdFactor struct implement
type SXrdFactor struct {
	codec.JceStructBase
	IDate int32   `json:"iDate"`
	DA    float64 `json:"dA"`
	DB    float64 `json:"dB"`
}

func (st *SXrdFactor) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *SXrdFactor) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DA, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DB, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SXrdFactor) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SXrdFactor, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SXrdFactor) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DA, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DB, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SXrdFactor) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SXrdFactor) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dA:", st.DA)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dB:", st.DB)

	ret = ret + " }"
	return ret
}

// SMultiKlineXrdData struct implement
type SMultiKlineXrdData struct {
	codec.JceStructBase
	IDate     int32   `json:"iDate"`
	IOpenDate int32   `json:"iOpenDate"`
	IHighDate int32   `json:"iHighDate"`
	ILowDate  int32   `json:"iLowDate"`
	DHigh     float64 `json:"dHigh"`
	DLow      float64 `json:"dLow"`
}

func (st *SMultiKlineXrdData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *SMultiKlineXrdData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IOpenDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IHighDate, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ILowDate, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHigh, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLow, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SMultiKlineXrdData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SMultiKlineXrdData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SMultiKlineXrdData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IOpenDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IHighDate, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ILowDate, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHigh, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLow, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SMultiKlineXrdData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *SMultiKlineXrdData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iOpenDate:", st.IOpenDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iHighDate:", st.IHighDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iLowDate:", st.ILowDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHigh:", st.DHigh)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLow:", st.DLow)

	ret = ret + " }"
	return ret
}

// HStockXrdFactor struct implement
type HStockXrdFactor struct {
	codec.JceStructBase
	Stock         HStockUnique `json:"stock"`
	VecQXrdFactor []SXrdFactor `json:"vecQXrdFactor"`
	VecHXrdFactor []SXrdFactor `json:"vecHXrdFactor"`
}

func (st *HStockXrdFactor) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.Stock.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HStockXrdFactor) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.Stock.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecQXrdFactor = make([]SXrdFactor, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VecQXrdFactor[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecHXrdFactor = make([]SXrdFactor, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.VecHXrdFactor[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStockXrdFactor) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStockXrdFactor, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStockXrdFactor) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.Stock.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecQXrdFactor)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecQXrdFactor {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecHXrdFactor)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecHXrdFactor {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStockXrdFactor) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStockXrdFactor) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "stock:" + st.Stock.Display()
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecQXrdFactor:", st.VecQXrdFactor)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecHXrdFactor:", st.VecHXrdFactor)

	ret = ret + " }"
	return ret
}

// HTSStock struct implement
type HTSStock struct {
	codec.JceStructBase
	ShtMarket  int16        `json:"shtMarket"`
	SCode      string       `json:"sCode"`
	SName      string       `json:"sName"`
	LTsDate    int64        `json:"lTsDate"`
	EType      E_STOCK_TYPE `json:"eType"`
	IBlockType int32        `json:"iBlockType"`
}

func (st *HTSStock) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HTSStock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LTsDate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IBlockType, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HTSStock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTSStock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HTSStock) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LTsDate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IBlockType, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HTSStock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HTSStock) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lTsDate:", st.LTsDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iBlockType:", st.IBlockType)

	ret = ret + " }"
	return ret
}

// HJjssStockData struct implement
type HJjssStockData struct {
	codec.JceStructBase
	ShtMarket  int16                   `json:"shtMarket"`
	SCode      string                  `json:"sCode"`
	SName      string                  `json:"sName"`
	DPrice     float64                 `json:"dPrice"`
	LDate      int64                   `json:"lDate"`
	EType      E_STOCK_TYPE            `json:"eType"`
	EBlockType E_DATACENTER_BLOCK_TYPE `json:"eBlockType"`
	NType      int16                   `json:"nType"`
}

func (st *HJjssStockData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.EBlockType = E_DATACENTER_BLOCK_TYPE_E_DATACENTER_BLOCK_TYPE_UNKNOWN
	st.NType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HJjssStockData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LDate, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EBlockType), 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.NType, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HJjssStockData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HJjssStockData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HJjssStockData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LDate, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EBlockType), 7)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.NType, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HJjssStockData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HJjssStockData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lDate:", st.LDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eBlockType:", st.EBlockType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("nType:", st.NType)

	ret = ret + " }"
	return ret
}

// HLTGChgData struct implement
type HLTGChgData struct {
	codec.JceStructBase
	LChgTime     int64   `json:"lChgTime"`
	LAFloatShare int64   `json:"lAFloatShare"`
	LBFloatShare int64   `json:"lBFloatShare"`
	LHFloatShare int64   `json:"lHFloatShare"`
	DZGB         float64 `json:"dZGB"`
}

func (st *HLTGChgData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HLTGChgData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int64(&st.LChgTime, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LAFloatShare, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LBFloatShare, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LHFloatShare, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZGB, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HLTGChgData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HLTGChgData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HLTGChgData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int64(st.LChgTime, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LAFloatShare, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LBFloatShare, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LHFloatShare, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZGB, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HLTGChgData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HLTGChgData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("lChgTime:", st.LChgTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lAFloatShare:", st.LAFloatShare)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lBFloatShare:", st.LBFloatShare)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lHFloatShare:", st.LHFloatShare)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZGB:", st.DZGB)

	ret = ret + " }"
	return ret
}

// HLTGChg struct implement
type HLTGChg struct {
	codec.JceStructBase
	ShtMarket int16         `json:"shtMarket"`
	SCode     string        `json:"sCode"`
	LVer      int64         `json:"lVer"`
	VData     []HLTGChgData `json:"vData"`
}

func (st *HLTGChg) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HLTGChg) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LVer, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]HLTGChgData, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HLTGChg) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HLTGChg, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HLTGChg) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LVer, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HLTGChg) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HLTGChg) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lVer:", st.LVer)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// HNewStockInfo struct implement
type HNewStockInfo struct {
	codec.JceStructBase
	ShtMarket int16   `json:"shtMarket"`
	SCode     string  `json:"sCode"`
	DFXJ      float64 `json:"dFXJ"`
	SListDate string  `json:"sListDate"`
	SName     string  `json:"sName"`
	IAPLDate  int32   `json:"iAPLDate"`
}

func (st *HNewStockInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HNewStockInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DFXJ, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SListDate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IAPLDate, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HNewStockInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HNewStockInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HNewStockInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DFXJ, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SListDate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IAPLDate, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HNewStockInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HNewStockInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dFXJ:", st.DFXJ)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sListDate:", st.SListDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iAPLDate:", st.IAPLDate)

	ret = ret + " }"
	return ret
}

// HBrokerData struct implement
type HBrokerData struct {
	codec.JceStructBase
	SId        string `json:"sId"`
	SEnName    string `json:"sEnName"`
	SEnShtName string `json:"sEnShtName"`
	SChName    string `json:"sChName"`
	SChShtName string `json:"sChShtName"`
}

func (st *HBrokerData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HBrokerData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SId, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SEnName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SEnShtName, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SChName, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SChShtName, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBrokerData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBrokerData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBrokerData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SId, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SEnName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SEnShtName, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SChName, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SChShtName, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBrokerData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBrokerData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sId:", st.SId)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sEnName:", st.SEnName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sEnShtName:", st.SEnShtName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sChName:", st.SChName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sChShtName:", st.SChShtName)

	ret = ret + " }"
	return ret
}

// HBrokerQueue struct implement
type HBrokerQueue struct {
	codec.JceStructBase
	ShtSetcode int16                   `json:"shtSetcode"`
	SCode      string                  `json:"sCode"`
	BuySide    map[int32][]HBrokerData `json:"buySide"`
	SellSide   map[int32][]HBrokerData `json:"sellSide"`
}

func (st *HBrokerQueue) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HBrokerQueue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err, have = _is.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.BuySide = make(map[int32][]HBrokerData)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 []HBrokerData

			err = _is.Read_int32(&k0, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v0 = make([]HBrokerData, length)
					for i1, e1 := int32(0), length; i1 < e1; i1++ {

						err = v0[i1].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.BuySide[k0] = v0
		}
	}

	err, have = _is.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}

		st.SellSide = make(map[int32][]HBrokerData)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 int32
			var v2 []HBrokerData

			err = _is.Read_int32(&k2, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}

					v2 = make([]HBrokerData, length)
					for i3, e3 := int32(0), length; i3 < e3; i3++ {

						err = v2[i3].ReadBlock(_is, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SIMPLE_LIST {
					err = fmt.Errorf("not support simple_list type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.SellSide[k2] = v2
		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HBrokerQueue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HBrokerQueue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HBrokerQueue) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.BuySide)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.BuySide {

		err = _os.Write_int32(k4, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v4)), 0)
		if err != nil {
			return err
		}

		for _, v := range v4 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.SellSide)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.SellSide {

		err = _os.Write_int32(k5, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v5)), 0)
		if err != nil {
			return err
		}

		for _, v := range v5 {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

		}
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HBrokerQueue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HBrokerQueue) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("buySide:", st.BuySide)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sellSide:", st.SellSide)

	ret = ret + " }"
	return ret
}

// TradeCale struct implement
type TradeCale struct {
	codec.JceStructBase
	IDate     int32 `json:"iDate"`
	ShtStatus int16 `json:"shtStatus"`
}

func (st *TradeCale) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *TradeCale) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStatus, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TradeCale) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeCale, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TradeCale) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStatus, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TradeCale) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *TradeCale) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStatus:", st.ShtStatus)

	ret = ret + " }"
	return ret
}

// HOptionUnderlyingDictInfo struct implement
type HOptionUnderlyingDictInfo struct {
	codec.JceStructBase
	ShtSetcode int16  `json:"shtSetcode"`
	SCode      string `json:"sCode"`
	SName      string `json:"sName"`
}

func (st *HOptionUnderlyingDictInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HOptionUnderlyingDictInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtSetcode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HOptionUnderlyingDictInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HOptionUnderlyingDictInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HOptionUnderlyingDictInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtSetcode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HOptionUnderlyingDictInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HOptionUnderlyingDictInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtSetcode:", st.ShtSetcode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)

	ret = ret + " }"
	return ret
}

// HYYInfo struct implement
type HYYInfo struct {
	codec.JceStructBase
	SCode      string  `json:"sCode"`
	SName      string  `json:"sName"`
	SBdCode    string  `json:"sBdCode"`
	ShtType    int16   `json:"shtType"`
	DPrice     float64 `json:"dPrice"`
	ShtStatus  int16   `json:"shtStatus"`
	IStartDate int32   `json:"iStartDate"`
	IEndDate   int32   `json:"iEndDate"`
	DVol       int32   `json:"dVol"`
	DBdPrice   float64 `json:"dBdPrice"`
	DYJL       float64 `json:"dYJL"`
}

func (st *HYYInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtType = 1
	st.ShtStatus = 1
	st.IStartDate = 0
	st.IEndDate = 0
	st.DVol = 0
	st.DBdPrice = 0.0
	st.DYJL = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HYYInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SBdCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtStatus, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartDate, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEndDate, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.DVol, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBdPrice, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DYJL, 10, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HYYInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HYYInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HYYInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SBdCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtStatus, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartDate, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEndDate, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.DVol, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBdPrice, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DYJL, 10)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HYYInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HYYInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sBdCode:", st.SBdCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtStatus:", st.ShtStatus)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartDate:", st.IStartDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDate:", st.IEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dVol:", st.DVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBdPrice:", st.DBdPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dYJL:", st.DYJL)

	ret = ret + " }"
	return ret
}

// HFXInfo struct implement
type HFXInfo struct {
	codec.JceStructBase
	SCode       string  `json:"sCode"`
	SName       string  `json:"sName"`
	SBdCode     string  `json:"sBdCode"`
	ShtType     int16   `json:"shtType"`
	IStartDate  int32   `json:"iStartDate"`
	IEndDate    int32   `json:"iEndDate"`
	DLowPrice   float64 `json:"dLowPrice"`
	DHighPrice  float64 `json:"dHighPrice"`
	DMinVol     float64 `json:"dMinVol"`
	DMaxVol     float64 `json:"dMaxVol"`
	DPrice      float64 `json:"dPrice"`
	DVol        float64 `json:"dVol"`
	ShtFXMethod int16   `json:"shtFXMethod"`
}

func (st *HFXInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtType = 0
	st.IStartDate = 0
	st.IEndDate = 0
	st.DLowPrice = 0.0
	st.DHighPrice = 0.0
	st.DMinVol = 0.0
	st.DMaxVol = 0.0
	st.DPrice = 0.0
	st.DVol = 0.0
	st.ShtFXMethod = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HFXInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SBdCode, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IStartDate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEndDate, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DLowPrice, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DHighPrice, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMinVol, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMaxVol, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrice, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DVol, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtFXMethod, 12, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HFXInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HFXInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HFXInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SBdCode, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IStartDate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEndDate, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DLowPrice, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DHighPrice, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMinVol, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMaxVol, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrice, 10)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DVol, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtFXMethod, 12)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HFXInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HFXInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sBdCode:", st.SBdCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartDate:", st.IStartDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDate:", st.IEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dLowPrice:", st.DLowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dHighPrice:", st.DHighPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMinVol:", st.DMinVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMaxVol:", st.DMaxVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrice:", st.DPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dVol:", st.DVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtFXMethod:", st.ShtFXMethod)

	ret = ret + " }"
	return ret
}

// HKZZInfo struct implement
type HKZZInfo struct {
	codec.JceStructBase
	FPrice     float32 `json:"fPrice"`
	IStartDate uint32  `json:"iStartDate"`
	IEndDate   uint32  `json:"iEndDate"`
}

func (st *HKZZInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.FPrice = 0.0
	st.IStartDate = 0
	st.IEndDate = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HKZZInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float32(&st.FPrice, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.IStartDate, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.IEndDate, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HKZZInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HKZZInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HKZZInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float32(st.FPrice, 0)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.IStartDate, 1)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.IEndDate, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HKZZInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HKZZInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("fPrice:", st.FPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iStartDate:", st.IStartDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDate:", st.IEndDate)

	ret = ret + " }"
	return ret
}

// HStaticDataSHSZ struct implement
type HStaticDataSHSZ struct {
	codec.JceStructBase
	BMarginMark     bool `json:"bMarginMark"`
	BSecuritiesMark bool `json:"bSecuritiesMark"`
	BIpoFlag        bool `json:"bIpoFlag"`
	BIpoCFlag       bool `json:"bIpoCFlag"`
	BSFlag          bool `json:"bSFlag"`
	BPFlag          bool `json:"bPFlag"`
	BTFlag          bool `json:"bTFlag"`
	BDeficit        bool `json:"bDeficit"`
	BDiffRight      bool `json:"bDiffRight"`
	BCDR            bool `json:"bCDR"`
	BGDR            bool `json:"bGDR"`
	BProControl     bool `json:"bProControl"`
}

func (st *HStaticDataSHSZ) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BMarginMark = false
	st.BSecuritiesMark = false
	st.BIpoFlag = false
	st.BIpoCFlag = false
	st.BSFlag = false
	st.BPFlag = false
	st.BTFlag = false
	st.BDeficit = false
	st.BDiffRight = false
	st.BCDR = false
	st.BGDR = false
	st.BProControl = false
}

//ReadFrom reads  from _is and put into struct.
func (st *HStaticDataSHSZ) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_bool(&st.BMarginMark, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BSecuritiesMark, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BIpoFlag, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BIpoCFlag, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BSFlag, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BPFlag, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BTFlag, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDeficit, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDiffRight, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCDR, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BGDR, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BProControl, 11, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStaticDataSHSZ) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStaticDataSHSZ, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStaticDataSHSZ) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_bool(st.BMarginMark, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BSecuritiesMark, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BIpoFlag, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BIpoCFlag, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BSFlag, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BPFlag, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BTFlag, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDeficit, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDiffRight, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCDR, 9)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BGDR, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BProControl, 11)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStaticDataSHSZ) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStaticDataSHSZ) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("bMarginMark:", st.BMarginMark)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bSecuritiesMark:", st.BSecuritiesMark)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bIpoFlag:", st.BIpoFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bIpoCFlag:", st.BIpoCFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bSFlag:", st.BSFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bPFlag:", st.BPFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bTFlag:", st.BTFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDeficit:", st.BDeficit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDiffRight:", st.BDiffRight)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCDR:", st.BCDR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bGDR:", st.BGDR)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bProControl:", st.BProControl)

	ret = ret + " }"
	return ret
}

// HStaticDataCW struct implement
type HStaticDataCW struct {
	codec.JceStructBase
	DLtg      float64 `json:"dLtg"`
	DZgb      float64 `json:"dZgb"`
	DMGDTSY   float64 `json:"dMGDTSY"`
	DMGJTSY   float64 `json:"dMGJTSY"`
	DMGTTMSY  float64 `json:"dMGTTMSY"`
	DNetValue float64 `json:"dNetValue"`
	DJzc      float64 `json:"dJzc"`
}

func (st *HStaticDataCW) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.DLtg = 0
	st.DZgb = 0
	st.DMGDTSY = 0.0
	st.DMGJTSY = 0.0
	st.DMGTTMSY = 0.0
	st.DNetValue = 0.0
	st.DJzc = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStaticDataCW) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_float64(&st.DLtg, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZgb, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGDTSY, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGJTSY, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DMGTTMSY, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNetValue, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DJzc, 6, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStaticDataCW) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStaticDataCW, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStaticDataCW) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_float64(st.DLtg, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZgb, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGDTSY, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGJTSY, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DMGTTMSY, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNetValue, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DJzc, 6)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStaticDataCW) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStaticDataCW) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("dLtg:", st.DLtg)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZgb:", st.DZgb)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGDTSY:", st.DMGDTSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGJTSY:", st.DMGJTSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dMGTTMSY:", st.DMGTTMSY)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNetValue:", st.DNetValue)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dJzc:", st.DJzc)

	ret = ret + " }"
	return ret
}

// HStaticDataBase struct implement
type HStaticDataBase struct {
	codec.JceStructBase
	SName      string  `json:"sName"`
	ShtType    int16   `json:"shtType"`
	ShtSubType int16   `json:"shtSubType"`
	DZTPrice   float64 `json:"dZTPrice"`
	DDTPrice   float64 `json:"dDTPrice"`
	CCoinType  int8    `json:"cCoinType"`
	D5SumVol   float64 `json:"d5SumVol"`
	DPreClose  float64 `json:"dPreClose"`
}

func (st *HStaticDataBase) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.ShtType = 0
	st.ShtSubType = 0
	st.DZTPrice = 0.0
	st.DDTPrice = 0.0
	st.CCoinType = 0
	st.D5SumVol = 0.0
	st.DPreClose = 0.0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStaticDataBase) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SName, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtType, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSubType, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DZTPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DDTPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CCoinType, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.D5SumVol, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreClose, 7, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStaticDataBase) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStaticDataBase, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStaticDataBase) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SName, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtType, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSubType, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DZTPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DDTPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CCoinType, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.D5SumVol, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreClose, 7)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStaticDataBase) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStaticDataBase) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtType:", st.ShtType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSubType:", st.ShtSubType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dZTPrice:", st.DZTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dDTPrice:", st.DDTPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cCoinType:", st.CCoinType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("d5SumVol:", st.D5SumVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreClose:", st.DPreClose)

	ret = ret + " }"
	return ret
}

// HStaticDataHK struct implement
type HStaticDataHK struct {
	codec.JceStructBase
	BVCM                      bool    `json:"bVCM"`
	BCAS                      bool    `json:"bCAS"`
	BPOS                      bool    `json:"bPOS"`
	DOpenLowLimitPrice        float64 `json:"dOpenLowLimitPrice"`
	DOpenHighLimitPrice       float64 `json:"dOpenHighLimitPrice"`
	ShtSpreadTableCode        int16   `json:"shtSpreadTableCode"`
	ILotSize                  int32   `json:"iLotSize"`
	BShortSell                bool    `json:"bShortSell"`
	BCCASS                    bool    `json:"bCCASS"`
	BDummy                    bool    `json:"bDummy"`
	BStampDuty                bool    `json:"bStampDuty"`
	BEFN                      bool    `json:"bEFN"`
	DAccruedInterest          float64 `json:"dAccruedInterest"`
	DCouponRate               float64 `json:"dCouponRate"`
	DConversionRatio          float64 `json:"dConversionRatio"`
	DStrikePrice1             float64 `json:"dStrikePrice1"`
	DStrikePrice2             float64 `json:"dStrikePrice2"`
	IMaturityDate             int32   `json:"iMaturityDate"`
	CallPutFlag               int8    `json:"callPutFlag"`
	Style                     int8    `json:"style"`
	WarrantType               int8    `json:"warrantType"`
	ICallPrice                int32   `json:"iCallPrice"`
	ShtDecimalInCallPrice     int16   `json:"shtDecimalInCallPrice"`
	IEntitlement              int32   `json:"iEntitlement"`
	ShtDecimalInEntitlement   int16   `json:"shtDecimalInEntitlement"`
	IWarrantPerEntitlementNum int32   `json:"iWarrantPerEntitlementNum"`
}

func (st *HStaticDataHK) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BVCM = false
	st.BCAS = false
	st.BPOS = false
	st.DOpenLowLimitPrice = 0
	st.DOpenHighLimitPrice = 0
	st.ShtSpreadTableCode = 0
	st.ILotSize = 0
	st.BShortSell = false
	st.BCCASS = false
	st.BDummy = false
	st.BStampDuty = false
	st.BEFN = false
	st.DAccruedInterest = 0
	st.DCouponRate = 0
	st.DConversionRatio = 0
	st.DStrikePrice1 = 0
	st.DStrikePrice2 = 0
	st.IMaturityDate = 0
	st.ICallPrice = 0
	st.ShtDecimalInCallPrice = 0
	st.IEntitlement = 0
	st.ShtDecimalInEntitlement = 0
	st.IWarrantPerEntitlementNum = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HStaticDataHK) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_bool(&st.BVCM, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCAS, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BPOS, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOpenLowLimitPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOpenHighLimitPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtSpreadTableCode, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ILotSize, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BShortSell, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BCCASS, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BDummy, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BStampDuty, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.BEFN, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DAccruedInterest, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCouponRate, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DConversionRatio, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DStrikePrice1, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DStrikePrice2, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IMaturityDate, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CallPutFlag, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.Style, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.WarrantType, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ICallPrice, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDecimalInCallPrice, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEntitlement, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_int16(&st.ShtDecimalInEntitlement, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IWarrantPerEntitlementNum, 25, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HStaticDataHK) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HStaticDataHK, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HStaticDataHK) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_bool(st.BVCM, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCAS, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BPOS, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOpenLowLimitPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOpenHighLimitPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtSpreadTableCode, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ILotSize, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BShortSell, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BCCASS, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BDummy, 9)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BStampDuty, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.BEFN, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DAccruedInterest, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCouponRate, 13)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DConversionRatio, 14)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DStrikePrice1, 15)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DStrikePrice2, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IMaturityDate, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CallPutFlag, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.Style, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.WarrantType, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ICallPrice, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDecimalInCallPrice, 22)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEntitlement, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int16(st.ShtDecimalInEntitlement, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IWarrantPerEntitlementNum, 25)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HStaticDataHK) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HStaticDataHK) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("bVCM:", st.BVCM)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCAS:", st.BCAS)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bPOS:", st.BPOS)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOpenLowLimitPrice:", st.DOpenLowLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOpenHighLimitPrice:", st.DOpenHighLimitPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtSpreadTableCode:", st.ShtSpreadTableCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iLotSize:", st.ILotSize)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bShortSell:", st.BShortSell)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bCCASS:", st.BCCASS)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bDummy:", st.BDummy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bStampDuty:", st.BStampDuty)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bEFN:", st.BEFN)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dAccruedInterest:", st.DAccruedInterest)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCouponRate:", st.DCouponRate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dConversionRatio:", st.DConversionRatio)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dStrikePrice1:", st.DStrikePrice1)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dStrikePrice2:", st.DStrikePrice2)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iMaturityDate:", st.IMaturityDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("callPutFlag:", st.CallPutFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("style:", st.Style)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("warrantType:", st.WarrantType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iCallPrice:", st.ICallPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDecimalInCallPrice:", st.ShtDecimalInCallPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEntitlement:", st.IEntitlement)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("shtDecimalInEntitlement:", st.ShtDecimalInEntitlement)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iWarrantPerEntitlementNum:", st.IWarrantPerEntitlementNum)

	ret = ret + " }"
	return ret
}

// HForeignRateMidPrice struct implement
type HForeignRateMidPrice struct {
	codec.JceStructBase
	SCode    string  `json:"sCode"`
	SName    string  `json:"sName"`
	Date     int32   `json:"date"`
	Price    float64 `json:"price"`
	PreClose float64 `json:"preClose"`
}

func (st *HForeignRateMidPrice) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HForeignRateMidPrice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SCode, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SName, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Price, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.PreClose, 4, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HForeignRateMidPrice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HForeignRateMidPrice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HForeignRateMidPrice) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SCode, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SName, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Price, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.PreClose, 4)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HForeignRateMidPrice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HForeignRateMidPrice) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sName:", st.SName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("date:", st.Date)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("price:", st.Price)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("preClose:", st.PreClose)

	ret = ret + " }"
	return ret
}

// HPeekOptionExt struct implement
type HPeekOptionExt struct {
	codec.JceStructBase
	SUnderlyingMarket      string  `json:"sUnderlyingMarket"`
	SUnderlyingCode        string  `json:"sUnderlyingCode"`
	SUnerlyingName         string  `json:"sUnerlyingName"`
	COptionType            int8    `json:"cOptionType"`
	CCallOrPut             int8    `json:"cCallOrPut"`
	IContractMutiplierUnit int32   `json:"iContractMutiplierUnit"`
	DExercisePrice         float64 `json:"dExercisePrice"`
	IOpenDate              int32   `json:"iOpenDate"`
	IEndDate               int32   `json:"iEndDate"`
	IExerciseDate          int32   `json:"iExerciseDate"`
	FTickSize              float32 `json:"fTickSize"`
	IDaysLeft              int32   `json:"iDaysLeft"`
	DPreDelta              float64 `json:"dPreDelta"`
	DCurrDelta             float64 `json:"dCurrDelta"`
	CTradeFlag             int8    `json:"cTradeFlag"`
	SContractType          string  `json:"sContractType"`
}

func (st *HPeekOptionExt) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPeekOptionExt) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SUnderlyingMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SUnderlyingCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SUnerlyingName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.COptionType, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CCallOrPut, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IContractMutiplierUnit, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DExercisePrice, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IOpenDate, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IEndDate, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IExerciseDate, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_float32(&st.FTickSize, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDaysLeft, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPreDelta, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCurrDelta, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CTradeFlag, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SContractType, 15, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPeekOptionExt) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPeekOptionExt, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPeekOptionExt) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SUnderlyingMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SUnderlyingCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SUnerlyingName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.COptionType, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CCallOrPut, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IContractMutiplierUnit, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DExercisePrice, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IOpenDate, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IEndDate, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IExerciseDate, 9)
	if err != nil {
		return err
	}

	err = _os.Write_float32(st.FTickSize, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDaysLeft, 11)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPreDelta, 12)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCurrDelta, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CTradeFlag, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SContractType, 15)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPeekOptionExt) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPeekOptionExt) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sUnderlyingMarket:", st.SUnderlyingMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sUnderlyingCode:", st.SUnderlyingCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sUnerlyingName:", st.SUnerlyingName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cOptionType:", st.COptionType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cCallOrPut:", st.CCallOrPut)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iContractMutiplierUnit:", st.IContractMutiplierUnit)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dExercisePrice:", st.DExercisePrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iOpenDate:", st.IOpenDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iEndDate:", st.IEndDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iExerciseDate:", st.IExerciseDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("fTickSize:", st.FTickSize)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDaysLeft:", st.IDaysLeft)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPreDelta:", st.DPreDelta)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCurrDelta:", st.DCurrDelta)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cTradeFlag:", st.CTradeFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sContractType:", st.SContractType)

	ret = ret + " }"
	return ret
}

// HPeekDeriveData struct implement
type HPeekDeriveData struct {
	codec.JceStructBase
	OptionExt HPeekOptionExt `json:"optionExt"`
}

func (st *HPeekDeriveData) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.OptionExt.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HPeekDeriveData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = st.OptionExt.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HPeekDeriveData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HPeekDeriveData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HPeekDeriveData) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = st.OptionExt.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HPeekDeriveData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HPeekDeriveData) Display() string {
	var ret string
	ret = "{ "
	ret = ret + "optionExt:" + st.OptionExt.Display()

	ret = ret + " }"
	return ret
}

// HConnectionInfo struct implement
type HConnectionInfo struct {
	codec.JceStructBase
	SGuid       string `json:"sGuid"`
	SIp         string `json:"sIp"`
	SPlatName   string `json:"sPlatName"`
	SCVerion    string `json:"sCVerion"`
	IDate       int32  `json:"iDate"`
	LDuration   int64  `json:"lDuration"`
	CConnType   int8   `json:"cConnType"`
	SServerIp   string `json:"sServerIp"`
	SServerName string `json:"sServerName"`
}

func (st *HConnectionInfo) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.IDate = 0
	st.LDuration = 0
	st.CConnType = E_CONNE_TYPE_E_UNKONWN
}

//ReadFrom reads  from _is and put into struct.
func (st *HConnectionInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_string(&st.SGuid, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SIp, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SPlatName, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCVerion, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IDate, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LDuration, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int8(&st.CConnType, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SServerIp, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SServerName, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HConnectionInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HConnectionInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HConnectionInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_string(st.SGuid, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SIp, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SPlatName, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCVerion, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IDate, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LDuration, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int8(st.CConnType, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SServerIp, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SServerName, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HConnectionInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HConnectionInfo) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("sGuid:", st.SGuid)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sIp:", st.SIp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sPlatName:", st.SPlatName)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCVerion:", st.SCVerion)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lDuration:", st.LDuration)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("cConnType:", st.CConnType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sServerIp:", st.SServerIp)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sServerName:", st.SServerName)

	ret = ret + " }"
	return ret
}

// HConnectionReq struct implement
type HConnectionReq struct {
	codec.JceStructBase
	CInfoType    int8              `json:"cInfoType"`
	VecConneInfo []HConnectionInfo `json:"vecConneInfo"`
}

func (st *HConnectionReq) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.CInfoType = 0
}

//ReadFrom reads  from _is and put into struct.
func (st *HConnectionReq) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int8(&st.CInfoType, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VecConneInfo = make([]HConnectionInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VecConneInfo[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HConnectionReq) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HConnectionReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HConnectionReq) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int8(st.CInfoType, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VecConneInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VecConneInfo {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HConnectionReq) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HConnectionReq) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("cInfoType:", st.CInfoType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vecConneInfo:", st.VecConneInfo)

	ret = ret + " }"
	return ret
}

// HMarketCheckSum struct implement
type HMarketCheckSum struct {
	codec.JceStructBase
	ShtMarket int16  `json:"shtMarket"`
	SCheckSum string `json:"sCheckSum"`
}

func (st *HMarketCheckSum) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *HMarketCheckSum) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int16(&st.ShtMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCheckSum, 1, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HMarketCheckSum) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HMarketCheckSum, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HMarketCheckSum) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int16(st.ShtMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCheckSum, 1)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HMarketCheckSum) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *HMarketCheckSum) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("shtMarket:", st.ShtMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCheckSum:", st.SCheckSum)

	ret = ret + " }"
	return ret
}
