// Package HQSys comment
// This file was generated by jce2go 2.0.0
// Generated from BasicHq.jce
package HQSys

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"gitlab.upchinaproduct.com/taf/tafgo/taf"
	m "gitlab.upchinaproduct.com/taf/tafgo/taf/model"
	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/codec"
	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/res/basef"
	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/res/requestf"
	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/wup"
	"gitlab.upchinaproduct.com/taf/tafgo/taf/util/current"
	"gitlab.upchinaproduct.com/taf/tafgo/taf/util/tools"
	"gitlab.upchinaproduct.com/taf/tafgo/taf/util/trace"
	"unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8
var _ = unsafe.Pointer(nil)
var _ = bytes.ErrTooLarge

//BasicHq struct
type BasicHq struct {
	s m.Servant
}

//HeartBeat is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HeartBeat(stReq *HProxyHeartReq, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "heartBeat", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HeartBeatWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HeartBeatWithContext(tafCtx context.Context, stReq *HProxyHeartReq, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HeartBeat", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "heartBeat", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HeartBeat", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HeartBeatOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HeartBeatOneWayWithContext(tafCtx context.Context, stReq *HProxyHeartReq, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "heartBeat", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetQXInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetQXInfo(stReq *HQXInfoReq, stRsp *HQXInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getQXInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetQXInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetQXInfoWithContext(tafCtx context.Context, stReq *HQXInfoReq, stRsp *HQXInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetQXInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getQXInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetQXInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetQXInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetQXInfoOneWayWithContext(tafCtx context.Context, stReq *HQXInfoReq, stRsp *HQXInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getQXInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCWData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCWData(stReq *HCWDataReq, stRsp *HCWDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getCWData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCWDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCWDataWithContext(tafCtx context.Context, stReq *HCWDataReq, stRsp *HCWDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetCWData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getCWData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetCWData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCWDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCWDataOneWayWithContext(tafCtx context.Context, stReq *HCWDataReq, stRsp *HCWDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getCWData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCWVer is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCWVer(stReq *HCWVerReq, stRsp *HCWVerRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getCWVer", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCWVerWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCWVerWithContext(tafCtx context.Context, stReq *HCWVerReq, stRsp *HCWVerRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetCWVer", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getCWVer", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetCWVer", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCWVerOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCWVerOneWayWithContext(tafCtx context.Context, stReq *HCWVerReq, stRsp *HCWVerRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getCWVer", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetLTGChg is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetLTGChg(stReq *HLTGChgReq, stRsp *HLTGChgRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getLTGChg", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetLTGChgWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetLTGChgWithContext(tafCtx context.Context, stReq *HLTGChgReq, stRsp *HLTGChgRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetLTGChg", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getLTGChg", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetLTGChg", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetLTGChgOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetLTGChgOneWayWithContext(tafCtx context.Context, stReq *HLTGChgReq, stRsp *HLTGChgRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getLTGChg", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFile is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFile(stReq *HFileReq, stRsp *HFileRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getFile", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFileWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFileWithContext(tafCtx context.Context, stReq *HFileReq, stRsp *HFileRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetFile", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getFile", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetFile", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFileOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFileOneWayWithContext(tafCtx context.Context, stReq *HFileReq, stRsp *HFileRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getFile", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFileBatch is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFileBatch(stReq *HFileBatchReq, stRsp *HFileBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getFileBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFileBatchWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFileBatchWithContext(tafCtx context.Context, stReq *HFileBatchReq, stRsp *HFileBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetFileBatch", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getFileBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetFileBatch", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFileBatchOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFileBatchOneWayWithContext(tafCtx context.Context, stReq *HFileBatchReq, stRsp *HFileBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getFileBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseInfo(stReq *HStockBaseInfoReq, stRsp *HStockBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseInfoWithContext(tafCtx context.Context, stReq *HStockBaseInfoReq, stRsp *HStockBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockBaseInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockBaseInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseInfoOneWayWithContext(tafCtx context.Context, stReq *HStockBaseInfoReq, stRsp *HStockBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseInfoSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseInfoSimple(stReq *HStockBaseInfoSimpleReq, stRsp *HStockBaseInfoSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockBaseInfoSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseInfoSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseInfoSimpleWithContext(tafCtx context.Context, stReq *HStockBaseInfoSimpleReq, stRsp *HStockBaseInfoSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockBaseInfoSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockBaseInfoSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockBaseInfoSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseInfoSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseInfoSimpleOneWayWithContext(tafCtx context.Context, stReq *HStockBaseInfoSimpleReq, stRsp *HStockBaseInfoSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockBaseInfoSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockStaticInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockStaticInfo(stReq *HStockBaseInfoReq, stRsp *HStockStaticInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockStaticInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockStaticInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockStaticInfoWithContext(tafCtx context.Context, stReq *HStockBaseInfoReq, stRsp *HStockStaticInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockStaticInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockStaticInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockStaticInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockStaticInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockStaticInfoOneWayWithContext(tafCtx context.Context, stReq *HStockBaseInfoReq, stRsp *HStockStaticInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockStaticInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MarketBaseInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MarketBaseInfo(stReq *HMarketBaseInfoReq, stRsp *HMarketBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "marketBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MarketBaseInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MarketBaseInfoWithContext(tafCtx context.Context, stReq *HMarketBaseInfoReq, stRsp *HMarketBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "MarketBaseInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "marketBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "MarketBaseInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MarketBaseInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MarketBaseInfoOneWayWithContext(tafCtx context.Context, stReq *HMarketBaseInfoReq, stRsp *HMarketBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "marketBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UserLogin is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) UserLogin(stReq *HUserLoginReq, stRsp *HUserLoginRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "userLogin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UserLoginWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) UserLoginWithContext(tafCtx context.Context, stReq *HUserLoginReq, stRsp *HUserLoginRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "UserLogin", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "userLogin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "UserLogin", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UserLoginOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) UserLoginOneWayWithContext(tafCtx context.Context, stReq *HUserLoginReq, stRsp *HUserLoginRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "userLogin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UserSimpleLogin is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) UserSimpleLogin(stReq *HUserSimpleLoginReq, stRsp *HUserSimpleLoginRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "userSimpleLogin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UserSimpleLoginWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) UserSimpleLoginWithContext(tafCtx context.Context, stReq *HUserSimpleLoginReq, stRsp *HUserSimpleLoginRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "UserSimpleLogin", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "userSimpleLogin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "UserSimpleLogin", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//UserSimpleLoginOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) UserSimpleLoginOneWayWithContext(tafCtx context.Context, stReq *HUserSimpleLoginReq, stRsp *HUserSimpleLoginRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "userSimpleLogin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDict is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDict(stReq *HStockDictReq, stRsp *HStockDictRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDict", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDictWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDictWithContext(tafCtx context.Context, stReq *HStockDictReq, stRsp *HStockDictRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDict", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDict", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDict", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDictOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDictOneWayWithContext(tafCtx context.Context, stReq *HStockDictReq, stRsp *HStockDictRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockDict", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDictSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDictSimple(stReq *HStockDictSimpleReq, stRsp *HStockDictSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDictSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDictSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDictSimpleWithContext(tafCtx context.Context, stReq *HStockDictSimpleReq, stRsp *HStockDictSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDictSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDictSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDictSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDictSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDictSimpleOneWayWithContext(tafCtx context.Context, stReq *HStockDictSimpleReq, stRsp *HStockDictSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockDictSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseBatch is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseBatch(stReq *HStockBaseBatchReq, stRsp *HStockBaseBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockBaseBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseBatchWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseBatchWithContext(tafCtx context.Context, stReq *HStockBaseBatchReq, stRsp *HStockBaseBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockBaseBatch", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockBaseBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockBaseBatch", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBaseBatchOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBaseBatchOneWayWithContext(tafCtx context.Context, stReq *HStockBaseBatchReq, stRsp *HStockBaseBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockBaseBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCQCX is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCQCX(stReq *HCQCXReq, stRsp *HCQCXRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getCQCX", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCQCXWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCQCXWithContext(tafCtx context.Context, stReq *HCQCXReq, stRsp *HCQCXRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetCQCX", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getCQCX", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetCQCX", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetCQCXOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetCQCXOneWayWithContext(tafCtx context.Context, stReq *HCQCXReq, stRsp *HCQCXRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getCQCX", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetTradePeriod is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetTradePeriod(stReq *HTradePeriodReq, stRsp *HTradePeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getTradePeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetTradePeriodWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetTradePeriodWithContext(tafCtx context.Context, stReq *HTradePeriodReq, stRsp *HTradePeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetTradePeriod", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getTradePeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetTradePeriod", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetTradePeriodOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetTradePeriodOneWayWithContext(tafCtx context.Context, stReq *HTradePeriodReq, stRsp *HTradePeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getTradePeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetPeriod is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetPeriod(stReq *HPeriodReq, stRsp *HPeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getPeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetPeriodWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetPeriodWithContext(tafCtx context.Context, stReq *HPeriodReq, stRsp *HPeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetPeriod", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getPeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetPeriod", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetPeriodOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetPeriodOneWayWithContext(tafCtx context.Context, stReq *HPeriodReq, stRsp *HPeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getPeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetInterval is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetInterval(stReq *HIntervalReq, stRsp *HIntervalRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getInterval", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetIntervalWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetIntervalWithContext(tafCtx context.Context, stReq *HIntervalReq, stRsp *HIntervalRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetInterval", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getInterval", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetInterval", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetIntervalOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetIntervalOneWayWithContext(tafCtx context.Context, stReq *HIntervalReq, stRsp *HIntervalRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getInterval", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ZhRank is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) ZhRank(stReq *HZHRankReq, stRsp *HZHRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "zhRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ZhRankWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) ZhRankWithContext(tafCtx context.Context, stReq *HZHRankReq, stRsp *HZHRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "ZhRank", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "zhRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "ZhRank", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ZhRankOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) ZhRankOneWayWithContext(tafCtx context.Context, stReq *HZHRankReq, stRsp *HZHRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "zhRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfRankSimp is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfRankSimp(stReq *HMFRankSimReq, stRsp *HMFRankSimpRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "mfRankSimp", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfRankSimpWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfRankSimpWithContext(tafCtx context.Context, stReq *HMFRankSimReq, stRsp *HMFRankSimpRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "MfRankSimp", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "mfRankSimp", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "MfRankSimp", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfRankSimpOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfRankSimpOneWayWithContext(tafCtx context.Context, stReq *HMFRankSimReq, stRsp *HMFRankSimpRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "mfRankSimp", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BkLed is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BkLed(stReq *HBKLedReq, stRsp *HBKLedRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "bkLed", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BkLedWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BkLedWithContext(tafCtx context.Context, stReq *HBKLedReq, stRsp *HBKLedRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BkLed", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "bkLed", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BkLed", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BkLedOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BkLedOneWayWithContext(tafCtx context.Context, stReq *HBKLedReq, stRsp *HBKLedRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "bkLed", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionBaseInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionBaseInfo(stReq *HOptionBaseInfoReq, stRsp *HOptionBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "optionBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionBaseInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionBaseInfoWithContext(tafCtx context.Context, stReq *HOptionBaseInfoReq, stRsp *HOptionBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptionBaseInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "optionBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptionBaseInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionBaseInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionBaseInfoOneWayWithContext(tafCtx context.Context, stReq *HOptionBaseInfoReq, stRsp *HOptionBaseInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "optionBaseInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionUnderlyingDict is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionUnderlyingDict(stReq *HOptionUnderlyingDictReq, stRsp *HOptionUnderlyingDictRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "optionUnderlyingDict", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionUnderlyingDictWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionUnderlyingDictWithContext(tafCtx context.Context, stReq *HOptionUnderlyingDictReq, stRsp *HOptionUnderlyingDictRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptionUnderlyingDict", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "optionUnderlyingDict", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptionUnderlyingDict", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionUnderlyingDictOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionUnderlyingDictOneWayWithContext(tafCtx context.Context, stReq *HOptionUnderlyingDictReq, stRsp *HOptionUnderlyingDictRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "optionUnderlyingDict", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionStock is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionStock(stReq *HOptionStockReq, stRsp *HOptionStockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "optionStock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionStockWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionStockWithContext(tafCtx context.Context, stReq *HOptionStockReq, stRsp *HOptionStockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptionStock", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "optionStock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptionStock", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptionStockOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptionStockOneWayWithContext(tafCtx context.Context, stReq *HOptionStockReq, stRsp *HOptionStockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "optionStock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//EtfInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) EtfInfo(stReq *HEtfInfoReq, stRsp *HEtfInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "etfInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//EtfInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) EtfInfoWithContext(tafCtx context.Context, stReq *HEtfInfoReq, stRsp *HEtfInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "EtfInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "etfInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "EtfInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//EtfInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) EtfInfoOneWayWithContext(tafCtx context.Context, stReq *HEtfInfoReq, stRsp *HEtfInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "etfInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockHq is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockHq(stReq *HStockHqReq, stRsp *HStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockHqWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockHqWithContext(tafCtx context.Context, stReq *HStockHqReq, stRsp *HStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockHq", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockHq", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockHqOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockHqOneWayWithContext(tafCtx context.Context, stReq *HStockHqReq, stRsp *HStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Qt is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Qt(stReq *HStockHqReq, stRsp *HStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "qt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//QtWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) QtWithContext(tafCtx context.Context, stReq *HStockHqReq, stRsp *HStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Qt", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "qt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Qt", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//QtOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) QtOneWayWithContext(tafCtx context.Context, stReq *HStockHqReq, stRsp *HStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "qt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockHqSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockHqSimple(stReq *HStockHqSimpleReq, stRsp *HStockHqSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockHqSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockHqSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockHqSimpleWithContext(tafCtx context.Context, stReq *HStockHqSimpleReq, stRsp *HStockHqSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockHqSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockHqSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockHqSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockHqSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockHqSimpleOneWayWithContext(tafCtx context.Context, stReq *HStockHqSimpleReq, stRsp *HStockHqSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockHqSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptStockHqEx is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptStockHqEx(stReq *OptStockHqExReq, stRsp *OptStockHqExRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "optStockHqEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptStockHqExWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptStockHqExWithContext(tafCtx context.Context, stReq *OptStockHqExReq, stRsp *OptStockHqExRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptStockHqEx", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "optStockHqEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptStockHqEx", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptStockHqExOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptStockHqExOneWayWithContext(tafCtx context.Context, stReq *OptStockHqExReq, stRsp *OptStockHqExRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "optStockHqEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptStockHq is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptStockHq(stReq *HOptStockHqReq, stRsp *HOptStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "optStockHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptStockHqWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptStockHqWithContext(tafCtx context.Context, stReq *HOptStockHqReq, stRsp *HOptStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptStockHq", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "optStockHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OptStockHq", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OptStockHqOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OptStockHqOneWayWithContext(tafCtx context.Context, stReq *HOptStockHqReq, stRsp *HOptStockHqRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "optStockHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RtMinData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RtMinData(stReq *HRTMinDataReq, stRsp *HRTMinDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "rtMinData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RtMinDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RtMinDataWithContext(tafCtx context.Context, stReq *HRTMinDataReq, stRsp *HRTMinDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RtMinData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "rtMinData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RtMinData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RtMinDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RtMinDataOneWayWithContext(tafCtx context.Context, stReq *HRTMinDataReq, stRsp *HRTMinDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "rtMinData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RtMinDataSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RtMinDataSimple(stReq *HRTMinDataSimpleReq, stRsp *HRTMinDataSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "rtMinDataSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RtMinDataSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RtMinDataSimpleWithContext(tafCtx context.Context, stReq *HRTMinDataSimpleReq, stRsp *HRTMinDataSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RtMinDataSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "rtMinDataSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RtMinDataSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RtMinDataSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RtMinDataSimpleOneWayWithContext(tafCtx context.Context, stReq *HRTMinDataSimpleReq, stRsp *HRTMinDataSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "rtMinDataSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisRtMinute is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisRtMinute(stReq *HHisMinuteReq, stRsp *HHisMinuteRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisRtMinute", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisRtMinuteWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisRtMinuteWithContext(tafCtx context.Context, stReq *HHisMinuteReq, stRsp *HHisMinuteRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisRtMinute", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisRtMinute", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisRtMinute", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisRtMinuteOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisRtMinuteOneWayWithContext(tafCtx context.Context, stReq *HHisMinuteReq, stRsp *HHisMinuteRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "hisRtMinute", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisRtMinuteSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisRtMinuteSimple(stReq *HHisMinuteSimpleReq, stRsp *HHisMinuteSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisRtMinuteSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisRtMinuteSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisRtMinuteSimpleWithContext(tafCtx context.Context, stReq *HHisMinuteSimpleReq, stRsp *HHisMinuteSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisRtMinuteSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisRtMinuteSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisRtMinuteSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisRtMinuteSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisRtMinuteSimpleOneWayWithContext(tafCtx context.Context, stReq *HHisMinuteSimpleReq, stRsp *HHisMinuteSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "hisRtMinuteSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisMinBatch is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisMinBatch(stReq *HHisMinBatchReq, stRsp *HHisMinBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisMinBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisMinBatchWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisMinBatchWithContext(tafCtx context.Context, stReq *HHisMinBatchReq, stRsp *HHisMinBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisMinBatch", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisMinBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisMinBatch", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisMinBatchOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisMinBatchOneWayWithContext(tafCtx context.Context, stReq *HHisMinBatchReq, stRsp *HHisMinBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "hisMinBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisMinBatchSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisMinBatchSimple(stReq *HHisMinBatchSimpleReq, stRsp *HHisMinBatchSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisMinBatchSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisMinBatchSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisMinBatchSimpleWithContext(tafCtx context.Context, stReq *HHisMinBatchSimpleReq, stRsp *HHisMinBatchSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisMinBatchSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisMinBatchSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisMinBatchSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisMinBatchSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisMinBatchSimpleOneWayWithContext(tafCtx context.Context, stReq *HHisMinBatchSimpleReq, stRsp *HHisMinBatchSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "hisMinBatchSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TickData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TickData(stReq *HTickDataReq, stRsp *HTickDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "tickData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TickDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TickDataWithContext(tafCtx context.Context, stReq *HTickDataReq, stRsp *HTickDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "TickData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "tickData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "TickData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TickDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TickDataOneWayWithContext(tafCtx context.Context, stReq *HTickDataReq, stRsp *HTickDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "tickData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisTick is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisTick(stReq *HHisTickReq, stRsp *HHisTickRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisTick", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisTickWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisTickWithContext(tafCtx context.Context, stReq *HHisTickReq, stRsp *HHisTickRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisTick", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "hisTick", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HisTick", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HisTickOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HisTickOneWayWithContext(tafCtx context.Context, stReq *HHisTickReq, stRsp *HHisTickRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "hisTick", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlow is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlow(stReq *HStockMFlowReq, stRsp *HStockMFlowRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockMFlow", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowWithContext(tafCtx context.Context, stReq *HStockMFlowReq, stRsp *HStockMFlowRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockMFlow", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockMFlow", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockMFlow", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowOneWayWithContext(tafCtx context.Context, stReq *HStockMFlowReq, stRsp *HStockMFlowRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockMFlow", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowBatch is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowBatch(stReq *HStockMFlowBatchReq, stRsp *HStockMFlowBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockMFlowBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowBatchWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowBatchWithContext(tafCtx context.Context, stReq *HStockMFlowBatchReq, stRsp *HStockMFlowBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockMFlowBatch", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockMFlowBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockMFlowBatch", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowBatchOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowBatchOneWayWithContext(tafCtx context.Context, stReq *HStockMFlowBatchReq, stRsp *HStockMFlowBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockMFlowBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowByDay is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowByDay(stReq *HMFlowByDayReq, stRsp *HMFlowByDayRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockMFlowByDay", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowByDayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowByDayWithContext(tafCtx context.Context, stReq *HMFlowByDayReq, stRsp *HMFlowByDayRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockMFlowByDay", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockMFlowByDay", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockMFlowByDay", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowByDayOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowByDayOneWayWithContext(tafCtx context.Context, stReq *HMFlowByDayReq, stRsp *HMFlowByDayRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockMFlowByDay", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfByTrade is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfByTrade(stReq *HMFByTradeReq, stRsp *HMFByTradeRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "mfByTrade", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfByTradeWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfByTradeWithContext(tafCtx context.Context, stReq *HMFByTradeReq, stRsp *HMFByTradeRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "MfByTrade", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "mfByTrade", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "MfByTrade", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfByTradeOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfByTradeOneWayWithContext(tafCtx context.Context, stReq *HMFByTradeReq, stRsp *HMFByTradeRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "mfByTrade", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowData(stReq *HStockMFlowDataReq, stRsp *HStockMFlowDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockMFlowData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowDataWithContext(tafCtx context.Context, stReq *HStockMFlowDataReq, stRsp *HStockMFlowDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockMFlowData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockMFlowData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockMFlowData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockMFlowDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockMFlowDataOneWayWithContext(tafCtx context.Context, stReq *HStockMFlowDataReq, stRsp *HStockMFlowDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockMFlowData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBatchMFlowData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBatchMFlowData(stReq *HStockBatchMFlowDataReq, stRsp *HStockBatchMFlowDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockBatchMFlowData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBatchMFlowDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBatchMFlowDataWithContext(tafCtx context.Context, stReq *HStockBatchMFlowDataReq, stRsp *HStockBatchMFlowDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockBatchMFlowData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockBatchMFlowData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockBatchMFlowData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockBatchMFlowDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockBatchMFlowDataOneWayWithContext(tafCtx context.Context, stReq *HStockBatchMFlowDataReq, stRsp *HStockBatchMFlowDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockBatchMFlowData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineData(stReq *HKLineDataReq, stRsp *HKLineDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "kLineData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataWithContext(tafCtx context.Context, stReq *HKLineDataReq, stRsp *HKLineDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "KLineData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "kLineData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "KLineData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataOneWayWithContext(tafCtx context.Context, stReq *HKLineDataReq, stRsp *HKLineDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "kLineData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataSimple(stReq *HKLineDataSimpleReq, stRsp *HKLineDataSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "kLineDataSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataSimpleWithContext(tafCtx context.Context, stReq *HKLineDataSimpleReq, stRsp *HKLineDataSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "KLineDataSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "kLineDataSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "KLineDataSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataSimpleOneWayWithContext(tafCtx context.Context, stReq *HKLineDataSimpleReq, stRsp *HKLineDataSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "kLineDataSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegKLine is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegKLine(stReq *HRegKLineReq, stRsp *HRegKLineRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "regKLine", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegKLineWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegKLineWithContext(tafCtx context.Context, stReq *HRegKLineReq, stRsp *HRegKLineRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegKLine", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "regKLine", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegKLine", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegKLineOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegKLineOneWayWithContext(tafCtx context.Context, stReq *HRegKLineReq, stRsp *HRegKLineRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "regKLine", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegKLineSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegKLineSimple(stReq *HRegKLineSimpleReq, stRsp *HRegKLineSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "regKLineSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegKLineSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegKLineSimpleWithContext(tafCtx context.Context, stReq *HRegKLineSimpleReq, stRsp *HRegKLineSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegKLineSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "regKLineSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegKLineSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegKLineSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegKLineSimpleOneWayWithContext(tafCtx context.Context, stReq *HRegKLineSimpleReq, stRsp *HRegKLineSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "regKLineSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataByPeriod is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataByPeriod(stReq *HKLineDataByPeriodReq, stRsp *HKLineDataByPeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "kLineDataByPeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataByPeriodWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataByPeriodWithContext(tafCtx context.Context, stReq *HKLineDataByPeriodReq, stRsp *HKLineDataByPeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "KLineDataByPeriod", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "kLineDataByPeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "KLineDataByPeriod", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataByPeriodOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataByPeriodOneWayWithContext(tafCtx context.Context, stReq *HKLineDataByPeriodReq, stRsp *HKLineDataByPeriodRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "kLineDataByPeriod", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataByPeriodSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataByPeriodSimple(stReq *HKLineDataByPeriodSimpleReq, stRsp *HKLineDataByPeriodSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "kLineDataByPeriodSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataByPeriodSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataByPeriodSimpleWithContext(tafCtx context.Context, stReq *HKLineDataByPeriodSimpleReq, stRsp *HKLineDataByPeriodSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "KLineDataByPeriodSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "kLineDataByPeriodSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "KLineDataByPeriodSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//KLineDataByPeriodSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) KLineDataByPeriodSimpleOneWayWithContext(tafCtx context.Context, stReq *HKLineDataByPeriodSimpleReq, stRsp *HKLineDataByPeriodSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "kLineDataByPeriodSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockKLineData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockKLineData(stReq *HStockKLineReq, stRsp *HStockKLineRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockKLineData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockKLineDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockKLineDataWithContext(tafCtx context.Context, stReq *HStockKLineReq, stRsp *HStockKLineRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockKLineData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockKLineData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockKLineData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockKLineDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockKLineDataOneWayWithContext(tafCtx context.Context, stReq *HStockKLineReq, stRsp *HStockKLineRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockKLineData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfRank is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfRank(stReq *HMFlowRankReq, stRsp *HMFlowRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "mfRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfRankWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfRankWithContext(tafCtx context.Context, stReq *HMFlowRankReq, stRsp *HMFlowRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "MfRank", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "mfRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "MfRank", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//MfRankOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) MfRankOneWayWithContext(tafCtx context.Context, stReq *HMFlowRankReq, stRsp *HMFlowRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "mfRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDERank is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDERank(stReq *HDDERankReq, stRsp *HDDERankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDDERank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDERankWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDERankWithContext(tafCtx context.Context, stReq *HDDERankReq, stRsp *HDDERankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDDERank", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDDERank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDDERank", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDERankOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDERankOneWayWithContext(tafCtx context.Context, stReq *HDDERankReq, stRsp *HDDERankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockDDERank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDEBatch is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDEBatch(stReq *HStockDDEBatchReq, stRsp *HStockDDEBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDDEBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDEBatchWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDEBatchWithContext(tafCtx context.Context, stReq *HStockDDEBatchReq, stRsp *HStockDDEBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDDEBatch", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDDEBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDDEBatch", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDEBatchOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDEBatchOneWayWithContext(tafCtx context.Context, stReq *HStockDDEBatchReq, stRsp *HStockDDEBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockDDEBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Dxjl is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Dxjl(stReq *HDxjlReq, stRsp *HDxjlRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "dxjl", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DxjlWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) DxjlWithContext(tafCtx context.Context, stReq *HDxjlReq, stRsp *HDxjlRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Dxjl", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "dxjl", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Dxjl", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//DxjlOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) DxjlOneWayWithContext(tafCtx context.Context, stReq *HDxjlReq, stRsp *HDxjlRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "dxjl", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2Monit is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2Monit(stReq *HL2MonitReq, stRsp *HL2MonitRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "l2Monit", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2MonitWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2MonitWithContext(tafCtx context.Context, stReq *HL2MonitReq, stRsp *HL2MonitRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2Monit", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "l2Monit", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2Monit", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2MonitOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2MonitOneWayWithContext(tafCtx context.Context, stReq *HL2MonitReq, stRsp *HL2MonitRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "l2Monit", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2Szfy is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2Szfy(stReq *HLV2SZFYReq, stRsp *HLV2SZFYRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "l2Szfy", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2SzfyWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2SzfyWithContext(tafCtx context.Context, stReq *HLV2SZFYReq, stRsp *HLV2SZFYRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2Szfy", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "l2Szfy", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2Szfy", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2SzfyOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2SzfyOneWayWithContext(tafCtx context.Context, stReq *HLV2SZFYReq, stRsp *HLV2SZFYRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "l2Szfy", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2SzfyCom is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2SzfyCom(stReq *HSZFYComReq, stRsp *HSZFYComRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "l2SzfyCom", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2SzfyComWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2SzfyComWithContext(tafCtx context.Context, stReq *HSZFYComReq, stRsp *HSZFYComRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2SzfyCom", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "l2SzfyCom", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2SzfyCom", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2SzfyComOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2SzfyComOneWayWithContext(tafCtx context.Context, stReq *HSZFYComReq, stRsp *HSZFYComRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "l2SzfyCom", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAHList is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAHList(stReq *HStockAHListReq, stRsp *HStockAHListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockAHList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAHListWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAHListWithContext(tafCtx context.Context, stReq *HStockAHListReq, stRsp *HStockAHListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockAHList", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockAHList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockAHList", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAHListOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAHListOneWayWithContext(tafCtx context.Context, stReq *HStockAHListReq, stRsp *HStockAHListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockAHList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAH is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAH(stReq *HStockAHReq, stRsp *HStockAHRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockAH", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAHWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAHWithContext(tafCtx context.Context, stReq *HStockAHReq, stRsp *HStockAHRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockAH", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockAH", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockAH", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAHOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAHOneWayWithContext(tafCtx context.Context, stReq *HStockAHReq, stRsp *HStockAHRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockAH", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAHBatch is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAHBatch(stReq *HStockAHReq, stRsp *HStockAHBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockAHBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAHBatchWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAHBatchWithContext(tafCtx context.Context, stReq *HStockAHReq, stRsp *HStockAHBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockAHBatch", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockAHBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockAHBatch", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockAHBatchOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockAHBatchOneWayWithContext(tafCtx context.Context, stReq *HStockAHReq, stRsp *HStockAHBatchRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockAHBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDZ is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDZ(stReq *HStockDDZReq, stRsp *HStockDDZRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDDZ", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDZWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDZWithContext(tafCtx context.Context, stReq *HStockDDZReq, stRsp *HStockDDZRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDDZ", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockDDZ", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockDDZ", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockDDZOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockDDZOneWayWithContext(tafCtx context.Context, stReq *HStockDDZReq, stRsp *HStockDDZRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockDDZ", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BrokerQueue is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BrokerQueue(stReq *HBrokerQueueReq, stRsp *HBrokerQueueRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "brokerQueue", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BrokerQueueWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BrokerQueueWithContext(tafCtx context.Context, stReq *HBrokerQueueReq, stRsp *HBrokerQueueRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BrokerQueue", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "brokerQueue", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BrokerQueue", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BrokerQueueOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BrokerQueueOneWayWithContext(tafCtx context.Context, stReq *HBrokerQueueReq, stRsp *HBrokerQueueRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "brokerQueue", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegStatus is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegStatus(stReq *HRegStatusReq, stRsp *HRegStatusRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "regStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegStatusWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegStatusWithContext(tafCtx context.Context, stReq *HRegStatusReq, stRsp *HRegStatusRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegStatus", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "regStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegStatus", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegStatusOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegStatusOneWayWithContext(tafCtx context.Context, stReq *HRegStatusReq, stRsp *HRegStatusRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "regStatus", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetCltInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) SetCltInfo(stReq *HCltInfoReq, stRsp *HCltInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "setCltInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetCltInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) SetCltInfoWithContext(tafCtx context.Context, stReq *HCltInfoReq, stRsp *HCltInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "SetCltInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "setCltInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "SetCltInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetCltInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) SetCltInfoOneWayWithContext(tafCtx context.Context, stReq *HCltInfoReq, stRsp *HCltInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "setCltInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetNewStockPerform is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetNewStockPerform(stReq *HNewStockPerformReq, stRsp *HNewStockPerformRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getNewStockPerform", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetNewStockPerformWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetNewStockPerformWithContext(tafCtx context.Context, stReq *HNewStockPerformReq, stRsp *HNewStockPerformRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetNewStockPerform", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getNewStockPerform", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetNewStockPerform", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetNewStockPerformOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetNewStockPerformOneWayWithContext(tafCtx context.Context, stReq *HNewStockPerformReq, stRsp *HNewStockPerformRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getNewStockPerform", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetNewStockPerformByStock is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetNewStockPerformByStock(stReq *HNewStockPerformByStockReq, stRsp *HNewStockPerformRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getNewStockPerformByStock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetNewStockPerformByStockWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetNewStockPerformByStockWithContext(tafCtx context.Context, stReq *HNewStockPerformByStockReq, stRsp *HNewStockPerformRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetNewStockPerformByStock", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getNewStockPerformByStock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetNewStockPerformByStock", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetNewStockPerformByStockOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetNewStockPerformByStockOneWayWithContext(tafCtx context.Context, stReq *HNewStockPerformByStockReq, stRsp *HNewStockPerformRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getNewStockPerformByStock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RangeStats is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RangeStats(stReq *HRangeStatsReq, stRsp *HRangeStatsRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "rangeStats", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RangeStatsWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RangeStatsWithContext(tafCtx context.Context, stReq *HRangeStatsReq, stRsp *HRangeStatsRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RangeStats", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "rangeStats", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RangeStats", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RangeStatsOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RangeStatsOneWayWithContext(tafCtx context.Context, stReq *HRangeStatsReq, stRsp *HRangeStatsRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "rangeStats", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HotPlateHq is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HotPlateHq(stReq *HHotPlateReq, stRsp *HHotPlateRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "hotPlateHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HotPlateHqWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HotPlateHqWithContext(tafCtx context.Context, stReq *HHotPlateReq, stRsp *HHotPlateRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HotPlateHq", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "hotPlateHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HotPlateHq", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HotPlateHqOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HotPlateHqOneWayWithContext(tafCtx context.Context, stReq *HHotPlateReq, stRsp *HHotPlateRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "hotPlateHq", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Type2Stock is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Type2Stock(stReq *HType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "type2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Type2StockWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Type2StockWithContext(tafCtx context.Context, stReq *HType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Type2Stock", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "type2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Type2Stock", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Type2StockOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Type2StockOneWayWithContext(tafCtx context.Context, stReq *HType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "type2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TypeList is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TypeList(stReq *HType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "typeList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TypeListWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TypeListWithContext(tafCtx context.Context, stReq *HType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "TypeList", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "typeList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "TypeList", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TypeListOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TypeListOneWayWithContext(tafCtx context.Context, stReq *HType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "typeList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TypeListSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TypeListSimple(stReq *HTypeListSimpleReq, stRsp *HType2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "typeListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TypeListSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TypeListSimpleWithContext(tafCtx context.Context, stReq *HTypeListSimpleReq, stRsp *HType2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "TypeListSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "typeListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "TypeListSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TypeListSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TypeListSimpleOneWayWithContext(tafCtx context.Context, stReq *HTypeListSimpleReq, stRsp *HType2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "typeListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Type2StockSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Type2StockSimple(stReq *HType2StockSimpleReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "type2StockSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Type2StockSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Type2StockSimpleWithContext(tafCtx context.Context, stReq *HType2StockSimpleReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Type2StockSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "type2StockSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Type2StockSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Type2StockSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Type2StockSimpleOneWayWithContext(tafCtx context.Context, stReq *HType2StockSimpleReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "type2StockSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BusList is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BusList(stReq *HType2StockSimpleReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "busList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BusListWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BusListWithContext(tafCtx context.Context, stReq *HType2StockSimpleReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BusList", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "busList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BusList", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BusListOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BusListOneWayWithContext(tafCtx context.Context, stReq *HType2StockSimpleReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "busList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BusListSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BusListSimple(stReq *HBusListSimpleReq, stRsp *HType2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "busListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BusListSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BusListSimpleWithContext(tafCtx context.Context, stReq *HBusListSimpleReq, stRsp *HType2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BusListSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "busListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BusListSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BusListSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BusListSimpleOneWayWithContext(tafCtx context.Context, stReq *HBusListSimpleReq, stRsp *HType2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "busListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Block2Stock is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Block2Stock(stReq *HBlock2StockReq, stRsp *HBlock2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "block2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Block2StockWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Block2StockWithContext(tafCtx context.Context, stReq *HBlock2StockReq, stRsp *HBlock2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Block2Stock", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "block2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Block2Stock", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Block2StockOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Block2StockOneWayWithContext(tafCtx context.Context, stReq *HBlock2StockReq, stRsp *HBlock2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "block2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockList is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockList(stReq *HBlock2StockReq, stRsp *HBlock2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "blockList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockListWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockListWithContext(tafCtx context.Context, stReq *HBlock2StockReq, stRsp *HBlock2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BlockList", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "blockList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BlockList", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockListOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockListOneWayWithContext(tafCtx context.Context, stReq *HBlock2StockReq, stRsp *HBlock2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "blockList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockListSimple is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockListSimple(stReq *HBlock2StockSimpleReq, stRsp *HBlock2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "blockListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockListSimpleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockListSimpleWithContext(tafCtx context.Context, stReq *HBlock2StockSimpleReq, stRsp *HBlock2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BlockListSimple", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "blockListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BlockListSimple", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockListSimpleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockListSimpleOneWayWithContext(tafCtx context.Context, stReq *HBlock2StockSimpleReq, stRsp *HBlock2StockSimpleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "blockListSimple", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockTsLevel is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockTsLevel(stReq *HTsBlockLevelReq, stRsp *HTsBlockLevelRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "blockTsLevel", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockTsLevelWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockTsLevelWithContext(tafCtx context.Context, stReq *HTsBlockLevelReq, stRsp *HTsBlockLevelRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BlockTsLevel", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "blockTsLevel", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "BlockTsLevel", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//BlockTsLevelOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) BlockTsLevelOneWayWithContext(tafCtx context.Context, stReq *HTsBlockLevelReq, stRsp *HTsBlockLevelRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "blockTsLevel", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CustomType2Stock is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) CustomType2Stock(stReq *HCustomType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "customType2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CustomType2StockWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) CustomType2StockWithContext(tafCtx context.Context, stReq *HCustomType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "CustomType2Stock", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "customType2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "CustomType2Stock", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CustomType2StockOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) CustomType2StockOneWayWithContext(tafCtx context.Context, stReq *HCustomType2StockReq, stRsp *HType2StockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "customType2Stock", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SortList is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) SortList(stReq *HSortListReq, stRsp *HSortListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "sortList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SortListWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) SortListWithContext(tafCtx context.Context, stReq *HSortListReq, stRsp *HSortListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "SortList", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "sortList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "SortList", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SortListOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) SortListOneWayWithContext(tafCtx context.Context, stReq *HSortListReq, stRsp *HSortListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "sortList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Stock2Block is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Stock2Block(stReq *HStock2BlockReq, stRsp *HStock2BlockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stock2Block", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Stock2BlockWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Stock2BlockWithContext(tafCtx context.Context, stReq *HStock2BlockReq, stRsp *HStock2BlockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Stock2Block", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stock2Block", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Stock2Block", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Stock2BlockOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Stock2BlockOneWayWithContext(tafCtx context.Context, stReq *HStock2BlockReq, stRsp *HStock2BlockRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stock2Block", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Stock2Industry is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Stock2Industry(stReq *HStock2IndustryReq, stRsp *HStock2IndustryRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stock2Industry", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Stock2IndustryWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Stock2IndustryWithContext(tafCtx context.Context, stReq *HStock2IndustryReq, stRsp *HStock2IndustryRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Stock2Industry", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stock2Industry", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Stock2Industry", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Stock2IndustryOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Stock2IndustryOneWayWithContext(tafCtx context.Context, stReq *HStock2IndustryReq, stRsp *HStock2IndustryRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stock2Industry", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegCPTMin is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegCPTMin(stReq *HRegCPTMinReq, stRsp *HRegCPTMinRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "regCPTMin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegCPTMinWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegCPTMinWithContext(tafCtx context.Context, stReq *HRegCPTMinReq, stRsp *HRegCPTMinRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegCPTMin", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "regCPTMin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegCPTMin", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegCPTMinOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegCPTMinOneWayWithContext(tafCtx context.Context, stReq *HRegCPTMinReq, stRsp *HRegCPTMinRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "regCPTMin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegMarketInit is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegMarketInit(stReq *HRegMarketInitReq, stRsp *HRegMarketInitRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "regMarketInit", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegMarketInitWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegMarketInitWithContext(tafCtx context.Context, stReq *HRegMarketInitReq, stRsp *HRegMarketInitRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegMarketInit", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "regMarketInit", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegMarketInit", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegMarketInitOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegMarketInitOneWayWithContext(tafCtx context.Context, stReq *HRegMarketInitReq, stRsp *HRegMarketInitRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "regMarketInit", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegCodes is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegCodes(stReq *HRegCodesReq, stRsp *HRegCodesRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "regCodes", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegCodesWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegCodesWithContext(tafCtx context.Context, stReq *HRegCodesReq, stRsp *HRegCodesRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegCodes", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "regCodes", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RegCodes", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RegCodesOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RegCodesOneWayWithContext(tafCtx context.Context, stReq *HRegCodesReq, stRsp *HRegCodesRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "regCodes", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderQueue is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderQueue(stReq *HOrderQueueReq, stRsp *HOrderQueueRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "orderQueue", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderQueueWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderQueueWithContext(tafCtx context.Context, stReq *HOrderQueueReq, stRsp *HOrderQueueRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OrderQueue", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "orderQueue", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OrderQueue", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderQueueOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderQueueOneWayWithContext(tafCtx context.Context, stReq *HOrderQueueReq, stRsp *HOrderQueueRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "orderQueue", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TransData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TransData(stReq *HTransDataReq, stRsp *HTransDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "transData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TransDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TransDataWithContext(tafCtx context.Context, stReq *HTransDataReq, stRsp *HTransDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "TransData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "transData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "TransData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//TransDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) TransDataOneWayWithContext(tafCtx context.Context, stReq *HTransDataReq, stRsp *HTransDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "transData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderRec is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderRec(stReq *HOrderRecReq, stRsp *HOrderRecRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "orderRec", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderRecWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderRecWithContext(tafCtx context.Context, stReq *HOrderRecReq, stRsp *HOrderRecRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OrderRec", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "orderRec", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OrderRec", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderRecOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderRecOneWayWithContext(tafCtx context.Context, stReq *HOrderRecReq, stRsp *HOrderRecRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "orderRec", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//PriceOrder is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) PriceOrder(stReq *HPriceOrderReq, stRsp *HPriceOrderRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "priceOrder", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//PriceOrderWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) PriceOrderWithContext(tafCtx context.Context, stReq *HPriceOrderReq, stRsp *HPriceOrderRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "PriceOrder", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "priceOrder", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "PriceOrder", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//PriceOrderOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) PriceOrderOneWayWithContext(tafCtx context.Context, stReq *HPriceOrderReq, stRsp *HPriceOrderRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "priceOrder", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RadarQt is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RadarQt(stReq *HRadarQtReq, stRsp *HRadarQtRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "radarQt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RadarQtWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RadarQtWithContext(tafCtx context.Context, stReq *HRadarQtReq, stRsp *HRadarQtRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RadarQt", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "radarQt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RadarQt", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RadarQtOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RadarQtOneWayWithContext(tafCtx context.Context, stReq *HRadarQtReq, stRsp *HRadarQtRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "radarQt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RadarChg is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RadarChg(stReq *HRadarChgReq, stRsp *HRadarChgRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "radarChg", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RadarChgWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RadarChgWithContext(tafCtx context.Context, stReq *HRadarChgReq, stRsp *HRadarChgRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RadarChg", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "radarChg", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "RadarChg", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//RadarChgOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) RadarChgOneWayWithContext(tafCtx context.Context, stReq *HRadarChgReq, stRsp *HRadarChgRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "radarChg", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//PriceAmount is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) PriceAmount(stReq *HPriceAmountReq, stRsp *HPriceAmountRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "priceAmount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//PriceAmountWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) PriceAmountWithContext(tafCtx context.Context, stReq *HPriceAmountReq, stRsp *HPriceAmountRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "PriceAmount", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "priceAmount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "PriceAmount", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//PriceAmountOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) PriceAmountOneWayWithContext(tafCtx context.Context, stReq *HPriceAmountReq, stRsp *HPriceAmountRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "priceAmount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Orderbook is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Orderbook(stReq *HOrderBookReq, stRsp *HOrderBookRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "orderbook", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderbookWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderbookWithContext(tafCtx context.Context, stReq *HOrderBookReq, stRsp *HOrderBookRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Orderbook", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "orderbook", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Orderbook", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderbookOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderbookOneWayWithContext(tafCtx context.Context, stReq *HOrderBookReq, stRsp *HOrderBookRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "orderbook", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderClassify is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderClassify(stReq *HOrderClassifyReq, stRsp *HOrderClassifyRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "orderClassify", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderClassifyWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderClassifyWithContext(tafCtx context.Context, stReq *HOrderClassifyReq, stRsp *HOrderClassifyRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OrderClassify", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "orderClassify", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "OrderClassify", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//OrderClassifyOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) OrderClassifyOneWayWithContext(tafCtx context.Context, stReq *HOrderClassifyReq, stRsp *HOrderClassifyRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "orderClassify", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2PankouRadio is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2PankouRadio(stReq *HPankouRadioReq, stRsp *HPankouRadioRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "l2PankouRadio", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2PankouRadioWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2PankouRadioWithContext(tafCtx context.Context, stReq *HPankouRadioReq, stRsp *HPankouRadioRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2PankouRadio", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "l2PankouRadio", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2PankouRadio", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2PankouRadioOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2PankouRadioOneWayWithContext(tafCtx context.Context, stReq *HPankouRadioReq, stRsp *HPankouRadioRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "l2PankouRadio", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2Synt is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2Synt(stReq *HSyntReq, stRsp *HSyntRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "L2Synt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2SyntWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2SyntWithContext(tafCtx context.Context, stReq *HSyntReq, stRsp *HSyntRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2Synt", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "L2Synt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "L2Synt", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//L2SyntOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) L2SyntOneWayWithContext(tafCtx context.Context, stReq *HSyntReq, stRsp *HSyntRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "L2Synt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HkWarrant is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HkWarrant(stReq *HHkWarrantReq, stRsp *HHkWarrantRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "hkWarrant", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HkWarrantWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HkWarrantWithContext(tafCtx context.Context, stReq *HHkWarrantReq, stRsp *HHkWarrantRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HkWarrant", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "hkWarrant", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "HkWarrant", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//HkWarrantOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) HkWarrantOneWayWithContext(tafCtx context.Context, stReq *HHkWarrantReq, stRsp *HHkWarrantRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "hkWarrant", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ServerInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) ServerInfo(stReq *HServerInfoReq, stRsp *HServerInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "serverInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ServerInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) ServerInfoWithContext(tafCtx context.Context, stReq *HServerInfoReq, stRsp *HServerInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "ServerInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "serverInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "ServerInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//ServerInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) ServerInfoOneWayWithContext(tafCtx context.Context, stReq *HServerInfoReq, stRsp *HServerInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "serverInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CheckUserPermission is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) CheckUserPermission(stReq *HUserPermissionReq, stRsp *HUserPermissionRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "checkUserPermission", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CheckUserPermissionWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) CheckUserPermissionWithContext(tafCtx context.Context, stReq *HUserPermissionReq, stRsp *HUserPermissionRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "CheckUserPermission", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "checkUserPermission", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "CheckUserPermission", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//CheckUserPermissionOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) CheckUserPermissionOneWayWithContext(tafCtx context.Context, stReq *HUserPermissionReq, stRsp *HUserPermissionRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "checkUserPermission", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//WarrantHk is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) WarrantHk(stReq *HWarrantHkReq, stRsp *HWarrantHkRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "warrantHk", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//WarrantHkWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) WarrantHkWithContext(tafCtx context.Context, stReq *HWarrantHkReq, stRsp *HWarrantHkRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "WarrantHk", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "warrantHk", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "WarrantHk", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//WarrantHkOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) WarrantHkOneWayWithContext(tafCtx context.Context, stReq *HWarrantHkReq, stRsp *HWarrantHkRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "warrantHk", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//VolPrice is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) VolPrice(stReq *HVolPriceReq, stRsp *HVolPriceRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "volPrice", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//VolPriceWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) VolPriceWithContext(tafCtx context.Context, stReq *HVolPriceReq, stRsp *HVolPriceRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "VolPrice", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "volPrice", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "VolPrice", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//VolPriceOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) VolPriceOneWayWithContext(tafCtx context.Context, stReq *HVolPriceReq, stRsp *HVolPriceRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "volPrice", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AllOrderPersp is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) AllOrderPersp(stReq *HAllOrderPerspReq, stRsp *HAllOrderPerspRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "allOrderPersp", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AllOrderPerspWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) AllOrderPerspWithContext(tafCtx context.Context, stReq *HAllOrderPerspReq, stRsp *HAllOrderPerspRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "AllOrderPersp", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "allOrderPersp", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "AllOrderPersp", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//AllOrderPerspOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) AllOrderPerspOneWayWithContext(tafCtx context.Context, stReq *HAllOrderPerspReq, stRsp *HAllOrderPerspRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "allOrderPersp", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMonitorInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetMonitorInfo(stReq *GetMonitorInfoReq, stRsp *GetMonitorInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getMonitorInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMonitorInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetMonitorInfoWithContext(tafCtx context.Context, stReq *GetMonitorInfoReq, stRsp *GetMonitorInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetMonitorInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getMonitorInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetMonitorInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMonitorInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetMonitorInfoOneWayWithContext(tafCtx context.Context, stReq *GetMonitorInfoReq, stRsp *GetMonitorInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getMonitorInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMarketTradeCale is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetMarketTradeCale(stReq *GetMarketTradeCaleReq, stRsp *GetMarketTradeCaleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getMarketTradeCale", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMarketTradeCaleWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetMarketTradeCaleWithContext(tafCtx context.Context, stReq *GetMarketTradeCaleReq, stRsp *GetMarketTradeCaleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetMarketTradeCale", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getMarketTradeCale", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetMarketTradeCale", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetMarketTradeCaleOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetMarketTradeCaleOneWayWithContext(tafCtx context.Context, stReq *GetMarketTradeCaleReq, stRsp *GetMarketTradeCaleRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getMarketTradeCale", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSysMonitorInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSysMonitorInfo(stReq *HSysMonitorReq, stRsp *HSysMonitorRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSysMonitorInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSysMonitorInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSysMonitorInfoWithContext(tafCtx context.Context, stReq *HSysMonitorReq, stRsp *HSysMonitorRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSysMonitorInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSysMonitorInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSysMonitorInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSysMonitorInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSysMonitorInfoOneWayWithContext(tafCtx context.Context, stReq *HSysMonitorReq, stRsp *HSysMonitorRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getSysMonitorInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGuidSet is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGuidSet(stReq *HGetGuidReq, stRsp *HGetGuidRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getGuidSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGuidSetWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGuidSetWithContext(tafCtx context.Context, stReq *HGetGuidReq, stRsp *HGetGuidRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetGuidSet", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getGuidSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetGuidSet", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGuidSetOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGuidSetOneWayWithContext(tafCtx context.Context, stReq *HGetGuidReq, stRsp *HGetGuidRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getGuidSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNInfo is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNInfo(stReq *HGetSNInfoReq, stRsp *HGetSNInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSNInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNInfoWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNInfoWithContext(tafCtx context.Context, stReq *HGetSNInfoReq, stRsp *HGetSNInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSNInfo", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSNInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSNInfo", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNInfoOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNInfoOneWayWithContext(tafCtx context.Context, stReq *HGetSNInfoReq, stRsp *HGetSNInfoRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getSNInfo", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGGTQXData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGGTQXData(stReq *HGGTQXReq, stRsp *HGGTQXRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getGGTQXData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGGTQXDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGGTQXDataWithContext(tafCtx context.Context, stReq *HGGTQXReq, stRsp *HGGTQXRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetGGTQXData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getGGTQXData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetGGTQXData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGGTQXDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGGTQXDataOneWayWithContext(tafCtx context.Context, stReq *HGGTQXReq, stRsp *HGGTQXRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getGGTQXData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGGTRate is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGGTRate(stReq *HGGTRateReq, stRsp *HGGTRateRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getGGTRate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGGTRateWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGGTRateWithContext(tafCtx context.Context, stReq *HGGTRateReq, stRsp *HGGTRateRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetGGTRate", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getGGTRate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetGGTRate", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetGGTRateOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetGGTRateOneWayWithContext(tafCtx context.Context, stReq *HGGTRateReq, stRsp *HGGTRateRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getGGTRate", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetYYData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetYYData(stReq *HYYDataReq, stRsp *HYYDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getYYData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetYYDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetYYDataWithContext(tafCtx context.Context, stReq *HYYDataReq, stRsp *HYYDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetYYData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getYYData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetYYData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetYYDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetYYDataOneWayWithContext(tafCtx context.Context, stReq *HYYDataReq, stRsp *HYYDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getYYData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFXData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFXData(stReq *HFXDataReq, stRsp *HFXDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getFXData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFXDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFXDataWithContext(tafCtx context.Context, stReq *HFXDataReq, stRsp *HFXDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetFXData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getFXData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetFXData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFXDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFXDataOneWayWithContext(tafCtx context.Context, stReq *HFXDataReq, stRsp *HFXDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getFXData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSouthMoneyFlow is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSouthMoneyFlow(stReq *GetSouthMoneyFlowReq, stRsp *GetSouthMoneyFlowRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSouthMoneyFlow", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSouthMoneyFlowWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSouthMoneyFlowWithContext(tafCtx context.Context, stReq *GetSouthMoneyFlowReq, stRsp *GetSouthMoneyFlowRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSouthMoneyFlow", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSouthMoneyFlow", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSouthMoneyFlow", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSouthMoneyFlowOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSouthMoneyFlowOneWayWithContext(tafCtx context.Context, stReq *GetSouthMoneyFlowReq, stRsp *GetSouthMoneyFlowRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getSouthMoneyFlow", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFutureNameList is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFutureNameList(stReq *HFutureNameListReq, stRsp *HFutureNameListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getFutureNameList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFutureNameListWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFutureNameListWithContext(tafCtx context.Context, stReq *HFutureNameListReq, stRsp *HFutureNameListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetFutureNameList", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getFutureNameList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetFutureNameList", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetFutureNameListOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetFutureNameListOneWayWithContext(tafCtx context.Context, stReq *HFutureNameListReq, stRsp *HFutureNameListRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getFutureNameList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetRtminAuction is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetRtminAuction(stReq *HRtminAuctionReq, stRsp *HRtminAuctionRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getRtminAuction", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetRtminAuctionWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetRtminAuctionWithContext(tafCtx context.Context, stReq *HRtminAuctionReq, stRsp *HRtminAuctionRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetRtminAuction", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getRtminAuction", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetRtminAuction", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetRtminAuctionOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetRtminAuctionOneWayWithContext(tafCtx context.Context, stReq *HRtminAuctionReq, stRsp *HRtminAuctionRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getRtminAuction", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNFundsData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNFundsData(stReq *HSNFundDataReq, stRsp *HSNFundDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSNFundsData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNFundsDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNFundsDataWithContext(tafCtx context.Context, stReq *HSNFundDataReq, stRsp *HSNFundDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSNFundsData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSNFundsData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSNFundsData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNFundsDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNFundsDataOneWayWithContext(tafCtx context.Context, stReq *HSNFundDataReq, stRsp *HSNFundDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getSNFundsData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNNetData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNNetData(stReq *HSNNetDataReq, stRsp *HSNNetDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSNNetData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNNetDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNNetDataWithContext(tafCtx context.Context, stReq *HSNNetDataReq, stRsp *HSNNetDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSNNetData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getSNNetData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetSNNetData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetSNNetDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetSNNetDataOneWayWithContext(tafCtx context.Context, stReq *HSNNetDataReq, stRsp *HSNNetDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getSNNetData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetHisSNNetData is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetHisSNNetData(stReq *HHisSNNetDataReq, stRsp *HHisSNNetDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getHisSNNetData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetHisSNNetDataWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetHisSNNetDataWithContext(tafCtx context.Context, stReq *HHisSNNetDataReq, stRsp *HHisSNNetDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetHisSNNetData", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getHisSNNetData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetHisSNNetData", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetHisSNNetDataOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetHisSNNetDataOneWayWithContext(tafCtx context.Context, stReq *HHisSNNetDataReq, stRsp *HHisSNNetDataRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getHisSNNetData", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//Jpjl is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) Jpjl(stReq *HJPJLReq, stRsp *HJPJLRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "jpjl", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//JpjlWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) JpjlWithContext(tafCtx context.Context, stReq *HJPJLReq, stRsp *HJPJLRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Jpjl", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "jpjl", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "Jpjl", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//JpjlOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) JpjlOneWayWithContext(tafCtx context.Context, stReq *HJPJLReq, stRsp *HJPJLRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "jpjl", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockRank is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockRank(stReq *HStockRankReq, stRsp *HStockRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockRankWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockRankWithContext(tafCtx context.Context, stReq *HStockRankReq, stRsp *HStockRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockRank", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "stockRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "StockRank", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//StockRankOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) StockRankOneWayWithContext(tafCtx context.Context, stReq *HStockRankReq, stRsp *HStockRankRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "stockRank", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetXrdFactor is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetXrdFactor(stReq *HXrdFactorReq, stRsp *HXrdFactorRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getXrdFactor", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetXrdFactorWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetXrdFactorWithContext(tafCtx context.Context, stReq *HXrdFactorReq, stRsp *HXrdFactorRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetXrdFactor", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getXrdFactor", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetXrdFactor", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetXrdFactorOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetXrdFactorOneWayWithContext(tafCtx context.Context, stReq *HXrdFactorReq, stRsp *HXrdFactorRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getXrdFactor", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetZDFenBu is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetZDFenBu(stReq *HZDFenbuReq, stRsp *HZDFenbuRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getZDFenBu", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetZDFenBuWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetZDFenBuWithContext(tafCtx context.Context, stReq *HZDFenbuReq, stRsp *HZDFenbuRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetZDFenBu", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getZDFenBu", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetZDFenBu", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetZDFenBuOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetZDFenBuOneWayWithContext(tafCtx context.Context, stReq *HZDFenbuReq, stRsp *HZDFenbuRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getZDFenBu", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetTradeStatusName is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetTradeStatusName(stReq *HTradeStatusNameReq, stRsp *HTradeStatusNameRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)
	tafCtx := context.Background()

	err = _obj.s.Taf_invoke(tafCtx, 0, "getTradeStatusName", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetTradeStatusNameWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetTradeStatusNameWithContext(tafCtx context.Context, stReq *HTradeStatusNameReq, stRsp *HTradeStatusNameRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(tafCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(_os.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["stReq"] = stReq
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetTradeStatusName", 0, traceParam, "")
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 0, "getTradeStatusName", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	_is := codec.NewReader(tools.Int8ToByte(_resp.SBuffer))
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).ReadBlock(_is, 2, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(_is.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["taf_ret"] = ret
			value["stRsp"] = *stRsp
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		taf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, taf.GetClientConfig().ModuleName, _obj.s.Name(), "GetTradeStatusName", int(_resp.IRet), traceParam, "")
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//GetTradeStatusNameOneWayWithContext is the proxy function for the method defined in the jce file, with the context
func (_obj *BasicHq) GetTradeStatusNameOneWayWithContext(tafCtx context.Context, stReq *HTradeStatusNameReq, stRsp *HTradeStatusNameRsp, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = stReq.WriteBlock(_os, 1)
	if err != nil {
		return ret, err
	}

	err = (*stRsp).WriteBlock(_os, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	if len(_opt) == 1 {
		_context = _opt[0]
	} else if len(_opt) == 2 {
		_context = _opt[0]
		_status = _opt[1]
	}
	_resp := new(requestf.BasePacket)

	err = _obj.s.Taf_invoke(tafCtx, 1, "getTradeStatusName", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}

	if len(_opt) == 1 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
	} else if len(_opt) == 2 {
		for k := range _context {
			delete(_context, k)
		}
		for k, v := range _resp.Context {
			_context[k] = v
		}
		for k := range _status {
			delete(_status, k)
		}
		for k, v := range _resp.Status {
			_status[k] = v
		}

	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

//SetServant sets servant for the service.
func (_obj *BasicHq) SetServant(s m.Servant) {
	_obj.s = s
}

//TafSetTimeout sets the timeout for the servant which is in ms.
func (_obj *BasicHq) TafSetTimeout(t int) {
	_obj.s.TafSetTimeout(t)
}

//TafSetProtocol sets the protocol for the servant.
func (_obj *BasicHq) TafSetProtocol(p m.Protocol) {
	_obj.s.TafSetProtocol(p)
}

//AddServant adds servant  for the service.
func (_obj *BasicHq) AddServant(imp _impBasicHq, obj string) {
	taf.AddServant(_obj, imp, obj)
}

//AddServantWithContext adds servant  for the service with context.
func (_obj *BasicHq) AddServantWithContext(imp _impBasicHqWithContext, obj string) {
	taf.AddServantWithContext(_obj, imp, obj)
}

type _impBasicHq interface {
	HeartBeat(stReq *HProxyHeartReq) (ret int32, err error)
	GetQXInfo(stReq *HQXInfoReq, stRsp *HQXInfoRsp) (ret int32, err error)
	GetCWData(stReq *HCWDataReq, stRsp *HCWDataRsp) (ret int32, err error)
	GetCWVer(stReq *HCWVerReq, stRsp *HCWVerRsp) (ret int32, err error)
	GetLTGChg(stReq *HLTGChgReq, stRsp *HLTGChgRsp) (ret int32, err error)
	GetFile(stReq *HFileReq, stRsp *HFileRsp) (ret int32, err error)
	GetFileBatch(stReq *HFileBatchReq, stRsp *HFileBatchRsp) (ret int32, err error)
	StockBaseInfo(stReq *HStockBaseInfoReq, stRsp *HStockBaseInfoRsp) (ret int32, err error)
	StockBaseInfoSimple(stReq *HStockBaseInfoSimpleReq, stRsp *HStockBaseInfoSimpleRsp) (ret int32, err error)
	StockStaticInfo(stReq *HStockBaseInfoReq, stRsp *HStockStaticInfoRsp) (ret int32, err error)
	MarketBaseInfo(stReq *HMarketBaseInfoReq, stRsp *HMarketBaseInfoRsp) (ret int32, err error)
	UserLogin(stReq *HUserLoginReq, stRsp *HUserLoginRsp) (ret int32, err error)
	UserSimpleLogin(stReq *HUserSimpleLoginReq, stRsp *HUserSimpleLoginRsp) (ret int32, err error)
	StockDict(stReq *HStockDictReq, stRsp *HStockDictRsp) (ret int32, err error)
	StockDictSimple(stReq *HStockDictSimpleReq, stRsp *HStockDictSimpleRsp) (ret int32, err error)
	StockBaseBatch(stReq *HStockBaseBatchReq, stRsp *HStockBaseBatchRsp) (ret int32, err error)
	GetCQCX(stReq *HCQCXReq, stRsp *HCQCXRsp) (ret int32, err error)
	GetTradePeriod(stReq *HTradePeriodReq, stRsp *HTradePeriodRsp) (ret int32, err error)
	GetPeriod(stReq *HPeriodReq, stRsp *HPeriodRsp) (ret int32, err error)
	GetInterval(stReq *HIntervalReq, stRsp *HIntervalRsp) (ret int32, err error)
	ZhRank(stReq *HZHRankReq, stRsp *HZHRankRsp) (ret int32, err error)
	MfRankSimp(stReq *HMFRankSimReq, stRsp *HMFRankSimpRsp) (ret int32, err error)
	BkLed(stReq *HBKLedReq, stRsp *HBKLedRsp) (ret int32, err error)
	OptionBaseInfo(stReq *HOptionBaseInfoReq, stRsp *HOptionBaseInfoRsp) (ret int32, err error)
	OptionUnderlyingDict(stReq *HOptionUnderlyingDictReq, stRsp *HOptionUnderlyingDictRsp) (ret int32, err error)
	OptionStock(stReq *HOptionStockReq, stRsp *HOptionStockRsp) (ret int32, err error)
	EtfInfo(stReq *HEtfInfoReq, stRsp *HEtfInfoRsp) (ret int32, err error)
	StockHq(stReq *HStockHqReq, stRsp *HStockHqRsp) (ret int32, err error)
	Qt(stReq *HStockHqReq, stRsp *HStockHqRsp) (ret int32, err error)
	StockHqSimple(stReq *HStockHqSimpleReq, stRsp *HStockHqSimpleRsp) (ret int32, err error)
	OptStockHqEx(stReq *OptStockHqExReq, stRsp *OptStockHqExRsp) (ret int32, err error)
	OptStockHq(stReq *HOptStockHqReq, stRsp *HOptStockHqRsp) (ret int32, err error)
	RtMinData(stReq *HRTMinDataReq, stRsp *HRTMinDataRsp) (ret int32, err error)
	RtMinDataSimple(stReq *HRTMinDataSimpleReq, stRsp *HRTMinDataSimpleRsp) (ret int32, err error)
	HisRtMinute(stReq *HHisMinuteReq, stRsp *HHisMinuteRsp) (ret int32, err error)
	HisRtMinuteSimple(stReq *HHisMinuteSimpleReq, stRsp *HHisMinuteSimpleRsp) (ret int32, err error)
	HisMinBatch(stReq *HHisMinBatchReq, stRsp *HHisMinBatchRsp) (ret int32, err error)
	HisMinBatchSimple(stReq *HHisMinBatchSimpleReq, stRsp *HHisMinBatchSimpleRsp) (ret int32, err error)
	TickData(stReq *HTickDataReq, stRsp *HTickDataRsp) (ret int32, err error)
	HisTick(stReq *HHisTickReq, stRsp *HHisTickRsp) (ret int32, err error)
	StockMFlow(stReq *HStockMFlowReq, stRsp *HStockMFlowRsp) (ret int32, err error)
	StockMFlowBatch(stReq *HStockMFlowBatchReq, stRsp *HStockMFlowBatchRsp) (ret int32, err error)
	StockMFlowByDay(stReq *HMFlowByDayReq, stRsp *HMFlowByDayRsp) (ret int32, err error)
	MfByTrade(stReq *HMFByTradeReq, stRsp *HMFByTradeRsp) (ret int32, err error)
	StockMFlowData(stReq *HStockMFlowDataReq, stRsp *HStockMFlowDataRsp) (ret int32, err error)
	StockBatchMFlowData(stReq *HStockBatchMFlowDataReq, stRsp *HStockBatchMFlowDataRsp) (ret int32, err error)
	KLineData(stReq *HKLineDataReq, stRsp *HKLineDataRsp) (ret int32, err error)
	KLineDataSimple(stReq *HKLineDataSimpleReq, stRsp *HKLineDataSimpleRsp) (ret int32, err error)
	RegKLine(stReq *HRegKLineReq, stRsp *HRegKLineRsp) (ret int32, err error)
	RegKLineSimple(stReq *HRegKLineSimpleReq, stRsp *HRegKLineSimpleRsp) (ret int32, err error)
	KLineDataByPeriod(stReq *HKLineDataByPeriodReq, stRsp *HKLineDataByPeriodRsp) (ret int32, err error)
	KLineDataByPeriodSimple(stReq *HKLineDataByPeriodSimpleReq, stRsp *HKLineDataByPeriodSimpleRsp) (ret int32, err error)
	StockKLineData(stReq *HStockKLineReq, stRsp *HStockKLineRsp) (ret int32, err error)
	MfRank(stReq *HMFlowRankReq, stRsp *HMFlowRankRsp) (ret int32, err error)
	StockDDERank(stReq *HDDERankReq, stRsp *HDDERankRsp) (ret int32, err error)
	StockDDEBatch(stReq *HStockDDEBatchReq, stRsp *HStockDDEBatchRsp) (ret int32, err error)
	Dxjl(stReq *HDxjlReq, stRsp *HDxjlRsp) (ret int32, err error)
	L2Monit(stReq *HL2MonitReq, stRsp *HL2MonitRsp) (ret int32, err error)
	L2Szfy(stReq *HLV2SZFYReq, stRsp *HLV2SZFYRsp) (ret int32, err error)
	L2SzfyCom(stReq *HSZFYComReq, stRsp *HSZFYComRsp) (ret int32, err error)
	StockAHList(stReq *HStockAHListReq, stRsp *HStockAHListRsp) (ret int32, err error)
	StockAH(stReq *HStockAHReq, stRsp *HStockAHRsp) (ret int32, err error)
	StockAHBatch(stReq *HStockAHReq, stRsp *HStockAHBatchRsp) (ret int32, err error)
	StockDDZ(stReq *HStockDDZReq, stRsp *HStockDDZRsp) (ret int32, err error)
	BrokerQueue(stReq *HBrokerQueueReq, stRsp *HBrokerQueueRsp) (ret int32, err error)
	RegStatus(stReq *HRegStatusReq, stRsp *HRegStatusRsp) (ret int32, err error)
	SetCltInfo(stReq *HCltInfoReq, stRsp *HCltInfoRsp) (ret int32, err error)
	GetNewStockPerform(stReq *HNewStockPerformReq, stRsp *HNewStockPerformRsp) (ret int32, err error)
	GetNewStockPerformByStock(stReq *HNewStockPerformByStockReq, stRsp *HNewStockPerformRsp) (ret int32, err error)
	RangeStats(stReq *HRangeStatsReq, stRsp *HRangeStatsRsp) (ret int32, err error)
	HotPlateHq(stReq *HHotPlateReq, stRsp *HHotPlateRsp) (ret int32, err error)
	Type2Stock(stReq *HType2StockReq, stRsp *HType2StockRsp) (ret int32, err error)
	TypeList(stReq *HType2StockReq, stRsp *HType2StockRsp) (ret int32, err error)
	TypeListSimple(stReq *HTypeListSimpleReq, stRsp *HType2StockSimpleRsp) (ret int32, err error)
	Type2StockSimple(stReq *HType2StockSimpleReq, stRsp *HType2StockRsp) (ret int32, err error)
	BusList(stReq *HType2StockSimpleReq, stRsp *HType2StockRsp) (ret int32, err error)
	BusListSimple(stReq *HBusListSimpleReq, stRsp *HType2StockSimpleRsp) (ret int32, err error)
	Block2Stock(stReq *HBlock2StockReq, stRsp *HBlock2StockRsp) (ret int32, err error)
	BlockList(stReq *HBlock2StockReq, stRsp *HBlock2StockRsp) (ret int32, err error)
	BlockListSimple(stReq *HBlock2StockSimpleReq, stRsp *HBlock2StockSimpleRsp) (ret int32, err error)
	BlockTsLevel(stReq *HTsBlockLevelReq, stRsp *HTsBlockLevelRsp) (ret int32, err error)
	CustomType2Stock(stReq *HCustomType2StockReq, stRsp *HType2StockRsp) (ret int32, err error)
	SortList(stReq *HSortListReq, stRsp *HSortListRsp) (ret int32, err error)
	Stock2Block(stReq *HStock2BlockReq, stRsp *HStock2BlockRsp) (ret int32, err error)
	Stock2Industry(stReq *HStock2IndustryReq, stRsp *HStock2IndustryRsp) (ret int32, err error)
	RegCPTMin(stReq *HRegCPTMinReq, stRsp *HRegCPTMinRsp) (ret int32, err error)
	RegMarketInit(stReq *HRegMarketInitReq, stRsp *HRegMarketInitRsp) (ret int32, err error)
	RegCodes(stReq *HRegCodesReq, stRsp *HRegCodesRsp) (ret int32, err error)
	OrderQueue(stReq *HOrderQueueReq, stRsp *HOrderQueueRsp) (ret int32, err error)
	TransData(stReq *HTransDataReq, stRsp *HTransDataRsp) (ret int32, err error)
	OrderRec(stReq *HOrderRecReq, stRsp *HOrderRecRsp) (ret int32, err error)
	PriceOrder(stReq *HPriceOrderReq, stRsp *HPriceOrderRsp) (ret int32, err error)
	RadarQt(stReq *HRadarQtReq, stRsp *HRadarQtRsp) (ret int32, err error)
	RadarChg(stReq *HRadarChgReq, stRsp *HRadarChgRsp) (ret int32, err error)
	PriceAmount(stReq *HPriceAmountReq, stRsp *HPriceAmountRsp) (ret int32, err error)
	Orderbook(stReq *HOrderBookReq, stRsp *HOrderBookRsp) (ret int32, err error)
	OrderClassify(stReq *HOrderClassifyReq, stRsp *HOrderClassifyRsp) (ret int32, err error)
	L2PankouRadio(stReq *HPankouRadioReq, stRsp *HPankouRadioRsp) (ret int32, err error)
	L2Synt(stReq *HSyntReq, stRsp *HSyntRsp) (ret int32, err error)
	HkWarrant(stReq *HHkWarrantReq, stRsp *HHkWarrantRsp) (ret int32, err error)
	ServerInfo(stReq *HServerInfoReq, stRsp *HServerInfoRsp) (ret int32, err error)
	CheckUserPermission(stReq *HUserPermissionReq, stRsp *HUserPermissionRsp) (ret int32, err error)
	WarrantHk(stReq *HWarrantHkReq, stRsp *HWarrantHkRsp) (ret int32, err error)
	VolPrice(stReq *HVolPriceReq, stRsp *HVolPriceRsp) (ret int32, err error)
	AllOrderPersp(stReq *HAllOrderPerspReq, stRsp *HAllOrderPerspRsp) (ret int32, err error)
	GetMonitorInfo(stReq *GetMonitorInfoReq, stRsp *GetMonitorInfoRsp) (ret int32, err error)
	GetMarketTradeCale(stReq *GetMarketTradeCaleReq, stRsp *GetMarketTradeCaleRsp) (ret int32, err error)
	GetSysMonitorInfo(stReq *HSysMonitorReq, stRsp *HSysMonitorRsp) (ret int32, err error)
	GetGuidSet(stReq *HGetGuidReq, stRsp *HGetGuidRsp) (ret int32, err error)
	GetSNInfo(stReq *HGetSNInfoReq, stRsp *HGetSNInfoRsp) (ret int32, err error)
	GetGGTQXData(stReq *HGGTQXReq, stRsp *HGGTQXRsp) (ret int32, err error)
	GetGGTRate(stReq *HGGTRateReq, stRsp *HGGTRateRsp) (ret int32, err error)
	GetYYData(stReq *HYYDataReq, stRsp *HYYDataRsp) (ret int32, err error)
	GetFXData(stReq *HFXDataReq, stRsp *HFXDataRsp) (ret int32, err error)
	GetSouthMoneyFlow(stReq *GetSouthMoneyFlowReq, stRsp *GetSouthMoneyFlowRsp) (ret int32, err error)
	GetFutureNameList(stReq *HFutureNameListReq, stRsp *HFutureNameListRsp) (ret int32, err error)
	GetRtminAuction(stReq *HRtminAuctionReq, stRsp *HRtminAuctionRsp) (ret int32, err error)
	GetSNFundsData(stReq *HSNFundDataReq, stRsp *HSNFundDataRsp) (ret int32, err error)
	GetSNNetData(stReq *HSNNetDataReq, stRsp *HSNNetDataRsp) (ret int32, err error)
	GetHisSNNetData(stReq *HHisSNNetDataReq, stRsp *HHisSNNetDataRsp) (ret int32, err error)
	Jpjl(stReq *HJPJLReq, stRsp *HJPJLRsp) (ret int32, err error)
	StockRank(stReq *HStockRankReq, stRsp *HStockRankRsp) (ret int32, err error)
	GetXrdFactor(stReq *HXrdFactorReq, stRsp *HXrdFactorRsp) (ret int32, err error)
	GetZDFenBu(stReq *HZDFenbuReq, stRsp *HZDFenbuRsp) (ret int32, err error)
	GetTradeStatusName(stReq *HTradeStatusNameReq, stRsp *HTradeStatusNameRsp) (ret int32, err error)
}
type _impBasicHqWithContext interface {
	HeartBeat(tafCtx context.Context, stReq *HProxyHeartReq) (ret int32, err error)
	GetQXInfo(tafCtx context.Context, stReq *HQXInfoReq, stRsp *HQXInfoRsp) (ret int32, err error)
	GetCWData(tafCtx context.Context, stReq *HCWDataReq, stRsp *HCWDataRsp) (ret int32, err error)
	GetCWVer(tafCtx context.Context, stReq *HCWVerReq, stRsp *HCWVerRsp) (ret int32, err error)
	GetLTGChg(tafCtx context.Context, stReq *HLTGChgReq, stRsp *HLTGChgRsp) (ret int32, err error)
	GetFile(tafCtx context.Context, stReq *HFileReq, stRsp *HFileRsp) (ret int32, err error)
	GetFileBatch(tafCtx context.Context, stReq *HFileBatchReq, stRsp *HFileBatchRsp) (ret int32, err error)
	StockBaseInfo(tafCtx context.Context, stReq *HStockBaseInfoReq, stRsp *HStockBaseInfoRsp) (ret int32, err error)
	StockBaseInfoSimple(tafCtx context.Context, stReq *HStockBaseInfoSimpleReq, stRsp *HStockBaseInfoSimpleRsp) (ret int32, err error)
	StockStaticInfo(tafCtx context.Context, stReq *HStockBaseInfoReq, stRsp *HStockStaticInfoRsp) (ret int32, err error)
	MarketBaseInfo(tafCtx context.Context, stReq *HMarketBaseInfoReq, stRsp *HMarketBaseInfoRsp) (ret int32, err error)
	UserLogin(tafCtx context.Context, stReq *HUserLoginReq, stRsp *HUserLoginRsp) (ret int32, err error)
	UserSimpleLogin(tafCtx context.Context, stReq *HUserSimpleLoginReq, stRsp *HUserSimpleLoginRsp) (ret int32, err error)
	StockDict(tafCtx context.Context, stReq *HStockDictReq, stRsp *HStockDictRsp) (ret int32, err error)
	StockDictSimple(tafCtx context.Context, stReq *HStockDictSimpleReq, stRsp *HStockDictSimpleRsp) (ret int32, err error)
	StockBaseBatch(tafCtx context.Context, stReq *HStockBaseBatchReq, stRsp *HStockBaseBatchRsp) (ret int32, err error)
	GetCQCX(tafCtx context.Context, stReq *HCQCXReq, stRsp *HCQCXRsp) (ret int32, err error)
	GetTradePeriod(tafCtx context.Context, stReq *HTradePeriodReq, stRsp *HTradePeriodRsp) (ret int32, err error)
	GetPeriod(tafCtx context.Context, stReq *HPeriodReq, stRsp *HPeriodRsp) (ret int32, err error)
	GetInterval(tafCtx context.Context, stReq *HIntervalReq, stRsp *HIntervalRsp) (ret int32, err error)
	ZhRank(tafCtx context.Context, stReq *HZHRankReq, stRsp *HZHRankRsp) (ret int32, err error)
	MfRankSimp(tafCtx context.Context, stReq *HMFRankSimReq, stRsp *HMFRankSimpRsp) (ret int32, err error)
	BkLed(tafCtx context.Context, stReq *HBKLedReq, stRsp *HBKLedRsp) (ret int32, err error)
	OptionBaseInfo(tafCtx context.Context, stReq *HOptionBaseInfoReq, stRsp *HOptionBaseInfoRsp) (ret int32, err error)
	OptionUnderlyingDict(tafCtx context.Context, stReq *HOptionUnderlyingDictReq, stRsp *HOptionUnderlyingDictRsp) (ret int32, err error)
	OptionStock(tafCtx context.Context, stReq *HOptionStockReq, stRsp *HOptionStockRsp) (ret int32, err error)
	EtfInfo(tafCtx context.Context, stReq *HEtfInfoReq, stRsp *HEtfInfoRsp) (ret int32, err error)
	StockHq(tafCtx context.Context, stReq *HStockHqReq, stRsp *HStockHqRsp) (ret int32, err error)
	Qt(tafCtx context.Context, stReq *HStockHqReq, stRsp *HStockHqRsp) (ret int32, err error)
	StockHqSimple(tafCtx context.Context, stReq *HStockHqSimpleReq, stRsp *HStockHqSimpleRsp) (ret int32, err error)
	OptStockHqEx(tafCtx context.Context, stReq *OptStockHqExReq, stRsp *OptStockHqExRsp) (ret int32, err error)
	OptStockHq(tafCtx context.Context, stReq *HOptStockHqReq, stRsp *HOptStockHqRsp) (ret int32, err error)
	RtMinData(tafCtx context.Context, stReq *HRTMinDataReq, stRsp *HRTMinDataRsp) (ret int32, err error)
	RtMinDataSimple(tafCtx context.Context, stReq *HRTMinDataSimpleReq, stRsp *HRTMinDataSimpleRsp) (ret int32, err error)
	HisRtMinute(tafCtx context.Context, stReq *HHisMinuteReq, stRsp *HHisMinuteRsp) (ret int32, err error)
	HisRtMinuteSimple(tafCtx context.Context, stReq *HHisMinuteSimpleReq, stRsp *HHisMinuteSimpleRsp) (ret int32, err error)
	HisMinBatch(tafCtx context.Context, stReq *HHisMinBatchReq, stRsp *HHisMinBatchRsp) (ret int32, err error)
	HisMinBatchSimple(tafCtx context.Context, stReq *HHisMinBatchSimpleReq, stRsp *HHisMinBatchSimpleRsp) (ret int32, err error)
	TickData(tafCtx context.Context, stReq *HTickDataReq, stRsp *HTickDataRsp) (ret int32, err error)
	HisTick(tafCtx context.Context, stReq *HHisTickReq, stRsp *HHisTickRsp) (ret int32, err error)
	StockMFlow(tafCtx context.Context, stReq *HStockMFlowReq, stRsp *HStockMFlowRsp) (ret int32, err error)
	StockMFlowBatch(tafCtx context.Context, stReq *HStockMFlowBatchReq, stRsp *HStockMFlowBatchRsp) (ret int32, err error)
	StockMFlowByDay(tafCtx context.Context, stReq *HMFlowByDayReq, stRsp *HMFlowByDayRsp) (ret int32, err error)
	MfByTrade(tafCtx context.Context, stReq *HMFByTradeReq, stRsp *HMFByTradeRsp) (ret int32, err error)
	StockMFlowData(tafCtx context.Context, stReq *HStockMFlowDataReq, stRsp *HStockMFlowDataRsp) (ret int32, err error)
	StockBatchMFlowData(tafCtx context.Context, stReq *HStockBatchMFlowDataReq, stRsp *HStockBatchMFlowDataRsp) (ret int32, err error)
	KLineData(tafCtx context.Context, stReq *HKLineDataReq, stRsp *HKLineDataRsp) (ret int32, err error)
	KLineDataSimple(tafCtx context.Context, stReq *HKLineDataSimpleReq, stRsp *HKLineDataSimpleRsp) (ret int32, err error)
	RegKLine(tafCtx context.Context, stReq *HRegKLineReq, stRsp *HRegKLineRsp) (ret int32, err error)
	RegKLineSimple(tafCtx context.Context, stReq *HRegKLineSimpleReq, stRsp *HRegKLineSimpleRsp) (ret int32, err error)
	KLineDataByPeriod(tafCtx context.Context, stReq *HKLineDataByPeriodReq, stRsp *HKLineDataByPeriodRsp) (ret int32, err error)
	KLineDataByPeriodSimple(tafCtx context.Context, stReq *HKLineDataByPeriodSimpleReq, stRsp *HKLineDataByPeriodSimpleRsp) (ret int32, err error)
	StockKLineData(tafCtx context.Context, stReq *HStockKLineReq, stRsp *HStockKLineRsp) (ret int32, err error)
	MfRank(tafCtx context.Context, stReq *HMFlowRankReq, stRsp *HMFlowRankRsp) (ret int32, err error)
	StockDDERank(tafCtx context.Context, stReq *HDDERankReq, stRsp *HDDERankRsp) (ret int32, err error)
	StockDDEBatch(tafCtx context.Context, stReq *HStockDDEBatchReq, stRsp *HStockDDEBatchRsp) (ret int32, err error)
	Dxjl(tafCtx context.Context, stReq *HDxjlReq, stRsp *HDxjlRsp) (ret int32, err error)
	L2Monit(tafCtx context.Context, stReq *HL2MonitReq, stRsp *HL2MonitRsp) (ret int32, err error)
	L2Szfy(tafCtx context.Context, stReq *HLV2SZFYReq, stRsp *HLV2SZFYRsp) (ret int32, err error)
	L2SzfyCom(tafCtx context.Context, stReq *HSZFYComReq, stRsp *HSZFYComRsp) (ret int32, err error)
	StockAHList(tafCtx context.Context, stReq *HStockAHListReq, stRsp *HStockAHListRsp) (ret int32, err error)
	StockAH(tafCtx context.Context, stReq *HStockAHReq, stRsp *HStockAHRsp) (ret int32, err error)
	StockAHBatch(tafCtx context.Context, stReq *HStockAHReq, stRsp *HStockAHBatchRsp) (ret int32, err error)
	StockDDZ(tafCtx context.Context, stReq *HStockDDZReq, stRsp *HStockDDZRsp) (ret int32, err error)
	BrokerQueue(tafCtx context.Context, stReq *HBrokerQueueReq, stRsp *HBrokerQueueRsp) (ret int32, err error)
	RegStatus(tafCtx context.Context, stReq *HRegStatusReq, stRsp *HRegStatusRsp) (ret int32, err error)
	SetCltInfo(tafCtx context.Context, stReq *HCltInfoReq, stRsp *HCltInfoRsp) (ret int32, err error)
	GetNewStockPerform(tafCtx context.Context, stReq *HNewStockPerformReq, stRsp *HNewStockPerformRsp) (ret int32, err error)
	GetNewStockPerformByStock(tafCtx context.Context, stReq *HNewStockPerformByStockReq, stRsp *HNewStockPerformRsp) (ret int32, err error)
	RangeStats(tafCtx context.Context, stReq *HRangeStatsReq, stRsp *HRangeStatsRsp) (ret int32, err error)
	HotPlateHq(tafCtx context.Context, stReq *HHotPlateReq, stRsp *HHotPlateRsp) (ret int32, err error)
	Type2Stock(tafCtx context.Context, stReq *HType2StockReq, stRsp *HType2StockRsp) (ret int32, err error)
	TypeList(tafCtx context.Context, stReq *HType2StockReq, stRsp *HType2StockRsp) (ret int32, err error)
	TypeListSimple(tafCtx context.Context, stReq *HTypeListSimpleReq, stRsp *HType2StockSimpleRsp) (ret int32, err error)
	Type2StockSimple(tafCtx context.Context, stReq *HType2StockSimpleReq, stRsp *HType2StockRsp) (ret int32, err error)
	BusList(tafCtx context.Context, stReq *HType2StockSimpleReq, stRsp *HType2StockRsp) (ret int32, err error)
	BusListSimple(tafCtx context.Context, stReq *HBusListSimpleReq, stRsp *HType2StockSimpleRsp) (ret int32, err error)
	Block2Stock(tafCtx context.Context, stReq *HBlock2StockReq, stRsp *HBlock2StockRsp) (ret int32, err error)
	BlockList(tafCtx context.Context, stReq *HBlock2StockReq, stRsp *HBlock2StockRsp) (ret int32, err error)
	BlockListSimple(tafCtx context.Context, stReq *HBlock2StockSimpleReq, stRsp *HBlock2StockSimpleRsp) (ret int32, err error)
	BlockTsLevel(tafCtx context.Context, stReq *HTsBlockLevelReq, stRsp *HTsBlockLevelRsp) (ret int32, err error)
	CustomType2Stock(tafCtx context.Context, stReq *HCustomType2StockReq, stRsp *HType2StockRsp) (ret int32, err error)
	SortList(tafCtx context.Context, stReq *HSortListReq, stRsp *HSortListRsp) (ret int32, err error)
	Stock2Block(tafCtx context.Context, stReq *HStock2BlockReq, stRsp *HStock2BlockRsp) (ret int32, err error)
	Stock2Industry(tafCtx context.Context, stReq *HStock2IndustryReq, stRsp *HStock2IndustryRsp) (ret int32, err error)
	RegCPTMin(tafCtx context.Context, stReq *HRegCPTMinReq, stRsp *HRegCPTMinRsp) (ret int32, err error)
	RegMarketInit(tafCtx context.Context, stReq *HRegMarketInitReq, stRsp *HRegMarketInitRsp) (ret int32, err error)
	RegCodes(tafCtx context.Context, stReq *HRegCodesReq, stRsp *HRegCodesRsp) (ret int32, err error)
	OrderQueue(tafCtx context.Context, stReq *HOrderQueueReq, stRsp *HOrderQueueRsp) (ret int32, err error)
	TransData(tafCtx context.Context, stReq *HTransDataReq, stRsp *HTransDataRsp) (ret int32, err error)
	OrderRec(tafCtx context.Context, stReq *HOrderRecReq, stRsp *HOrderRecRsp) (ret int32, err error)
	PriceOrder(tafCtx context.Context, stReq *HPriceOrderReq, stRsp *HPriceOrderRsp) (ret int32, err error)
	RadarQt(tafCtx context.Context, stReq *HRadarQtReq, stRsp *HRadarQtRsp) (ret int32, err error)
	RadarChg(tafCtx context.Context, stReq *HRadarChgReq, stRsp *HRadarChgRsp) (ret int32, err error)
	PriceAmount(tafCtx context.Context, stReq *HPriceAmountReq, stRsp *HPriceAmountRsp) (ret int32, err error)
	Orderbook(tafCtx context.Context, stReq *HOrderBookReq, stRsp *HOrderBookRsp) (ret int32, err error)
	OrderClassify(tafCtx context.Context, stReq *HOrderClassifyReq, stRsp *HOrderClassifyRsp) (ret int32, err error)
	L2PankouRadio(tafCtx context.Context, stReq *HPankouRadioReq, stRsp *HPankouRadioRsp) (ret int32, err error)
	L2Synt(tafCtx context.Context, stReq *HSyntReq, stRsp *HSyntRsp) (ret int32, err error)
	HkWarrant(tafCtx context.Context, stReq *HHkWarrantReq, stRsp *HHkWarrantRsp) (ret int32, err error)
	ServerInfo(tafCtx context.Context, stReq *HServerInfoReq, stRsp *HServerInfoRsp) (ret int32, err error)
	CheckUserPermission(tafCtx context.Context, stReq *HUserPermissionReq, stRsp *HUserPermissionRsp) (ret int32, err error)
	WarrantHk(tafCtx context.Context, stReq *HWarrantHkReq, stRsp *HWarrantHkRsp) (ret int32, err error)
	VolPrice(tafCtx context.Context, stReq *HVolPriceReq, stRsp *HVolPriceRsp) (ret int32, err error)
	AllOrderPersp(tafCtx context.Context, stReq *HAllOrderPerspReq, stRsp *HAllOrderPerspRsp) (ret int32, err error)
	GetMonitorInfo(tafCtx context.Context, stReq *GetMonitorInfoReq, stRsp *GetMonitorInfoRsp) (ret int32, err error)
	GetMarketTradeCale(tafCtx context.Context, stReq *GetMarketTradeCaleReq, stRsp *GetMarketTradeCaleRsp) (ret int32, err error)
	GetSysMonitorInfo(tafCtx context.Context, stReq *HSysMonitorReq, stRsp *HSysMonitorRsp) (ret int32, err error)
	GetGuidSet(tafCtx context.Context, stReq *HGetGuidReq, stRsp *HGetGuidRsp) (ret int32, err error)
	GetSNInfo(tafCtx context.Context, stReq *HGetSNInfoReq, stRsp *HGetSNInfoRsp) (ret int32, err error)
	GetGGTQXData(tafCtx context.Context, stReq *HGGTQXReq, stRsp *HGGTQXRsp) (ret int32, err error)
	GetGGTRate(tafCtx context.Context, stReq *HGGTRateReq, stRsp *HGGTRateRsp) (ret int32, err error)
	GetYYData(tafCtx context.Context, stReq *HYYDataReq, stRsp *HYYDataRsp) (ret int32, err error)
	GetFXData(tafCtx context.Context, stReq *HFXDataReq, stRsp *HFXDataRsp) (ret int32, err error)
	GetSouthMoneyFlow(tafCtx context.Context, stReq *GetSouthMoneyFlowReq, stRsp *GetSouthMoneyFlowRsp) (ret int32, err error)
	GetFutureNameList(tafCtx context.Context, stReq *HFutureNameListReq, stRsp *HFutureNameListRsp) (ret int32, err error)
	GetRtminAuction(tafCtx context.Context, stReq *HRtminAuctionReq, stRsp *HRtminAuctionRsp) (ret int32, err error)
	GetSNFundsData(tafCtx context.Context, stReq *HSNFundDataReq, stRsp *HSNFundDataRsp) (ret int32, err error)
	GetSNNetData(tafCtx context.Context, stReq *HSNNetDataReq, stRsp *HSNNetDataRsp) (ret int32, err error)
	GetHisSNNetData(tafCtx context.Context, stReq *HHisSNNetDataReq, stRsp *HHisSNNetDataRsp) (ret int32, err error)
	Jpjl(tafCtx context.Context, stReq *HJPJLReq, stRsp *HJPJLRsp) (ret int32, err error)
	StockRank(tafCtx context.Context, stReq *HStockRankReq, stRsp *HStockRankRsp) (ret int32, err error)
	GetXrdFactor(tafCtx context.Context, stReq *HXrdFactorReq, stRsp *HXrdFactorRsp) (ret int32, err error)
	GetZDFenBu(tafCtx context.Context, stReq *HZDFenbuReq, stRsp *HZDFenbuRsp) (ret int32, err error)
	GetTradeStatusName(tafCtx context.Context, stReq *HTradeStatusNameReq, stRsp *HTradeStatusNameRsp) (ret int32, err error)
}

// Dispatch is used to call the server side implemnet for the method defined in the jce file. _withContext shows using context or not.
func (_obj *BasicHq) Dispatch(tafCtx context.Context, _val interface{}, tafReq *requestf.BasePacket, tafResp *requestf.BasePacket, _withContext bool) (err error) {
	var length int32
	var have bool
	var ty byte
	_is := codec.NewReader(tools.Int8ToByte(tafReq.SBuffer))
	_os := codec.NewBuffer()
	switch tafReq.SFuncName {
	case "heartBeat":
		var stReq HProxyHeartReq

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "heartBeat", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.HeartBeat(&stReq)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.HeartBeat(tafCtx, &stReq)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "heartBeat", 0, traceParam, "")
		}

	case "getQXInfo":
		var stReq HQXInfoReq
		var stRsp HQXInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getQXInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetQXInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetQXInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getQXInfo", 0, traceParam, "")
		}

	case "getCWData":
		var stReq HCWDataReq
		var stRsp HCWDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getCWData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetCWData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetCWData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getCWData", 0, traceParam, "")
		}

	case "getCWVer":
		var stReq HCWVerReq
		var stRsp HCWVerRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getCWVer", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetCWVer(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetCWVer(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getCWVer", 0, traceParam, "")
		}

	case "getLTGChg":
		var stReq HLTGChgReq
		var stRsp HLTGChgRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getLTGChg", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetLTGChg(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetLTGChg(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getLTGChg", 0, traceParam, "")
		}

	case "getFile":
		var stReq HFileReq
		var stRsp HFileRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getFile", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetFile(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetFile(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getFile", 0, traceParam, "")
		}

	case "getFileBatch":
		var stReq HFileBatchReq
		var stRsp HFileBatchRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getFileBatch", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetFileBatch(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetFileBatch(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getFileBatch", 0, traceParam, "")
		}

	case "stockBaseInfo":
		var stReq HStockBaseInfoReq
		var stRsp HStockBaseInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockBaseInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockBaseInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockBaseInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockBaseInfo", 0, traceParam, "")
		}

	case "stockBaseInfoSimple":
		var stReq HStockBaseInfoSimpleReq
		var stRsp HStockBaseInfoSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockBaseInfoSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockBaseInfoSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockBaseInfoSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockBaseInfoSimple", 0, traceParam, "")
		}

	case "stockStaticInfo":
		var stReq HStockBaseInfoReq
		var stRsp HStockStaticInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockStaticInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockStaticInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockStaticInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockStaticInfo", 0, traceParam, "")
		}

	case "marketBaseInfo":
		var stReq HMarketBaseInfoReq
		var stRsp HMarketBaseInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "marketBaseInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.MarketBaseInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.MarketBaseInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "marketBaseInfo", 0, traceParam, "")
		}

	case "userLogin":
		var stReq HUserLoginReq
		var stRsp HUserLoginRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "userLogin", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.UserLogin(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.UserLogin(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "userLogin", 0, traceParam, "")
		}

	case "userSimpleLogin":
		var stReq HUserSimpleLoginReq
		var stRsp HUserSimpleLoginRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "userSimpleLogin", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.UserSimpleLogin(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.UserSimpleLogin(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "userSimpleLogin", 0, traceParam, "")
		}

	case "stockDict":
		var stReq HStockDictReq
		var stRsp HStockDictRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDict", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockDict(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockDict(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDict", 0, traceParam, "")
		}

	case "stockDictSimple":
		var stReq HStockDictSimpleReq
		var stRsp HStockDictSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDictSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockDictSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockDictSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDictSimple", 0, traceParam, "")
		}

	case "stockBaseBatch":
		var stReq HStockBaseBatchReq
		var stRsp HStockBaseBatchRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockBaseBatch", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockBaseBatch(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockBaseBatch(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockBaseBatch", 0, traceParam, "")
		}

	case "getCQCX":
		var stReq HCQCXReq
		var stRsp HCQCXRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getCQCX", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetCQCX(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetCQCX(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getCQCX", 0, traceParam, "")
		}

	case "getTradePeriod":
		var stReq HTradePeriodReq
		var stRsp HTradePeriodRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getTradePeriod", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetTradePeriod(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetTradePeriod(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getTradePeriod", 0, traceParam, "")
		}

	case "getPeriod":
		var stReq HPeriodReq
		var stRsp HPeriodRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getPeriod", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetPeriod(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetPeriod(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getPeriod", 0, traceParam, "")
		}

	case "getInterval":
		var stReq HIntervalReq
		var stRsp HIntervalRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getInterval", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetInterval(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetInterval(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getInterval", 0, traceParam, "")
		}

	case "zhRank":
		var stReq HZHRankReq
		var stRsp HZHRankRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "zhRank", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.ZhRank(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.ZhRank(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "zhRank", 0, traceParam, "")
		}

	case "mfRankSimp":
		var stReq HMFRankSimReq
		var stRsp HMFRankSimpRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "mfRankSimp", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.MfRankSimp(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.MfRankSimp(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "mfRankSimp", 0, traceParam, "")
		}

	case "bkLed":
		var stReq HBKLedReq
		var stRsp HBKLedRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "bkLed", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.BkLed(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.BkLed(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "bkLed", 0, traceParam, "")
		}

	case "optionBaseInfo":
		var stReq HOptionBaseInfoReq
		var stRsp HOptionBaseInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optionBaseInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.OptionBaseInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.OptionBaseInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optionBaseInfo", 0, traceParam, "")
		}

	case "optionUnderlyingDict":
		var stReq HOptionUnderlyingDictReq
		var stRsp HOptionUnderlyingDictRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optionUnderlyingDict", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.OptionUnderlyingDict(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.OptionUnderlyingDict(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optionUnderlyingDict", 0, traceParam, "")
		}

	case "optionStock":
		var stReq HOptionStockReq
		var stRsp HOptionStockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optionStock", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.OptionStock(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.OptionStock(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optionStock", 0, traceParam, "")
		}

	case "etfInfo":
		var stReq HEtfInfoReq
		var stRsp HEtfInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "etfInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.EtfInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.EtfInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "etfInfo", 0, traceParam, "")
		}

	case "stockHq":
		var stReq HStockHqReq
		var stRsp HStockHqRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockHq", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockHq(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockHq(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockHq", 0, traceParam, "")
		}

	case "qt":
		var stReq HStockHqReq
		var stRsp HStockHqRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "qt", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Qt(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Qt(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "qt", 0, traceParam, "")
		}

	case "stockHqSimple":
		var stReq HStockHqSimpleReq
		var stRsp HStockHqSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockHqSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockHqSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockHqSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockHqSimple", 0, traceParam, "")
		}

	case "optStockHqEx":
		var stReq OptStockHqExReq
		var stRsp OptStockHqExRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optStockHqEx", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.OptStockHqEx(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.OptStockHqEx(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optStockHqEx", 0, traceParam, "")
		}

	case "optStockHq":
		var stReq HOptStockHqReq
		var stRsp HOptStockHqRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optStockHq", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.OptStockHq(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.OptStockHq(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "optStockHq", 0, traceParam, "")
		}

	case "rtMinData":
		var stReq HRTMinDataReq
		var stRsp HRTMinDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "rtMinData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RtMinData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RtMinData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "rtMinData", 0, traceParam, "")
		}

	case "rtMinDataSimple":
		var stReq HRTMinDataSimpleReq
		var stRsp HRTMinDataSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "rtMinDataSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RtMinDataSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RtMinDataSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "rtMinDataSimple", 0, traceParam, "")
		}

	case "hisRtMinute":
		var stReq HHisMinuteReq
		var stRsp HHisMinuteRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisRtMinute", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.HisRtMinute(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.HisRtMinute(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisRtMinute", 0, traceParam, "")
		}

	case "hisRtMinuteSimple":
		var stReq HHisMinuteSimpleReq
		var stRsp HHisMinuteSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisRtMinuteSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.HisRtMinuteSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.HisRtMinuteSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisRtMinuteSimple", 0, traceParam, "")
		}

	case "hisMinBatch":
		var stReq HHisMinBatchReq
		var stRsp HHisMinBatchRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisMinBatch", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.HisMinBatch(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.HisMinBatch(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisMinBatch", 0, traceParam, "")
		}

	case "hisMinBatchSimple":
		var stReq HHisMinBatchSimpleReq
		var stRsp HHisMinBatchSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisMinBatchSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.HisMinBatchSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.HisMinBatchSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisMinBatchSimple", 0, traceParam, "")
		}

	case "tickData":
		var stReq HTickDataReq
		var stRsp HTickDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "tickData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.TickData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.TickData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "tickData", 0, traceParam, "")
		}

	case "hisTick":
		var stReq HHisTickReq
		var stRsp HHisTickRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisTick", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.HisTick(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.HisTick(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hisTick", 0, traceParam, "")
		}

	case "stockMFlow":
		var stReq HStockMFlowReq
		var stRsp HStockMFlowRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockMFlow", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockMFlow(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockMFlow(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockMFlow", 0, traceParam, "")
		}

	case "stockMFlowBatch":
		var stReq HStockMFlowBatchReq
		var stRsp HStockMFlowBatchRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockMFlowBatch", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockMFlowBatch(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockMFlowBatch(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockMFlowBatch", 0, traceParam, "")
		}

	case "stockMFlowByDay":
		var stReq HMFlowByDayReq
		var stRsp HMFlowByDayRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockMFlowByDay", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockMFlowByDay(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockMFlowByDay(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockMFlowByDay", 0, traceParam, "")
		}

	case "mfByTrade":
		var stReq HMFByTradeReq
		var stRsp HMFByTradeRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "mfByTrade", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.MfByTrade(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.MfByTrade(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "mfByTrade", 0, traceParam, "")
		}

	case "stockMFlowData":
		var stReq HStockMFlowDataReq
		var stRsp HStockMFlowDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockMFlowData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockMFlowData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockMFlowData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockMFlowData", 0, traceParam, "")
		}

	case "stockBatchMFlowData":
		var stReq HStockBatchMFlowDataReq
		var stRsp HStockBatchMFlowDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockBatchMFlowData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockBatchMFlowData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockBatchMFlowData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockBatchMFlowData", 0, traceParam, "")
		}

	case "kLineData":
		var stReq HKLineDataReq
		var stRsp HKLineDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "kLineData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.KLineData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.KLineData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "kLineData", 0, traceParam, "")
		}

	case "kLineDataSimple":
		var stReq HKLineDataSimpleReq
		var stRsp HKLineDataSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "kLineDataSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.KLineDataSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.KLineDataSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "kLineDataSimple", 0, traceParam, "")
		}

	case "regKLine":
		var stReq HRegKLineReq
		var stRsp HRegKLineRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regKLine", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RegKLine(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RegKLine(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regKLine", 0, traceParam, "")
		}

	case "regKLineSimple":
		var stReq HRegKLineSimpleReq
		var stRsp HRegKLineSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regKLineSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RegKLineSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RegKLineSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regKLineSimple", 0, traceParam, "")
		}

	case "kLineDataByPeriod":
		var stReq HKLineDataByPeriodReq
		var stRsp HKLineDataByPeriodRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "kLineDataByPeriod", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.KLineDataByPeriod(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.KLineDataByPeriod(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "kLineDataByPeriod", 0, traceParam, "")
		}

	case "kLineDataByPeriodSimple":
		var stReq HKLineDataByPeriodSimpleReq
		var stRsp HKLineDataByPeriodSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "kLineDataByPeriodSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.KLineDataByPeriodSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.KLineDataByPeriodSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "kLineDataByPeriodSimple", 0, traceParam, "")
		}

	case "stockKLineData":
		var stReq HStockKLineReq
		var stRsp HStockKLineRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockKLineData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockKLineData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockKLineData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockKLineData", 0, traceParam, "")
		}

	case "mfRank":
		var stReq HMFlowRankReq
		var stRsp HMFlowRankRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "mfRank", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.MfRank(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.MfRank(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "mfRank", 0, traceParam, "")
		}

	case "stockDDERank":
		var stReq HDDERankReq
		var stRsp HDDERankRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDDERank", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockDDERank(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockDDERank(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDDERank", 0, traceParam, "")
		}

	case "stockDDEBatch":
		var stReq HStockDDEBatchReq
		var stRsp HStockDDEBatchRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDDEBatch", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockDDEBatch(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockDDEBatch(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDDEBatch", 0, traceParam, "")
		}

	case "dxjl":
		var stReq HDxjlReq
		var stRsp HDxjlRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "dxjl", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Dxjl(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Dxjl(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "dxjl", 0, traceParam, "")
		}

	case "l2Monit":
		var stReq HL2MonitReq
		var stRsp HL2MonitRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "l2Monit", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.L2Monit(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.L2Monit(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "l2Monit", 0, traceParam, "")
		}

	case "l2Szfy":
		var stReq HLV2SZFYReq
		var stRsp HLV2SZFYRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "l2Szfy", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.L2Szfy(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.L2Szfy(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "l2Szfy", 0, traceParam, "")
		}

	case "l2SzfyCom":
		var stReq HSZFYComReq
		var stRsp HSZFYComRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "l2SzfyCom", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.L2SzfyCom(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.L2SzfyCom(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "l2SzfyCom", 0, traceParam, "")
		}

	case "stockAHList":
		var stReq HStockAHListReq
		var stRsp HStockAHListRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockAHList", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockAHList(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockAHList(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockAHList", 0, traceParam, "")
		}

	case "stockAH":
		var stReq HStockAHReq
		var stRsp HStockAHRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockAH", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockAH(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockAH(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockAH", 0, traceParam, "")
		}

	case "stockAHBatch":
		var stReq HStockAHReq
		var stRsp HStockAHBatchRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockAHBatch", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockAHBatch(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockAHBatch(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockAHBatch", 0, traceParam, "")
		}

	case "stockDDZ":
		var stReq HStockDDZReq
		var stRsp HStockDDZRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDDZ", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockDDZ(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockDDZ(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockDDZ", 0, traceParam, "")
		}

	case "brokerQueue":
		var stReq HBrokerQueueReq
		var stRsp HBrokerQueueRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "brokerQueue", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.BrokerQueue(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.BrokerQueue(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "brokerQueue", 0, traceParam, "")
		}

	case "regStatus":
		var stReq HRegStatusReq
		var stRsp HRegStatusRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regStatus", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RegStatus(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RegStatus(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regStatus", 0, traceParam, "")
		}

	case "setCltInfo":
		var stReq HCltInfoReq
		var stRsp HCltInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "setCltInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.SetCltInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.SetCltInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "setCltInfo", 0, traceParam, "")
		}

	case "getNewStockPerform":
		var stReq HNewStockPerformReq
		var stRsp HNewStockPerformRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getNewStockPerform", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetNewStockPerform(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetNewStockPerform(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getNewStockPerform", 0, traceParam, "")
		}

	case "getNewStockPerformByStock":
		var stReq HNewStockPerformByStockReq
		var stRsp HNewStockPerformRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getNewStockPerformByStock", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetNewStockPerformByStock(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetNewStockPerformByStock(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getNewStockPerformByStock", 0, traceParam, "")
		}

	case "rangeStats":
		var stReq HRangeStatsReq
		var stRsp HRangeStatsRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "rangeStats", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RangeStats(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RangeStats(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "rangeStats", 0, traceParam, "")
		}

	case "hotPlateHq":
		var stReq HHotPlateReq
		var stRsp HHotPlateRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hotPlateHq", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.HotPlateHq(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.HotPlateHq(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hotPlateHq", 0, traceParam, "")
		}

	case "type2Stock":
		var stReq HType2StockReq
		var stRsp HType2StockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "type2Stock", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Type2Stock(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Type2Stock(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "type2Stock", 0, traceParam, "")
		}

	case "typeList":
		var stReq HType2StockReq
		var stRsp HType2StockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "typeList", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.TypeList(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.TypeList(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "typeList", 0, traceParam, "")
		}

	case "typeListSimple":
		var stReq HTypeListSimpleReq
		var stRsp HType2StockSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "typeListSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.TypeListSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.TypeListSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "typeListSimple", 0, traceParam, "")
		}

	case "type2StockSimple":
		var stReq HType2StockSimpleReq
		var stRsp HType2StockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "type2StockSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Type2StockSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Type2StockSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "type2StockSimple", 0, traceParam, "")
		}

	case "busList":
		var stReq HType2StockSimpleReq
		var stRsp HType2StockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "busList", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.BusList(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.BusList(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "busList", 0, traceParam, "")
		}

	case "busListSimple":
		var stReq HBusListSimpleReq
		var stRsp HType2StockSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "busListSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.BusListSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.BusListSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "busListSimple", 0, traceParam, "")
		}

	case "block2Stock":
		var stReq HBlock2StockReq
		var stRsp HBlock2StockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "block2Stock", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Block2Stock(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Block2Stock(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "block2Stock", 0, traceParam, "")
		}

	case "blockList":
		var stReq HBlock2StockReq
		var stRsp HBlock2StockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "blockList", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.BlockList(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.BlockList(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "blockList", 0, traceParam, "")
		}

	case "blockListSimple":
		var stReq HBlock2StockSimpleReq
		var stRsp HBlock2StockSimpleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "blockListSimple", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.BlockListSimple(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.BlockListSimple(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "blockListSimple", 0, traceParam, "")
		}

	case "blockTsLevel":
		var stReq HTsBlockLevelReq
		var stRsp HTsBlockLevelRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "blockTsLevel", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.BlockTsLevel(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.BlockTsLevel(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "blockTsLevel", 0, traceParam, "")
		}

	case "customType2Stock":
		var stReq HCustomType2StockReq
		var stRsp HType2StockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "customType2Stock", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.CustomType2Stock(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.CustomType2Stock(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "customType2Stock", 0, traceParam, "")
		}

	case "sortList":
		var stReq HSortListReq
		var stRsp HSortListRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "sortList", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.SortList(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.SortList(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "sortList", 0, traceParam, "")
		}

	case "stock2Block":
		var stReq HStock2BlockReq
		var stRsp HStock2BlockRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stock2Block", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Stock2Block(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Stock2Block(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stock2Block", 0, traceParam, "")
		}

	case "stock2Industry":
		var stReq HStock2IndustryReq
		var stRsp HStock2IndustryRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stock2Industry", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Stock2Industry(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Stock2Industry(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stock2Industry", 0, traceParam, "")
		}

	case "regCPTMin":
		var stReq HRegCPTMinReq
		var stRsp HRegCPTMinRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regCPTMin", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RegCPTMin(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RegCPTMin(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regCPTMin", 0, traceParam, "")
		}

	case "regMarketInit":
		var stReq HRegMarketInitReq
		var stRsp HRegMarketInitRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regMarketInit", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RegMarketInit(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RegMarketInit(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regMarketInit", 0, traceParam, "")
		}

	case "regCodes":
		var stReq HRegCodesReq
		var stRsp HRegCodesRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regCodes", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RegCodes(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RegCodes(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "regCodes", 0, traceParam, "")
		}

	case "orderQueue":
		var stReq HOrderQueueReq
		var stRsp HOrderQueueRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "orderQueue", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.OrderQueue(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.OrderQueue(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "orderQueue", 0, traceParam, "")
		}

	case "transData":
		var stReq HTransDataReq
		var stRsp HTransDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "transData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.TransData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.TransData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "transData", 0, traceParam, "")
		}

	case "orderRec":
		var stReq HOrderRecReq
		var stRsp HOrderRecRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "orderRec", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.OrderRec(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.OrderRec(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "orderRec", 0, traceParam, "")
		}

	case "priceOrder":
		var stReq HPriceOrderReq
		var stRsp HPriceOrderRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "priceOrder", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.PriceOrder(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.PriceOrder(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "priceOrder", 0, traceParam, "")
		}

	case "radarQt":
		var stReq HRadarQtReq
		var stRsp HRadarQtRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "radarQt", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RadarQt(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RadarQt(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "radarQt", 0, traceParam, "")
		}

	case "radarChg":
		var stReq HRadarChgReq
		var stRsp HRadarChgRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "radarChg", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.RadarChg(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.RadarChg(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "radarChg", 0, traceParam, "")
		}

	case "priceAmount":
		var stReq HPriceAmountReq
		var stRsp HPriceAmountRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "priceAmount", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.PriceAmount(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.PriceAmount(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "priceAmount", 0, traceParam, "")
		}

	case "orderbook":
		var stReq HOrderBookReq
		var stRsp HOrderBookRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "orderbook", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Orderbook(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Orderbook(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "orderbook", 0, traceParam, "")
		}

	case "orderClassify":
		var stReq HOrderClassifyReq
		var stRsp HOrderClassifyRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "orderClassify", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.OrderClassify(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.OrderClassify(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "orderClassify", 0, traceParam, "")
		}

	case "l2PankouRadio":
		var stReq HPankouRadioReq
		var stRsp HPankouRadioRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "l2PankouRadio", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.L2PankouRadio(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.L2PankouRadio(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "l2PankouRadio", 0, traceParam, "")
		}

	case "L2Synt":
		var stReq HSyntReq
		var stRsp HSyntRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "L2Synt", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.L2Synt(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.L2Synt(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "L2Synt", 0, traceParam, "")
		}

	case "hkWarrant":
		var stReq HHkWarrantReq
		var stRsp HHkWarrantRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hkWarrant", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.HkWarrant(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.HkWarrant(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "hkWarrant", 0, traceParam, "")
		}

	case "serverInfo":
		var stReq HServerInfoReq
		var stRsp HServerInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "serverInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.ServerInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.ServerInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "serverInfo", 0, traceParam, "")
		}

	case "checkUserPermission":
		var stReq HUserPermissionReq
		var stRsp HUserPermissionRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "checkUserPermission", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.CheckUserPermission(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.CheckUserPermission(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "checkUserPermission", 0, traceParam, "")
		}

	case "warrantHk":
		var stReq HWarrantHkReq
		var stRsp HWarrantHkRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "warrantHk", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.WarrantHk(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.WarrantHk(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "warrantHk", 0, traceParam, "")
		}

	case "volPrice":
		var stReq HVolPriceReq
		var stRsp HVolPriceRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "volPrice", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.VolPrice(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.VolPrice(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "volPrice", 0, traceParam, "")
		}

	case "allOrderPersp":
		var stReq HAllOrderPerspReq
		var stRsp HAllOrderPerspRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "allOrderPersp", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.AllOrderPersp(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.AllOrderPersp(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "allOrderPersp", 0, traceParam, "")
		}

	case "getMonitorInfo":
		var stReq GetMonitorInfoReq
		var stRsp GetMonitorInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getMonitorInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetMonitorInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetMonitorInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getMonitorInfo", 0, traceParam, "")
		}

	case "getMarketTradeCale":
		var stReq GetMarketTradeCaleReq
		var stRsp GetMarketTradeCaleRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getMarketTradeCale", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetMarketTradeCale(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetMarketTradeCale(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getMarketTradeCale", 0, traceParam, "")
		}

	case "getSysMonitorInfo":
		var stReq HSysMonitorReq
		var stRsp HSysMonitorRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSysMonitorInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetSysMonitorInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetSysMonitorInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSysMonitorInfo", 0, traceParam, "")
		}

	case "getGuidSet":
		var stReq HGetGuidReq
		var stRsp HGetGuidRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getGuidSet", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetGuidSet(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetGuidSet(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getGuidSet", 0, traceParam, "")
		}

	case "getSNInfo":
		var stReq HGetSNInfoReq
		var stRsp HGetSNInfoRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSNInfo", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetSNInfo(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetSNInfo(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSNInfo", 0, traceParam, "")
		}

	case "getGGTQXData":
		var stReq HGGTQXReq
		var stRsp HGGTQXRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getGGTQXData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetGGTQXData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetGGTQXData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getGGTQXData", 0, traceParam, "")
		}

	case "getGGTRate":
		var stReq HGGTRateReq
		var stRsp HGGTRateRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getGGTRate", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetGGTRate(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetGGTRate(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getGGTRate", 0, traceParam, "")
		}

	case "getYYData":
		var stReq HYYDataReq
		var stRsp HYYDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getYYData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetYYData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetYYData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getYYData", 0, traceParam, "")
		}

	case "getFXData":
		var stReq HFXDataReq
		var stRsp HFXDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getFXData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetFXData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetFXData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getFXData", 0, traceParam, "")
		}

	case "getSouthMoneyFlow":
		var stReq GetSouthMoneyFlowReq
		var stRsp GetSouthMoneyFlowRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSouthMoneyFlow", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetSouthMoneyFlow(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetSouthMoneyFlow(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSouthMoneyFlow", 0, traceParam, "")
		}

	case "getFutureNameList":
		var stReq HFutureNameListReq
		var stRsp HFutureNameListRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getFutureNameList", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetFutureNameList(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetFutureNameList(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getFutureNameList", 0, traceParam, "")
		}

	case "getRtminAuction":
		var stReq HRtminAuctionReq
		var stRsp HRtminAuctionRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getRtminAuction", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetRtminAuction(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetRtminAuction(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getRtminAuction", 0, traceParam, "")
		}

	case "getSNFundsData":
		var stReq HSNFundDataReq
		var stRsp HSNFundDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSNFundsData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetSNFundsData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetSNFundsData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSNFundsData", 0, traceParam, "")
		}

	case "getSNNetData":
		var stReq HSNNetDataReq
		var stRsp HSNNetDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSNNetData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetSNNetData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetSNNetData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getSNNetData", 0, traceParam, "")
		}

	case "getHisSNNetData":
		var stReq HHisSNNetDataReq
		var stRsp HHisSNNetDataRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getHisSNNetData", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetHisSNNetData(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetHisSNNetData(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getHisSNNetData", 0, traceParam, "")
		}

	case "jpjl":
		var stReq HJPJLReq
		var stRsp HJPJLRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "jpjl", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.Jpjl(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.Jpjl(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "jpjl", 0, traceParam, "")
		}

	case "stockRank":
		var stReq HStockRankReq
		var stRsp HStockRankRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockRank", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.StockRank(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.StockRank(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "stockRank", 0, traceParam, "")
		}

	case "getXrdFactor":
		var stReq HXrdFactorReq
		var stRsp HXrdFactorRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getXrdFactor", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetXrdFactor(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetXrdFactor(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getXrdFactor", 0, traceParam, "")
		}

	case "getZDFenBu":
		var stReq HZDFenbuReq
		var stRsp HZDFenbuRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getZDFenBu", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetZDFenBu(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetZDFenBu(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getZDFenBu", 0, traceParam, "")
		}

	case "getTradeStatusName":
		var stReq HTradeStatusNameReq
		var stRsp HTradeStatusNameRsp

		if tafReq.IVersion == basef.JCEVERSION {

			err = stReq.ReadBlock(_is, 1, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_reqWup_ := wup.NewUniAttribute()
			_reqWup_.Decode(_is)

			var _wupBuffer_ []byte

			_reqWup_.GetBuffer("stReq", &_wupBuffer_)
			_is.Reset(_wupBuffer_)
			err = stReq.ReadBlock(_is, 0, true)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.JSONVERSION {
			var _jsonDat_ map[string]interface{}
			_decoder_ := json.NewDecoder(bytes.NewReader(_is.ToBytes()))
			_decoder_.UseNumber()
			err = _decoder_.Decode(&_jsonDat_)
			if err != nil {
				return fmt.Errorf("Decode reqpacket failed, error: %+v", err)
			}
			{
				_jsonStr_, _ := json.Marshal(_jsonDat_["stReq"])
				stReq.ResetDefault()
				if err = json.Unmarshal([]byte(_jsonStr_), &stReq); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("Decode reqpacket fail, error version: %d", tafReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(tafCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(_is.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["stReq"] = stReq
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getTradeStatusName", 0, traceParam, "")
		}

		var _funRet_ int32
		if _withContext == false {
			_imp := _val.(_impBasicHq)
			_funRet_, err = _imp.GetTradeStatusName(&stReq, &stRsp)
		} else {
			_imp := _val.(_impBasicHqWithContext)
			_funRet_, err = _imp.GetTradeStatusName(tafCtx, &stReq, &stRsp)
		}

		if err != nil {
			return err
		}

		if tafReq.IVersion == basef.JCEVERSION {
			_os.Reset()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			err = stRsp.WriteBlock(_os, 2)
			if err != nil {
				return err
			}

		} else if tafReq.IVersion == basef.WUPVERSION {
			_wupRsp_ := wup.NewUniAttribute()

			err = _os.Write_int32(_funRet_, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("", _os.ToBytes())
			_wupRsp_.PutBuffer("taf_ret", _os.ToBytes())

			_os.Reset()
			err = stRsp.WriteBlock(_os, 0)
			if err != nil {
				return err
			}

			_wupRsp_.PutBuffer("stRsp", _os.ToBytes())

			_os.Reset()
			err = _wupRsp_.Encode(_os)
			if err != nil {
				return err
			}
		} else if tafReq.IVersion == basef.JSONVERSION {
			_rspJson_ := map[string]interface{}{}
			_rspJson_["taf_ret"] = _funRet_
			_rspJson_[""] = _funRet_
			_rspJson_["stRsp"] = stRsp

			var _rspByte_ []byte
			if _rspByte_, err = json.Marshal(_rspJson_); err != nil {
				return err
			}

			_os.Reset()
			err = _os.Write_slice_uint8(_rspByte_)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(_os.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = _funRet_
				value["taf_ret"] = _funRet_
				value["stRsp"] = stRsp
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			taf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, taf.GetClientConfig().ModuleName, tafReq.SServantName, "getTradeStatusName", 0, traceParam, "")
		}

	default:
		return fmt.Errorf("func mismatch")
	}
	var _status map[string]string
	s, ok := current.GetResponseStatus(tafCtx)
	if ok && s != nil {
		_status = s
	}
	var _context map[string]string
	c, ok := current.GetResponseContext(tafCtx)
	if ok && c != nil {
		_context = c
	}
	*tafResp = requestf.BasePacket{
		IVersion:     tafReq.IVersion,
		CPacketType:  0,
		IRequestId:   tafReq.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(_os.ToBytes()),
		Status:       _status,
		SResultDesc:  "",
		Context:      _context,
	}

	_ = _is
	_ = _os
	_ = length
	_ = have
	_ = ty
	return nil
}
