// Package RadarData comment
// This file was generated by jce2go 2.0.0
// Generated from RadarData.jce
package RadarData

import (
	"fmt"

	"gitlab.upchinaproduct.com/taf/tafgo/taf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type E_STARS_LEVEL int32

const (
	E_STARS_LEVEL_E_STARS_NONE   = 0
	E_STARS_LEVEL_E_STARS_LEVEL1 = 1
	E_STARS_LEVEL_E_STARS_LEVEL2 = 2
	E_STARS_LEVEL_E_STARS_LEVEL3 = 3
	E_STARS_LEVEL_E_STARS_LEVEL4 = 4
)

type E_STRENGTH_CHANGE int32

const (
	E_STRENGTH_CHANGE_NO_CHANGE   = 1
	E_STRENGTH_CHANGE_UP_CHANGE   = 2
	E_STRENGTH_CHANGE_DOWN_CHANGE = 3
)

type E_RADAR_TYPE int32

const (
	E_RADAR_TYPE_E_RADAR_BUY  = 1
	E_RADAR_TYPE_E_RADAR_SELL = 2
)

// Temperature struct implement
type Temperature struct {
	codec.JceStructBase
	IMarket       int32   `json:"iMarket"`
	SCode         string  `json:"sCode"`
	IUpdateTime   int32   `json:"iUpdateTime"`
	DblStrength   float64 `json:"dblStrength"`
	LStrengthBuy  int64   `json:"lStrengthBuy"`
	LStrengthSell int64   `json:"lStrengthSell"`
	DblLatent     float64 `json:"dblLatent"`
	LLatentBuy    int64   `json:"lLatentBuy"`
	LLatentSell   int64   `json:"lLatentSell"`
}

func (st *Temperature) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *Temperature) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IUpdateTime, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DblStrength, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LStrengthBuy, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LStrengthSell, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DblLatent, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LLatentBuy, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LLatentSell, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Temperature) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Temperature, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Temperature) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IUpdateTime, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DblStrength, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LStrengthBuy, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LStrengthSell, 5)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DblLatent, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LLatentBuy, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LLatentSell, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Temperature) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *Temperature) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iMarket:", st.IMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iUpdateTime:", st.IUpdateTime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dblStrength:", st.DblStrength)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lStrengthBuy:", st.LStrengthBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lStrengthSell:", st.LStrengthSell)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dblLatent:", st.DblLatent)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lLatentBuy:", st.LLatentBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lLatentSell:", st.LLatentSell)

	ret = ret + " }"
	return ret
}

// RadarQt struct implement
type RadarQt struct {
	codec.JceStructBase
	IStockID      int32             `json:"iStockID"`
	ITime         int32             `json:"iTime"`
	DblStrength   float64           `json:"dblStrength"`
	EStarsLevel   E_STARS_LEVEL     `json:"eStarsLevel"`
	LStrengthBuy  int64             `json:"lStrengthBuy"`
	LStrengthSell int64             `json:"lStrengthSell"`
	EChgFlag      E_STRENGTH_CHANGE `json:"eChgFlag"`
	DNowPrice     float64           `json:"dNowPrice"`
	DPrevPrice    float64           `json:"dPrevPrice"`
}

func (st *RadarQt) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *RadarQt) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IStockID, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITime, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DblStrength, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStarsLevel), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LStrengthBuy, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LStrengthSell, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EChgFlag), 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNowPrice, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrevPrice, 9, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RadarQt) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RadarQt, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RadarQt) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IStockID, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITime, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DblStrength, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStarsLevel), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LStrengthBuy, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LStrengthSell, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EChgFlag), 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNowPrice, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrevPrice, 9)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RadarQt) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *RadarQt) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iStockID:", st.IStockID)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dblStrength:", st.DblStrength)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStarsLevel:", st.EStarsLevel)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lStrengthBuy:", st.LStrengthBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lStrengthSell:", st.LStrengthSell)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eChgFlag:", st.EChgFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNowPrice:", st.DNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrevPrice:", st.DPrevPrice)

	ret = ret + " }"
	return ret
}

// RadarChg struct implement
type RadarChg struct {
	codec.JceStructBase
	IStockID      int32             `json:"iStockID"`
	ITime         int32             `json:"iTime"`
	EType         E_RADAR_TYPE      `json:"eType"`
	EStarsLevel   E_STARS_LEVEL     `json:"eStarsLevel"`
	LStrengthBuy  int64             `json:"lStrengthBuy"`
	LStrengthSell int64             `json:"lStrengthSell"`
	EChgFlag      E_STRENGTH_CHANGE `json:"eChgFlag"`
	DNowPrice     float64           `json:"dNowPrice"`
	DPrevPrice    float64           `json:"dPrevPrice"`
}

func (st *RadarChg) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *RadarChg) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IStockID, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ITime, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EType), 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EStarsLevel), 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LStrengthBuy, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LStrengthSell, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32((*int32)(&st.EChgFlag), 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DNowPrice, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DPrevPrice, 9, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RadarChg) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RadarChg, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RadarChg) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IStockID, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ITime, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EType), 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EStarsLevel), 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LStrengthBuy, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LStrengthSell, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(st.EChgFlag), 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DNowPrice, 8)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DPrevPrice, 9)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RadarChg) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *RadarChg) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iStockID:", st.IStockID)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eType:", st.EType)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eStarsLevel:", st.EStarsLevel)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lStrengthBuy:", st.LStrengthBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lStrengthSell:", st.LStrengthSell)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("eChgFlag:", st.EChgFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dNowPrice:", st.DNowPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dPrevPrice:", st.DPrevPrice)

	ret = ret + " }"
	return ret
}

// RadarQtList struct implement
type RadarQtList struct {
	codec.JceStructBase
	VRadarQt []RadarQt `json:"vRadarQt"`
}

func (st *RadarQtList) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *RadarQtList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VRadarQt = make([]RadarQt, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VRadarQt[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RadarQtList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RadarQtList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RadarQtList) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VRadarQt)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VRadarQt {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RadarQtList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *RadarQtList) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vRadarQt:", st.VRadarQt)

	ret = ret + " }"
	return ret
}

// RadarRtMin struct implement
type RadarRtMin struct {
	codec.JceStructBase
	UiStockID       uint32  `json:"uiStockID"`
	ITime           uint32  `json:"iTime"`
	DblRtStrength   float64 `json:"dblRtStrength"`
	LRtStrengthBuy  int64   `json:"lRtStrengthBuy"`
	LRtStrengthSell int64   `json:"lRtStrengthSell"`
}

func (st *RadarRtMin) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *RadarRtMin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_uint32(&st.UiStockID, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.ITime, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DblRtStrength, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LRtStrengthBuy, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.LRtStrengthSell, 5, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RadarRtMin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RadarRtMin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RadarRtMin) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_uint32(st.UiStockID, 1)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.ITime, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DblRtStrength, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LRtStrengthBuy, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.LRtStrengthSell, 5)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RadarRtMin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *RadarRtMin) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("uiStockID:", st.UiStockID)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iTime:", st.ITime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dblRtStrength:", st.DblRtStrength)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lRtStrengthBuy:", st.LRtStrengthBuy)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("lRtStrengthSell:", st.LRtStrengthSell)

	ret = ret + " }"
	return ret
}

// RadarRtMinList struct implement
type RadarRtMinList struct {
	codec.JceStructBase
	BClear    bool         `json:"bClear"`
	UiStockID uint32       `json:"uiStockID"`
	VData     []RadarRtMin `json:"vData"`
}

func (st *RadarRtMinList) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *RadarRtMinList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_bool(&st.BClear, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_uint32(&st.UiStockID, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VData = make([]RadarRtMin, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VData[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RadarRtMinList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RadarRtMinList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RadarRtMinList) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_bool(st.BClear, 1)
	if err != nil {
		return err
	}

	err = _os.Write_uint32(st.UiStockID, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VData)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VData {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RadarRtMinList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *RadarRtMinList) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("bClear:", st.BClear)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("uiStockID:", st.UiStockID)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vData:", st.VData)

	ret = ret + " }"
	return ret
}

// RadarRtMinBatchList struct implement
type RadarRtMinBatchList struct {
	codec.JceStructBase
	VStock []RadarRtMinList `json:"vStock"`
}

func (st *RadarRtMinBatchList) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *RadarRtMinBatchList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VStock = make([]RadarRtMinList, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VStock[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RadarRtMinBatchList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RadarRtMinBatchList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RadarRtMinBatchList) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VStock)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VStock {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RadarRtMinBatchList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *RadarRtMinBatchList) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vStock:", st.VStock)

	ret = ret + " }"
	return ret
}

// TempList struct implement
type TempList struct {
	codec.JceStructBase
	IDate         int32         `json:"iDate"`
	IFlag         int32         `json:"iFlag"`
	VtTemperature []Temperature `json:"vtTemperature"`
}

func (st *TempList) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *TempList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IDate, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IFlag, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VtTemperature = make([]Temperature, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VtTemperature[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TempList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TempList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TempList) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IDate, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IFlag, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VtTemperature)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VtTemperature {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TempList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *TempList) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iDate:", st.IDate)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iFlag:", st.IFlag)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("vtTemperature:", st.VtTemperature)

	ret = ret + " }"
	return ret
}

// JumpOrder struct implement
type JumpOrder struct {
	codec.JceStructBase
	IMarket       int32   `json:"iMarket"`
	SCode         string  `json:"sCode"`
	IOrdertime    int32   `json:"iOrdertime"`
	DOrderPrice   float64 `json:"dOrderPrice"`
	DCurPrice     float64 `json:"dCurPrice"`
	IBuyOrderVol  int32   `json:"iBuyOrderVol"`
	ISellOrderVol int32   `json:"iSellOrderVol"`
	DBuyTransAmt  float64 `json:"dBuyTransAmt"`
	DSellTransAmt float64 `json:"dSellTransAmt"`
}

func (st *JumpOrder) ResetDefault() {
	st.JceStructBase.ResetPrecision()
}

//ReadFrom reads  from _is and put into struct.
func (st *JumpOrder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err = _is.Read_int32(&st.IMarket, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.SCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IOrdertime, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DOrderPrice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DCurPrice, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.IBuyOrderVol, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.ISellOrderVol, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DBuyTransAmt, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.DSellTransAmt, 8, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *JumpOrder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JumpOrder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *JumpOrder) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.Write_int32(st.IMarket, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.SCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IOrdertime, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DOrderPrice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DCurPrice, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.IBuyOrderVol, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.ISellOrderVol, 6)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DBuyTransAmt, 7)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.DSellTransAmt, 8)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *JumpOrder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *JumpOrder) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("iMarket:", st.IMarket)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("sCode:", st.SCode)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iOrdertime:", st.IOrdertime)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dOrderPrice:", st.DOrderPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dCurPrice:", st.DCurPrice)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iBuyOrderVol:", st.IBuyOrderVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("iSellOrderVol:", st.ISellOrderVol)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dBuyTransAmt:", st.DBuyTransAmt)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("dSellTransAmt:", st.DSellTransAmt)

	ret = ret + " }"
	return ret
}

// JumpOrderList struct implement
type JumpOrderList struct {
	codec.JceStructBase
	VJump  []JumpOrder `json:"vJump"`
	BReset bool        `json:"bReset"`
}

func (st *JumpOrderList) ResetDefault() {
	st.JceStructBase.ResetPrecision()
	st.BReset = false
}

//ReadFrom reads  from _is and put into struct.
func (st *JumpOrderList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_is.SavePrecision()

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.VJump = make([]JumpOrder, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.VJump[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.BReset, 2, false)
	if err != nil {
		return err
	}

	st.SetPrecision(_is.ResumePrecision())

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *JumpOrderList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JumpOrderList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *JumpOrderList) WriteTo(_os *codec.Buffer) error {
	var err error

	_os.SavePrecision(st.GetPrecision())

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.VJump)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VJump {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.BReset, 2)
	if err != nil {
		return err
	}

	_os.ResumePrecision()

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *JumpOrderList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

//Display this struct to a string.
func (st *JumpOrderList) Display() string {
	var ret string
	ret = "{ "
	ret = ret + fmt.Sprint("vJump:", st.VJump)
	ret = ret + ",  "
	ret = ret + fmt.Sprint("bReset:", st.BReset)

	ret = ret + " }"
	return ret
}
